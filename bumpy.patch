diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/qgl.h bumpy-code/code/renderer/qgl.h
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/qgl.h	2014-06-09 22:09:45.526844462 -0400
+++ bumpy-code/code/renderer/qgl.h	2014-06-09 22:14:52.593548742 -0400
@@ -44,6 +44,13 @@
 #include <windows.h>
 #include <GL/gl.h>
 
+
+typedef ptrdiff_t GLsizeiptrARB;
+typedef ptrdiff_t GLintptrARB;
+typedef unsigned int GLhandleARB;	// shader object handle 
+typedef char GLcharARB;		// native character 
+
+
 #elif defined(MACOS_X)
 
 #include <OpenGL/OpenGL.h>
@@ -181,6 +189,149 @@
 
 // extensions will be function pointers on all platforms
 
+extern GLvoid (APIENTRY * qglDeleteObjectARB) (GLhandleARB obj);
+extern GLhandleARB (APIENTRY * qglGetHandleARB) (GLenum pname);
+extern GLvoid (APIENTRY * qglDetachObjectARB) (GLhandleARB containerObj, GLhandleARB attachedObj);
+extern GLhandleARB (APIENTRY * qglCreateShaderObjectARB) (GLenum shaderType);
+extern GLvoid (APIENTRY * qglShaderSourceARB) (GLhandleARB shaderObj, GLsizei count, const GLcharARB **string,
+				       const GLint *length);
+extern GLvoid (APIENTRY * qglCompileShaderARB) (GLhandleARB shaderObj);
+extern GLhandleARB (APIENTRY * qglCreateProgramObjectARB) (void);
+extern GLvoid (APIENTRY * qglAttachObjectARB) (GLhandleARB containerObj, GLhandleARB obj);
+extern GLvoid (APIENTRY * qglLinkProgramARB) (GLhandleARB programObj);
+extern GLvoid (APIENTRY * qglUseProgramObjectARB) (GLhandleARB programObj);
+extern GLvoid (APIENTRY * qglValidateProgramARB) (GLhandleARB programObj);
+extern GLvoid (APIENTRY * qglUniform1fARB) (GLint location, GLfloat v0);
+extern GLvoid (APIENTRY * qglUniform2fARB) (GLint location, GLfloat v0, GLfloat v1);
+extern GLvoid (APIENTRY * qglUniform3fARB) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+extern GLvoid (APIENTRY * qglUniform4fARB) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+extern GLvoid (APIENTRY * qglUniform1iARB) (GLint location, GLint v0);
+extern GLvoid (APIENTRY * qglUniform2iARB) (GLint location, GLint v0, GLint v1);
+extern GLvoid (APIENTRY * qglUniform3iARB) (GLint location, GLint v0, GLint v1, GLint v2);
+extern GLvoid (APIENTRY * qglUniform4iARB) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+extern GLvoid (APIENTRY * qglUniform1fvARB) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRY * qglUniform2fvARB) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRY * qglUniform3fvARB) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRY * qglUniform4fvARB) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRY * qglUniform1ivARB) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRY * qglUniform2ivARB) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRY * qglUniform3ivARB) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRY * qglUniform4ivARB) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRY * qglUniformMatrix2fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+extern GLvoid (APIENTRY * qglUniformMatrix3fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+extern GLvoid (APIENTRY * qglUniformMatrix4fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+extern GLvoid (APIENTRY * qglGetObjectParameterfvARB) (GLhandleARB obj, GLenum pname, GLfloat *params);
+extern GLvoid (APIENTRY * qglGetObjectParameterivARB) (GLhandleARB obj, GLenum pname, GLint *params);
+extern GLvoid (APIENTRY * qglGetInfoLogARB) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
+extern GLvoid (APIENTRY * qglGetAttachedObjectsARB) (GLhandleARB containerObj, GLsizei maxCount, GLsizei *count,
+					     GLhandleARB *obj);
+extern GLint(APIENTRY * qglGetUniformLocationARB) (GLhandleARB programObj, const GLcharARB * name);
+extern GLvoid (APIENTRY * qglGetActiveUniformARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
+					   GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+extern GLvoid (APIENTRY * qglGetUniformfvARB) (GLhandleARB programObj, GLint location, GLfloat *params);
+extern GLvoid (APIENTRY * qglGetUniformivARB) (GLhandleARB programObj, GLint location, GLint *params);
+extern GLvoid (APIENTRY * qglGetShaderSourceARB) (GLhandleARB obj, GLsizei maxLength, GLsizei *length,
+					  GLcharARB *source);
+
+
+extern GLvoid (APIENTRY * qglVertexAttrib1fARB) (GLuint index, GLfloat v0);
+extern GLvoid (APIENTRY * qglVertexAttrib1sARB) (GLuint index, GLshort v0);
+extern GLvoid (APIENTRY * qglVertexAttrib1dARB) (GLuint index, GLdouble v0);
+extern GLvoid (APIENTRY * qglVertexAttrib2fARB) (GLuint index, GLfloat v0, GLfloat v1);
+extern GLvoid (APIENTRY * qglVertexAttrib2sARB) (GLuint index, GLshort v0, GLshort v1);
+extern GLvoid (APIENTRY * qglVertexAttrib2dARB) (GLuint index, GLdouble v0, GLdouble v1);
+extern GLvoid (APIENTRY * qglVertexAttrib3fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2);
+extern GLvoid (APIENTRY * qglVertexAttrib3sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2);
+extern GLvoid (APIENTRY * qglVertexAttrib3dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
+extern GLvoid (APIENTRY * qglVertexAttrib4fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+extern GLvoid (APIENTRY * qglVertexAttrib4sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3);
+extern GLvoid (APIENTRY * qglVertexAttrib4dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
+extern GLvoid (APIENTRY * qglVertexAttrib4NubARB) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+extern GLvoid (APIENTRY * qglVertexAttrib1fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRY * qglVertexAttrib1svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRY * qglVertexAttrib1dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRY * qglVertexAttrib2fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRY * qglVertexAttrib2svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRY * qglVertexAttrib2dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRY * qglVertexAttrib3fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRY * qglVertexAttrib3svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRY * qglVertexAttrib3dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRY * qglVertexAttrib4fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRY * qglVertexAttrib4svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRY * qglVertexAttrib4dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRY * qglVertexAttrib4ivARB) (GLuint index, GLint *v);
+extern GLvoid (APIENTRY * qglVertexAttrib4bvARB) (GLuint index, GLbyte *v);
+extern GLvoid (APIENTRY * qglVertexAttrib4ubvARB) (GLuint index, GLubyte *v);
+extern GLvoid (APIENTRY * qglVertexAttrib4usvARB) (GLuint index, GLushort *v);
+extern GLvoid (APIENTRY * qglVertexAttrib4uivARB) (GLuint index, GLuint *v);
+extern GLvoid (APIENTRY * qglVertexAttrib4NbvARB) (GLuint index, const GLbyte *v);
+extern GLvoid (APIENTRY * qglVertexAttrib4NsvARB) (GLuint index, const GLshort *v);
+extern GLvoid (APIENTRY * qglVertexAttrib4NivARB) (GLuint index, const GLint *v);
+extern GLvoid (APIENTRY * qglVertexAttrib4NubvARB) (GLuint index, const GLubyte *v);
+extern GLvoid (APIENTRY * qglVertexAttrib4NusvARB) (GLuint index, const GLushort *v);
+extern GLvoid (APIENTRY * qglVertexAttrib4NuivARB) (GLuint index, const GLuint *v);
+extern GLvoid (APIENTRY * qglVertexAttribPointerARB) (GLuint index, GLint size, GLenum type, GLboolean normalized,
+					      GLsizei stride, const GLvoid *pointer);
+extern GLvoid (APIENTRY * qglEnableVertexAttribArrayARB) (GLuint index);
+extern GLvoid (APIENTRY * qglDisableVertexAttribArrayARB) (GLuint index);
+extern GLvoid (APIENTRY * qglBindAttribLocationARB) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
+extern GLvoid (APIENTRY * qglGetActiveAttribARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
+					  GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+extern GLint(APIENTRY * qglGetAttribLocationARB) (GLhandleARB programObj, const GLcharARB * name);
+extern GLvoid (APIENTRY * qglGetVertexAttribdvARB) (GLuint index, GLenum pname, GLdouble *params);
+extern GLvoid (APIENTRY * qglGetVertexAttribfvARB) (GLuint index, GLenum pname, GLfloat *params);
+extern GLvoid (APIENTRY * qglGetVertexAttribivARB) (GLuint index, GLenum pname, GLint *params);
+extern GLvoid (APIENTRY * qglGetVertexAttribPointervARB) (GLuint index, GLenum pname, GLvoid **pointer);
+
+
+extern GLboolean (APIENTRY * qglIsRenderbufferEXT) (GLuint renderbuffer);
+extern GLvoid (APIENTRY * qglBindRenderbufferEXT) (GLenum target, GLuint renderbuffer);
+extern GLvoid (APIENTRY * qglDeleteRenderbuffersEXT) (GLsizei n, const GLuint *renderbuffers);
+extern GLvoid (APIENTRY * qglGenRenderbuffersEXT) (GLsizei n, GLuint *renderbuffers);
+extern GLvoid (APIENTRY * qglRenderbufferStorageEXT) (GLenum target, GLenum internalformat,
+					   GLsizei width, GLsizei height);
+extern GLvoid (APIENTRY * qglGetRenderbufferParameterivEXT) (GLenum target, GLenum pname, GLint *params);
+extern GLboolean (APIENTRY * qglIsFramebufferEXT) (GLuint framebuffer);
+extern GLvoid (APIENTRY * qglBindFramebufferEXT) (GLenum target, GLuint framebuffer);
+extern GLvoid (APIENTRY * qglDeleteFramebuffersEXT) (GLsizei n, const GLuint *framebuffers);
+extern GLvoid (APIENTRY * qglGenFramebuffersEXT) (GLsizei n, GLuint *framebuffers);
+extern GLenum (APIENTRY * qglCheckFramebufferStatusEXT) (GLenum target);
+extern GLvoid (APIENTRY * qglFramebufferTexture1DEXT) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture, GLint level);
+extern GLvoid (APIENTRY * qglFramebufferTexture2DEXT) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture, GLint level);
+extern GLvoid (APIENTRY * qglFramebufferTexture3DEXT) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture,
+					    GLint level, GLint layer);
+extern GLvoid (APIENTRY * qglFramebufferRenderbufferEXT) (GLenum target, GLenum attachment,
+					       GLenum renderbuffertarget, GLuint renderbuffer);
+extern GLvoid (APIENTRY * qglGetFramebufferAttachmentParameterivEXT) (GLenum target, GLenum attachment,
+							   GLenum pname, GLint *params);
+extern GLvoid (APIENTRY * qglGenerateMipmapEXT) (GLenum target);
+
+
+extern GLvoid (APIENTRY * qglGenQueriesARB) (GLsizei n, GLuint *ids);
+extern GLvoid (APIENTRY * qglDeleteQueriesARB) (GLsizei n, const GLuint *ids);
+extern GLboolean (APIENTRY * qglIsQueryARB) (GLuint id);
+extern GLvoid (APIENTRY * qglBeginQueryARB) (GLenum target, GLuint id);
+extern GLvoid (APIENTRY * qglEndQueryARB) (GLenum target);
+extern GLvoid (APIENTRY * qglGetQueryivARB) (GLenum target, GLenum pname, GLint *params);
+extern GLvoid (APIENTRY * qglGetQueryObjectivARB) (GLuint id, GLenum pname, GLint *params);
+extern GLvoid (APIENTRY * qglGetQueryObjectuivARB) (GLuint id, GLenum pname, GLuint *params);
+
+extern 	void (APIENTRY * qglBindBufferARB) (GLenum target, GLuint buffer);
+extern	void (APIENTRY * qglDeleteBuffersARB) (GLsizei n, const GLuint * buffers);
+extern	void (APIENTRY * qglGenBuffersARB) (GLsizei n, GLuint * buffers);
+extern	GLboolean (APIENTRY * qglIsBufferARB) (GLuint buffer);
+extern	void (APIENTRY * qglBufferDataARB) (GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage);
+extern	void (APIENTRY * qglBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data);
+extern	void (APIENTRY * qglGetBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid * data);
+extern	GLvoid *(APIENTRY * qglMapBufferARB) (GLenum target, GLenum access);
+extern	GLboolean (APIENTRY * qglUnmapBufferARB) (GLenum target);
+extern	void (APIENTRY * qglGetBufferParameterivARB) (GLenum target, GLenum pname, GLint * params);
+extern	void (APIENTRY * qglGetBufferPointervARB) (GLenum target, GLenum pname, GLvoid * *params);
+
+
 extern	void ( APIENTRY * qglMultiTexCoord2fARB )( GLenum texture, GLfloat s, GLfloat t );
 extern	void ( APIENTRY * qglActiveTextureARB )( GLenum texture );
 extern	void ( APIENTRY * qglClientActiveTextureARB )( GLenum texture );
@@ -188,6 +339,8 @@
 extern	void ( APIENTRY * qglLockArraysEXT) (GLint, GLint);
 extern	void ( APIENTRY * qglUnlockArraysEXT) (void);
 
+
+extern void (APIENTRY * qglDrawRangeElementsEXT) (GLenum mode, GLsizei count, GLuint start, GLuint end, GLenum type, const GLvoid *indices);
 //===========================================================================
 
 // non-dlopening systems will just redefine qgl* to gl*
@@ -603,4 +756,2986 @@
 
 #endif	// _WIN32 && __linux__
 
+
+#define GL_GLEXT_VERSION 29
+
+#ifndef GL_VERSION_1_2
+#define GL_UNSIGNED_BYTE_3_3_2            0x8032
+#define GL_UNSIGNED_SHORT_4_4_4_4         0x8033
+#define GL_UNSIGNED_SHORT_5_5_5_1         0x8034
+#define GL_UNSIGNED_INT_8_8_8_8           0x8035
+#define GL_UNSIGNED_INT_10_10_10_2        0x8036
+#define GL_RESCALE_NORMAL                 0x803A
+#define GL_TEXTURE_BINDING_3D             0x806A
+#define GL_PACK_SKIP_IMAGES               0x806B
+#define GL_PACK_IMAGE_HEIGHT              0x806C
+#define GL_UNPACK_SKIP_IMAGES             0x806D
+#define GL_UNPACK_IMAGE_HEIGHT            0x806E
+#define GL_TEXTURE_3D                     0x806F
+#define GL_PROXY_TEXTURE_3D               0x8070
+#define GL_TEXTURE_DEPTH                  0x8071
+#define GL_TEXTURE_WRAP_R                 0x8072
+#define GL_MAX_3D_TEXTURE_SIZE            0x8073
+#define GL_UNSIGNED_BYTE_2_3_3_REV        0x8362
+#define GL_UNSIGNED_SHORT_5_6_5           0x8363
+#define GL_UNSIGNED_SHORT_5_6_5_REV       0x8364
+#define GL_UNSIGNED_SHORT_4_4_4_4_REV     0x8365
+#define GL_UNSIGNED_SHORT_1_5_5_5_REV     0x8366
+#define GL_UNSIGNED_INT_8_8_8_8_REV       0x8367
+#define GL_UNSIGNED_INT_2_10_10_10_REV    0x8368
+#define GL_BGR                            0x80E0
+#define GL_BGRA                           0x80E1
+#define GL_MAX_ELEMENTS_VERTICES          0x80E8
+#define GL_MAX_ELEMENTS_INDICES           0x80E9
+#define GL_CLAMP_TO_EDGE                  0x812F
+#define GL_TEXTURE_MIN_LOD                0x813A
+#define GL_TEXTURE_MAX_LOD                0x813B
+#define GL_TEXTURE_BASE_LEVEL             0x813C
+#define GL_TEXTURE_MAX_LEVEL              0x813D
+#define GL_LIGHT_MODEL_COLOR_CONTROL      0x81F8
+#define GL_SINGLE_COLOR                   0x81F9
+#define GL_SEPARATE_SPECULAR_COLOR        0x81FA
+#define GL_SMOOTH_POINT_SIZE_RANGE        0x0B12
+#define GL_SMOOTH_POINT_SIZE_GRANULARITY  0x0B13
+#define GL_SMOOTH_LINE_WIDTH_RANGE        0x0B22
+#define GL_SMOOTH_LINE_WIDTH_GRANULARITY  0x0B23
+#define GL_ALIASED_POINT_SIZE_RANGE       0x846D
+#define GL_ALIASED_LINE_WIDTH_RANGE       0x846E
+#endif
+
+#ifndef GL_ARB_imaging
+#define GL_CONSTANT_COLOR                 0x8001
+#define GL_ONE_MINUS_CONSTANT_COLOR       0x8002
+#define GL_CONSTANT_ALPHA                 0x8003
+#define GL_ONE_MINUS_CONSTANT_ALPHA       0x8004
+#define GL_BLEND_COLOR                    0x8005
+#define GL_FUNC_ADD                       0x8006
+#define GL_MIN                            0x8007
+#define GL_MAX                            0x8008
+#define GL_BLEND_EQUATION                 0x8009
+#define GL_FUNC_SUBTRACT                  0x800A
+#define GL_FUNC_REVERSE_SUBTRACT          0x800B
+#define GL_CONVOLUTION_1D                 0x8010
+#define GL_CONVOLUTION_2D                 0x8011
+#define GL_SEPARABLE_2D                   0x8012
+#define GL_CONVOLUTION_BORDER_MODE        0x8013
+#define GL_CONVOLUTION_FILTER_SCALE       0x8014
+#define GL_CONVOLUTION_FILTER_BIAS        0x8015
+#define GL_REDUCE                         0x8016
+#define GL_CONVOLUTION_FORMAT             0x8017
+#define GL_CONVOLUTION_WIDTH              0x8018
+#define GL_CONVOLUTION_HEIGHT             0x8019
+#define GL_MAX_CONVOLUTION_WIDTH          0x801A
+#define GL_MAX_CONVOLUTION_HEIGHT         0x801B
+#define GL_POST_CONVOLUTION_RED_SCALE     0x801C
+#define GL_POST_CONVOLUTION_GREEN_SCALE   0x801D
+#define GL_POST_CONVOLUTION_BLUE_SCALE    0x801E
+#define GL_POST_CONVOLUTION_ALPHA_SCALE   0x801F
+#define GL_POST_CONVOLUTION_RED_BIAS      0x8020
+#define GL_POST_CONVOLUTION_GREEN_BIAS    0x8021
+#define GL_POST_CONVOLUTION_BLUE_BIAS     0x8022
+#define GL_POST_CONVOLUTION_ALPHA_BIAS    0x8023
+#define GL_HISTOGRAM                      0x8024
+#define GL_PROXY_HISTOGRAM                0x8025
+#define GL_HISTOGRAM_WIDTH                0x8026
+#define GL_HISTOGRAM_FORMAT               0x8027
+#define GL_HISTOGRAM_RED_SIZE             0x8028
+#define GL_HISTOGRAM_GREEN_SIZE           0x8029
+#define GL_HISTOGRAM_BLUE_SIZE            0x802A
+#define GL_HISTOGRAM_ALPHA_SIZE           0x802B
+#define GL_HISTOGRAM_LUMINANCE_SIZE       0x802C
+#define GL_HISTOGRAM_SINK                 0x802D
+#define GL_MINMAX                         0x802E
+#define GL_MINMAX_FORMAT                  0x802F
+#define GL_MINMAX_SINK                    0x8030
+#define GL_TABLE_TOO_LARGE                0x8031
+#define GL_COLOR_MATRIX                   0x80B1
+#define GL_COLOR_MATRIX_STACK_DEPTH       0x80B2
+#define GL_MAX_COLOR_MATRIX_STACK_DEPTH   0x80B3
+#define GL_POST_COLOR_MATRIX_RED_SCALE    0x80B4
+#define GL_POST_COLOR_MATRIX_GREEN_SCALE  0x80B5
+#define GL_POST_COLOR_MATRIX_BLUE_SCALE   0x80B6
+#define GL_POST_COLOR_MATRIX_ALPHA_SCALE  0x80B7
+#define GL_POST_COLOR_MATRIX_RED_BIAS     0x80B8
+#define GL_POST_COLOR_MATRIX_GREEN_BIAS   0x80B9
+#define GL_POST_COLOR_MATRIX_BLUE_BIAS    0x80BA
+#define GL_POST_COLOR_MATRIX_ALPHA_BIAS   0x80BB
+#define GL_COLOR_TABLE                    0x80D0
+#define GL_POST_CONVOLUTION_COLOR_TABLE   0x80D1
+#define GL_POST_COLOR_MATRIX_COLOR_TABLE  0x80D2
+#define GL_PROXY_COLOR_TABLE              0x80D3
+#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE 0x80D4
+#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE 0x80D5
+#define GL_COLOR_TABLE_SCALE              0x80D6
+#define GL_COLOR_TABLE_BIAS               0x80D7
+#define GL_COLOR_TABLE_FORMAT             0x80D8
+#define GL_COLOR_TABLE_WIDTH              0x80D9
+#define GL_COLOR_TABLE_RED_SIZE           0x80DA
+#define GL_COLOR_TABLE_GREEN_SIZE         0x80DB
+#define GL_COLOR_TABLE_BLUE_SIZE          0x80DC
+#define GL_COLOR_TABLE_ALPHA_SIZE         0x80DD
+#define GL_COLOR_TABLE_LUMINANCE_SIZE     0x80DE
+#define GL_COLOR_TABLE_INTENSITY_SIZE     0x80DF
+#define GL_CONSTANT_BORDER                0x8151
+#define GL_REPLICATE_BORDER               0x8153
+#define GL_CONVOLUTION_BORDER_COLOR       0x8154
+#endif
+
+#ifndef GL_VERSION_1_3
+#define GL_TEXTURE0                       0x84C0
+#define GL_TEXTURE1                       0x84C1
+#define GL_TEXTURE2                       0x84C2
+#define GL_TEXTURE3                       0x84C3
+#define GL_TEXTURE4                       0x84C4
+#define GL_TEXTURE5                       0x84C5
+#define GL_TEXTURE6                       0x84C6
+#define GL_TEXTURE7                       0x84C7
+#define GL_TEXTURE8                       0x84C8
+#define GL_TEXTURE9                       0x84C9
+#define GL_TEXTURE10                      0x84CA
+#define GL_TEXTURE11                      0x84CB
+#define GL_TEXTURE12                      0x84CC
+#define GL_TEXTURE13                      0x84CD
+#define GL_TEXTURE14                      0x84CE
+#define GL_TEXTURE15                      0x84CF
+#define GL_TEXTURE16                      0x84D0
+#define GL_TEXTURE17                      0x84D1
+#define GL_TEXTURE18                      0x84D2
+#define GL_TEXTURE19                      0x84D3
+#define GL_TEXTURE20                      0x84D4
+#define GL_TEXTURE21                      0x84D5
+#define GL_TEXTURE22                      0x84D6
+#define GL_TEXTURE23                      0x84D7
+#define GL_TEXTURE24                      0x84D8
+#define GL_TEXTURE25                      0x84D9
+#define GL_TEXTURE26                      0x84DA
+#define GL_TEXTURE27                      0x84DB
+#define GL_TEXTURE28                      0x84DC
+#define GL_TEXTURE29                      0x84DD
+#define GL_TEXTURE30                      0x84DE
+#define GL_TEXTURE31                      0x84DF
+#define GL_ACTIVE_TEXTURE                 0x84E0
+#define GL_CLIENT_ACTIVE_TEXTURE          0x84E1
+#define GL_MAX_TEXTURE_UNITS              0x84E2
+#define GL_TRANSPOSE_MODELVIEW_MATRIX     0x84E3
+#define GL_TRANSPOSE_PROJECTION_MATRIX    0x84E4
+#define GL_TRANSPOSE_TEXTURE_MATRIX       0x84E5
+#define GL_TRANSPOSE_COLOR_MATRIX         0x84E6
+#define GL_MULTISAMPLE                    0x809D
+#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE            0x809F
+#define GL_SAMPLE_COVERAGE                0x80A0
+#define GL_SAMPLE_BUFFERS                 0x80A8
+#define GL_SAMPLES                        0x80A9
+#define GL_SAMPLE_COVERAGE_VALUE          0x80AA
+#define GL_SAMPLE_COVERAGE_INVERT         0x80AB
+#define GL_MULTISAMPLE_BIT                0x20000000
+#define GL_NORMAL_MAP                     0x8511
+#define GL_REFLECTION_MAP                 0x8512
+#define GL_TEXTURE_CUBE_MAP               0x8513
+#define GL_TEXTURE_BINDING_CUBE_MAP       0x8514
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_X    0x8515
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X    0x8516
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y    0x8517
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y    0x8518
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z    0x8519
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z    0x851A
+#define GL_PROXY_TEXTURE_CUBE_MAP         0x851B
+#define GL_MAX_CUBE_MAP_TEXTURE_SIZE      0x851C
+#define GL_COMPRESSED_ALPHA               0x84E9
+#define GL_COMPRESSED_LUMINANCE           0x84EA
+#define GL_COMPRESSED_LUMINANCE_ALPHA     0x84EB
+#define GL_COMPRESSED_INTENSITY           0x84EC
+#define GL_COMPRESSED_RGB                 0x84ED
+#define GL_COMPRESSED_RGBA                0x84EE
+#define GL_TEXTURE_COMPRESSION_HINT       0x84EF
+#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE  0x86A0
+#define GL_TEXTURE_COMPRESSED             0x86A1
+#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
+#define GL_COMPRESSED_TEXTURE_FORMATS     0x86A3
+#define GL_CLAMP_TO_BORDER                0x812D
+#define GL_COMBINE                        0x8570
+#define GL_COMBINE_RGB                    0x8571
+#define GL_COMBINE_ALPHA                  0x8572
+#define GL_SOURCE0_RGB                    0x8580
+#define GL_SOURCE1_RGB                    0x8581
+#define GL_SOURCE2_RGB                    0x8582
+#define GL_SOURCE0_ALPHA                  0x8588
+#define GL_SOURCE1_ALPHA                  0x8589
+#define GL_SOURCE2_ALPHA                  0x858A
+#define GL_OPERAND0_RGB                   0x8590
+#define GL_OPERAND1_RGB                   0x8591
+#define GL_OPERAND2_RGB                   0x8592
+#define GL_OPERAND0_ALPHA                 0x8598
+#define GL_OPERAND1_ALPHA                 0x8599
+#define GL_OPERAND2_ALPHA                 0x859A
+#define GL_RGB_SCALE                      0x8573
+#define GL_ADD_SIGNED                     0x8574
+#define GL_INTERPOLATE                    0x8575
+#define GL_SUBTRACT                       0x84E7
+#define GL_CONSTANT                       0x8576
+#define GL_PRIMARY_COLOR                  0x8577
+#define GL_PREVIOUS                       0x8578
+#define GL_DOT3_RGB                       0x86AE
+#define GL_DOT3_RGBA                      0x86AF
+#endif
+
+#ifndef GL_VERSION_1_4
+#define GL_BLEND_DST_RGB                  0x80C8
+#define GL_BLEND_SRC_RGB                  0x80C9
+#define GL_BLEND_DST_ALPHA                0x80CA
+#define GL_BLEND_SRC_ALPHA                0x80CB
+#define GL_POINT_SIZE_MIN                 0x8126
+#define GL_POINT_SIZE_MAX                 0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE      0x8128
+#define GL_POINT_DISTANCE_ATTENUATION     0x8129
+#define GL_GENERATE_MIPMAP                0x8191
+#define GL_GENERATE_MIPMAP_HINT           0x8192
+#define GL_DEPTH_COMPONENT16              0x81A5
+#define GL_DEPTH_COMPONENT24              0x81A6
+#define GL_DEPTH_COMPONENT32              0x81A7
+#define GL_MIRRORED_REPEAT                0x8370
+#define GL_FOG_COORDINATE_SOURCE          0x8450
+#define GL_FOG_COORDINATE                 0x8451
+#define GL_FRAGMENT_DEPTH                 0x8452
+#define GL_CURRENT_FOG_COORDINATE         0x8453
+#define GL_FOG_COORDINATE_ARRAY_TYPE      0x8454
+#define GL_FOG_COORDINATE_ARRAY_STRIDE    0x8455
+#define GL_FOG_COORDINATE_ARRAY_POINTER   0x8456
+#define GL_FOG_COORDINATE_ARRAY           0x8457
+#define GL_COLOR_SUM                      0x8458
+#define GL_CURRENT_SECONDARY_COLOR        0x8459
+#define GL_SECONDARY_COLOR_ARRAY_SIZE     0x845A
+#define GL_SECONDARY_COLOR_ARRAY_TYPE     0x845B
+#define GL_SECONDARY_COLOR_ARRAY_STRIDE   0x845C
+#define GL_SECONDARY_COLOR_ARRAY_POINTER  0x845D
+#define GL_SECONDARY_COLOR_ARRAY          0x845E
+#define GL_MAX_TEXTURE_LOD_BIAS           0x84FD
+#define GL_TEXTURE_FILTER_CONTROL         0x8500
+#define GL_TEXTURE_LOD_BIAS               0x8501
+#define GL_INCR_WRAP                      0x8507
+#define GL_DECR_WRAP                      0x8508
+#define GL_TEXTURE_DEPTH_SIZE             0x884A
+#define GL_DEPTH_TEXTURE_MODE             0x884B
+#define GL_TEXTURE_COMPARE_MODE           0x884C
+#define GL_TEXTURE_COMPARE_FUNC           0x884D
+#define GL_COMPARE_R_TO_TEXTURE           0x884E
+#endif
+
+#ifndef GL_VERSION_1_5
+#define GL_BUFFER_SIZE                    0x8764
+#define GL_BUFFER_USAGE                   0x8765
+#define GL_QUERY_COUNTER_BITS             0x8864
+#define GL_CURRENT_QUERY                  0x8865
+#define GL_QUERY_RESULT                   0x8866
+#define GL_QUERY_RESULT_AVAILABLE         0x8867
+#define GL_ARRAY_BUFFER                   0x8892
+#define GL_ELEMENT_ARRAY_BUFFER           0x8893
+#define GL_ARRAY_BUFFER_BINDING           0x8894
+#define GL_ELEMENT_ARRAY_BUFFER_BINDING   0x8895
+#define GL_VERTEX_ARRAY_BUFFER_BINDING    0x8896
+#define GL_NORMAL_ARRAY_BUFFER_BINDING    0x8897
+#define GL_COLOR_ARRAY_BUFFER_BINDING     0x8898
+#define GL_INDEX_ARRAY_BUFFER_BINDING     0x8899
+#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING 0x889A
+#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING 0x889B
+#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING 0x889C
+#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING 0x889D
+#define GL_WEIGHT_ARRAY_BUFFER_BINDING    0x889E
+#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
+#define GL_READ_ONLY                      0x88B8
+#define GL_WRITE_ONLY                     0x88B9
+#define GL_READ_WRITE                     0x88BA
+#define GL_BUFFER_ACCESS                  0x88BB
+#define GL_BUFFER_MAPPED                  0x88BC
+#define GL_BUFFER_MAP_POINTER             0x88BD
+#define GL_STREAM_DRAW                    0x88E0
+#define GL_STREAM_READ                    0x88E1
+#define GL_STREAM_COPY                    0x88E2
+#define GL_STATIC_DRAW                    0x88E4
+#define GL_STATIC_READ                    0x88E5
+#define GL_STATIC_COPY                    0x88E6
+#define GL_DYNAMIC_DRAW                   0x88E8
+#define GL_DYNAMIC_READ                   0x88E9
+#define GL_DYNAMIC_COPY                   0x88EA
+#define GL_SAMPLES_PASSED                 0x8914
+#define GL_FOG_COORD_SRC                  GL_FOG_COORDINATE_SOURCE
+#define GL_FOG_COORD                      GL_FOG_COORDINATE
+#define GL_CURRENT_FOG_COORD              GL_CURRENT_FOG_COORDINATE
+#define GL_FOG_COORD_ARRAY_TYPE           GL_FOG_COORDINATE_ARRAY_TYPE
+#define GL_FOG_COORD_ARRAY_STRIDE         GL_FOG_COORDINATE_ARRAY_STRIDE
+#define GL_FOG_COORD_ARRAY_POINTER        GL_FOG_COORDINATE_ARRAY_POINTER
+#define GL_FOG_COORD_ARRAY                GL_FOG_COORDINATE_ARRAY
+#define GL_FOG_COORD_ARRAY_BUFFER_BINDING GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING
+#define GL_SRC0_RGB                       GL_SOURCE0_RGB
+#define GL_SRC1_RGB                       GL_SOURCE1_RGB
+#define GL_SRC2_RGB                       GL_SOURCE2_RGB
+#define GL_SRC0_ALPHA                     GL_SOURCE0_ALPHA
+#define GL_SRC1_ALPHA                     GL_SOURCE1_ALPHA
+#define GL_SRC2_ALPHA                     GL_SOURCE2_ALPHA
+#endif
+
+#ifndef GL_VERSION_2_0
+#define GL_BLEND_EQUATION_RGB             GL_BLEND_EQUATION
+#define GL_VERTEX_ATTRIB_ARRAY_ENABLED    0x8622
+#define GL_VERTEX_ATTRIB_ARRAY_SIZE       0x8623
+#define GL_VERTEX_ATTRIB_ARRAY_STRIDE     0x8624
+#define GL_VERTEX_ATTRIB_ARRAY_TYPE       0x8625
+#define GL_CURRENT_VERTEX_ATTRIB          0x8626
+#define GL_VERTEX_PROGRAM_POINT_SIZE      0x8642
+#define GL_VERTEX_PROGRAM_TWO_SIDE        0x8643
+#define GL_VERTEX_ATTRIB_ARRAY_POINTER    0x8645
+#define GL_STENCIL_BACK_FUNC              0x8800
+#define GL_STENCIL_BACK_FAIL              0x8801
+#define GL_STENCIL_BACK_PASS_DEPTH_FAIL   0x8802
+#define GL_STENCIL_BACK_PASS_DEPTH_PASS   0x8803
+#define GL_MAX_DRAW_BUFFERS               0x8824
+#define GL_DRAW_BUFFER0                   0x8825
+#define GL_DRAW_BUFFER1                   0x8826
+#define GL_DRAW_BUFFER2                   0x8827
+#define GL_DRAW_BUFFER3                   0x8828
+#define GL_DRAW_BUFFER4                   0x8829
+#define GL_DRAW_BUFFER5                   0x882A
+#define GL_DRAW_BUFFER6                   0x882B
+#define GL_DRAW_BUFFER7                   0x882C
+#define GL_DRAW_BUFFER8                   0x882D
+#define GL_DRAW_BUFFER9                   0x882E
+#define GL_DRAW_BUFFER10                  0x882F
+#define GL_DRAW_BUFFER11                  0x8830
+#define GL_DRAW_BUFFER12                  0x8831
+#define GL_DRAW_BUFFER13                  0x8832
+#define GL_DRAW_BUFFER14                  0x8833
+#define GL_DRAW_BUFFER15                  0x8834
+#define GL_BLEND_EQUATION_ALPHA           0x883D
+#define GL_POINT_SPRITE                   0x8861
+#define GL_COORD_REPLACE                  0x8862
+#define GL_MAX_VERTEX_ATTRIBS             0x8869
+#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
+#define GL_MAX_TEXTURE_COORDS             0x8871
+#define GL_MAX_TEXTURE_IMAGE_UNITS        0x8872
+#define GL_FRAGMENT_SHADER                0x8B30
+#define GL_VERTEX_SHADER                  0x8B31
+#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
+#define GL_MAX_VERTEX_UNIFORM_COMPONENTS  0x8B4A
+#define GL_MAX_VARYING_FLOATS             0x8B4B
+#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
+#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
+#define GL_SHADER_TYPE                    0x8B4F
+#define GL_FLOAT_VEC2                     0x8B50
+#define GL_FLOAT_VEC3                     0x8B51
+#define GL_FLOAT_VEC4                     0x8B52
+#define GL_INT_VEC2                       0x8B53
+#define GL_INT_VEC3                       0x8B54
+#define GL_INT_VEC4                       0x8B55
+#define GL_BOOL                           0x8B56
+#define GL_BOOL_VEC2                      0x8B57
+#define GL_BOOL_VEC3                      0x8B58
+#define GL_BOOL_VEC4                      0x8B59
+#define GL_FLOAT_MAT2                     0x8B5A
+#define GL_FLOAT_MAT3                     0x8B5B
+#define GL_FLOAT_MAT4                     0x8B5C
+#define GL_SAMPLER_1D                     0x8B5D
+#define GL_SAMPLER_2D                     0x8B5E
+#define GL_SAMPLER_3D                     0x8B5F
+#define GL_SAMPLER_CUBE                   0x8B60
+#define GL_SAMPLER_1D_SHADOW              0x8B61
+#define GL_SAMPLER_2D_SHADOW              0x8B62
+#define GL_DELETE_STATUS                  0x8B80
+#define GL_COMPILE_STATUS                 0x8B81
+#define GL_LINK_STATUS                    0x8B82
+#define GL_VALIDATE_STATUS                0x8B83
+#define GL_INFO_LOG_LENGTH                0x8B84
+#define GL_ATTACHED_SHADERS               0x8B85
+#define GL_ACTIVE_UNIFORMS                0x8B86
+#define GL_ACTIVE_UNIFORM_MAX_LENGTH      0x8B87
+#define GL_SHADER_SOURCE_LENGTH           0x8B88
+#define GL_ACTIVE_ATTRIBUTES              0x8B89
+#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH    0x8B8A
+#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
+#define GL_SHADING_LANGUAGE_VERSION       0x8B8C
+#define GL_CURRENT_PROGRAM                0x8B8D
+#define GL_POINT_SPRITE_COORD_ORIGIN      0x8CA0
+#define GL_LOWER_LEFT                     0x8CA1
+#define GL_UPPER_LEFT                     0x8CA2
+#define GL_STENCIL_BACK_REF               0x8CA3
+#define GL_STENCIL_BACK_VALUE_MASK        0x8CA4
+#define GL_STENCIL_BACK_WRITEMASK         0x8CA5
+#endif
+
+#ifndef GL_ARB_multitexture
+#define GL_TEXTURE0_ARB                   0x84C0
+#define GL_TEXTURE1_ARB                   0x84C1
+#define GL_TEXTURE2_ARB                   0x84C2
+#define GL_TEXTURE3_ARB                   0x84C3
+#define GL_TEXTURE4_ARB                   0x84C4
+#define GL_TEXTURE5_ARB                   0x84C5
+#define GL_TEXTURE6_ARB                   0x84C6
+#define GL_TEXTURE7_ARB                   0x84C7
+#define GL_TEXTURE8_ARB                   0x84C8
+#define GL_TEXTURE9_ARB                   0x84C9
+#define GL_TEXTURE10_ARB                  0x84CA
+#define GL_TEXTURE11_ARB                  0x84CB
+#define GL_TEXTURE12_ARB                  0x84CC
+#define GL_TEXTURE13_ARB                  0x84CD
+#define GL_TEXTURE14_ARB                  0x84CE
+#define GL_TEXTURE15_ARB                  0x84CF
+#define GL_TEXTURE16_ARB                  0x84D0
+#define GL_TEXTURE17_ARB                  0x84D1
+#define GL_TEXTURE18_ARB                  0x84D2
+#define GL_TEXTURE19_ARB                  0x84D3
+#define GL_TEXTURE20_ARB                  0x84D4
+#define GL_TEXTURE21_ARB                  0x84D5
+#define GL_TEXTURE22_ARB                  0x84D6
+#define GL_TEXTURE23_ARB                  0x84D7
+#define GL_TEXTURE24_ARB                  0x84D8
+#define GL_TEXTURE25_ARB                  0x84D9
+#define GL_TEXTURE26_ARB                  0x84DA
+#define GL_TEXTURE27_ARB                  0x84DB
+#define GL_TEXTURE28_ARB                  0x84DC
+#define GL_TEXTURE29_ARB                  0x84DD
+#define GL_TEXTURE30_ARB                  0x84DE
+#define GL_TEXTURE31_ARB                  0x84DF
+#define GL_ACTIVE_TEXTURE_ARB             0x84E0
+#define GL_CLIENT_ACTIVE_TEXTURE_ARB      0x84E1
+#define GL_MAX_TEXTURE_UNITS_ARB          0x84E2
+#endif
+
+#ifndef GL_ARB_transpose_matrix
+#define GL_TRANSPOSE_MODELVIEW_MATRIX_ARB 0x84E3
+#define GL_TRANSPOSE_PROJECTION_MATRIX_ARB 0x84E4
+#define GL_TRANSPOSE_TEXTURE_MATRIX_ARB   0x84E5
+#define GL_TRANSPOSE_COLOR_MATRIX_ARB     0x84E6
+#endif
+
+#ifndef GL_ARB_multisample
+#define GL_MULTISAMPLE_ARB                0x809D
+#define GL_SAMPLE_ALPHA_TO_COVERAGE_ARB   0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE_ARB        0x809F
+#define GL_SAMPLE_COVERAGE_ARB            0x80A0
+#define GL_SAMPLE_BUFFERS_ARB             0x80A8
+#define GL_SAMPLES_ARB                    0x80A9
+#define GL_SAMPLE_COVERAGE_VALUE_ARB      0x80AA
+#define GL_SAMPLE_COVERAGE_INVERT_ARB     0x80AB
+#define GL_MULTISAMPLE_BIT_ARB            0x20000000
+#endif
+
+#ifndef GL_ARB_texture_env_add
+#endif
+
+#ifndef GL_ARB_texture_cube_map
+#define GL_NORMAL_MAP_ARB                 0x8511
+#define GL_REFLECTION_MAP_ARB             0x8512
+#define GL_TEXTURE_CUBE_MAP_ARB           0x8513
+#define GL_TEXTURE_BINDING_CUBE_MAP_ARB   0x8514
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB 0x8515
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB 0x8516
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB 0x8517
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB 0x8518
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB 0x8519
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB 0x851A
+#define GL_PROXY_TEXTURE_CUBE_MAP_ARB     0x851B
+#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB  0x851C
+#endif
+
+#ifndef GL_ARB_texture_compression
+#define GL_COMPRESSED_ALPHA_ARB           0x84E9
+#define GL_COMPRESSED_LUMINANCE_ARB       0x84EA
+#define GL_COMPRESSED_LUMINANCE_ALPHA_ARB 0x84EB
+#define GL_COMPRESSED_INTENSITY_ARB       0x84EC
+#define GL_COMPRESSED_RGB_ARB             0x84ED
+#define GL_COMPRESSED_RGBA_ARB            0x84EE
+#define GL_TEXTURE_COMPRESSION_HINT_ARB   0x84EF
+#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB 0x86A0
+#define GL_TEXTURE_COMPRESSED_ARB         0x86A1
+#define GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A2
+#define GL_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A3
+#endif
+
+#ifndef GL_ARB_texture_border_clamp
+#define GL_CLAMP_TO_BORDER_ARB            0x812D
+#endif
+
+#ifndef GL_ARB_point_parameters
+#define GL_POINT_SIZE_MIN_ARB             0x8126
+#define GL_POINT_SIZE_MAX_ARB             0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE_ARB  0x8128
+#define GL_POINT_DISTANCE_ATTENUATION_ARB 0x8129
+#endif
+
+#ifndef GL_ARB_vertex_blend
+#define GL_MAX_VERTEX_UNITS_ARB           0x86A4
+#define GL_ACTIVE_VERTEX_UNITS_ARB        0x86A5
+#define GL_WEIGHT_SUM_UNITY_ARB           0x86A6
+#define GL_VERTEX_BLEND_ARB               0x86A7
+#define GL_CURRENT_WEIGHT_ARB             0x86A8
+#define GL_WEIGHT_ARRAY_TYPE_ARB          0x86A9
+#define GL_WEIGHT_ARRAY_STRIDE_ARB        0x86AA
+#define GL_WEIGHT_ARRAY_SIZE_ARB          0x86AB
+#define GL_WEIGHT_ARRAY_POINTER_ARB       0x86AC
+#define GL_WEIGHT_ARRAY_ARB               0x86AD
+#define GL_MODELVIEW0_ARB                 0x1700
+#define GL_MODELVIEW1_ARB                 0x850A
+#define GL_MODELVIEW2_ARB                 0x8722
+#define GL_MODELVIEW3_ARB                 0x8723
+#define GL_MODELVIEW4_ARB                 0x8724
+#define GL_MODELVIEW5_ARB                 0x8725
+#define GL_MODELVIEW6_ARB                 0x8726
+#define GL_MODELVIEW7_ARB                 0x8727
+#define GL_MODELVIEW8_ARB                 0x8728
+#define GL_MODELVIEW9_ARB                 0x8729
+#define GL_MODELVIEW10_ARB                0x872A
+#define GL_MODELVIEW11_ARB                0x872B
+#define GL_MODELVIEW12_ARB                0x872C
+#define GL_MODELVIEW13_ARB                0x872D
+#define GL_MODELVIEW14_ARB                0x872E
+#define GL_MODELVIEW15_ARB                0x872F
+#define GL_MODELVIEW16_ARB                0x8730
+#define GL_MODELVIEW17_ARB                0x8731
+#define GL_MODELVIEW18_ARB                0x8732
+#define GL_MODELVIEW19_ARB                0x8733
+#define GL_MODELVIEW20_ARB                0x8734
+#define GL_MODELVIEW21_ARB                0x8735
+#define GL_MODELVIEW22_ARB                0x8736
+#define GL_MODELVIEW23_ARB                0x8737
+#define GL_MODELVIEW24_ARB                0x8738
+#define GL_MODELVIEW25_ARB                0x8739
+#define GL_MODELVIEW26_ARB                0x873A
+#define GL_MODELVIEW27_ARB                0x873B
+#define GL_MODELVIEW28_ARB                0x873C
+#define GL_MODELVIEW29_ARB                0x873D
+#define GL_MODELVIEW30_ARB                0x873E
+#define GL_MODELVIEW31_ARB                0x873F
+#endif
+
+#ifndef GL_ARB_matrix_palette
+#define GL_MATRIX_PALETTE_ARB             0x8840
+#define GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB 0x8841
+#define GL_MAX_PALETTE_MATRICES_ARB       0x8842
+#define GL_CURRENT_PALETTE_MATRIX_ARB     0x8843
+#define GL_MATRIX_INDEX_ARRAY_ARB         0x8844
+#define GL_CURRENT_MATRIX_INDEX_ARB       0x8845
+#define GL_MATRIX_INDEX_ARRAY_SIZE_ARB    0x8846
+#define GL_MATRIX_INDEX_ARRAY_TYPE_ARB    0x8847
+#define GL_MATRIX_INDEX_ARRAY_STRIDE_ARB  0x8848
+#define GL_MATRIX_INDEX_ARRAY_POINTER_ARB 0x8849
+#endif
+
+#ifndef GL_ARB_texture_env_combine
+#define GL_COMBINE_ARB                    0x8570
+#define GL_COMBINE_RGB_ARB                0x8571
+#define GL_COMBINE_ALPHA_ARB              0x8572
+#define GL_SOURCE0_RGB_ARB                0x8580
+#define GL_SOURCE1_RGB_ARB                0x8581
+#define GL_SOURCE2_RGB_ARB                0x8582
+#define GL_SOURCE0_ALPHA_ARB              0x8588
+#define GL_SOURCE1_ALPHA_ARB              0x8589
+#define GL_SOURCE2_ALPHA_ARB              0x858A
+#define GL_OPERAND0_RGB_ARB               0x8590
+#define GL_OPERAND1_RGB_ARB               0x8591
+#define GL_OPERAND2_RGB_ARB               0x8592
+#define GL_OPERAND0_ALPHA_ARB             0x8598
+#define GL_OPERAND1_ALPHA_ARB             0x8599
+#define GL_OPERAND2_ALPHA_ARB             0x859A
+#define GL_RGB_SCALE_ARB                  0x8573
+#define GL_ADD_SIGNED_ARB                 0x8574
+#define GL_INTERPOLATE_ARB                0x8575
+#define GL_SUBTRACT_ARB                   0x84E7
+#define GL_CONSTANT_ARB                   0x8576
+#define GL_PRIMARY_COLOR_ARB              0x8577
+#define GL_PREVIOUS_ARB                   0x8578
+#endif
+
+#ifndef GL_ARB_texture_env_crossbar
+#endif
+
+#ifndef GL_ARB_texture_env_dot3
+#define GL_DOT3_RGB_ARB                   0x86AE
+#define GL_DOT3_RGBA_ARB                  0x86AF
+#endif
+
+#ifndef GL_ARB_texture_mirrored_repeat
+#define GL_MIRRORED_REPEAT_ARB            0x8370
+#endif
+
+#ifndef GL_ARB_depth_texture
+#define GL_DEPTH_COMPONENT16_ARB          0x81A5
+#define GL_DEPTH_COMPONENT24_ARB          0x81A6
+#define GL_DEPTH_COMPONENT32_ARB          0x81A7
+#define GL_TEXTURE_DEPTH_SIZE_ARB         0x884A
+#define GL_DEPTH_TEXTURE_MODE_ARB         0x884B
+#endif
+
+#ifndef GL_ARB_shadow
+#define GL_TEXTURE_COMPARE_MODE_ARB       0x884C
+#define GL_TEXTURE_COMPARE_FUNC_ARB       0x884D
+#define GL_COMPARE_R_TO_TEXTURE_ARB       0x884E
+#endif
+
+#ifndef GL_ARB_shadow_ambient
+#define GL_TEXTURE_COMPARE_FAIL_VALUE_ARB 0x80BF
+#endif
+
+#ifndef GL_ARB_window_pos
+#endif
+
+#ifndef GL_ARB_vertex_program
+#define GL_COLOR_SUM_ARB                  0x8458
+#define GL_VERTEX_PROGRAM_ARB             0x8620
+#define GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB 0x8622
+#define GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB   0x8623
+#define GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB 0x8624
+#define GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB   0x8625
+#define GL_CURRENT_VERTEX_ATTRIB_ARB      0x8626
+#define GL_PROGRAM_LENGTH_ARB             0x8627
+#define GL_PROGRAM_STRING_ARB             0x8628
+#define GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB 0x862E
+#define GL_MAX_PROGRAM_MATRICES_ARB       0x862F
+#define GL_CURRENT_MATRIX_STACK_DEPTH_ARB 0x8640
+#define GL_CURRENT_MATRIX_ARB             0x8641
+#define GL_VERTEX_PROGRAM_POINT_SIZE_ARB  0x8642
+#define GL_VERTEX_PROGRAM_TWO_SIDE_ARB    0x8643
+#define GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB 0x8645
+#define GL_PROGRAM_ERROR_POSITION_ARB     0x864B
+#define GL_PROGRAM_BINDING_ARB            0x8677
+#define GL_MAX_VERTEX_ATTRIBS_ARB         0x8869
+#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB 0x886A
+#define GL_PROGRAM_ERROR_STRING_ARB       0x8874
+#define GL_PROGRAM_FORMAT_ASCII_ARB       0x8875
+#define GL_PROGRAM_FORMAT_ARB             0x8876
+#define GL_PROGRAM_INSTRUCTIONS_ARB       0x88A0
+#define GL_MAX_PROGRAM_INSTRUCTIONS_ARB   0x88A1
+#define GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A2
+#define GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A3
+#define GL_PROGRAM_TEMPORARIES_ARB        0x88A4
+#define GL_MAX_PROGRAM_TEMPORARIES_ARB    0x88A5
+#define GL_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A6
+#define GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A7
+#define GL_PROGRAM_PARAMETERS_ARB         0x88A8
+#define GL_MAX_PROGRAM_PARAMETERS_ARB     0x88A9
+#define GL_PROGRAM_NATIVE_PARAMETERS_ARB  0x88AA
+#define GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB 0x88AB
+#define GL_PROGRAM_ATTRIBS_ARB            0x88AC
+#define GL_MAX_PROGRAM_ATTRIBS_ARB        0x88AD
+#define GL_PROGRAM_NATIVE_ATTRIBS_ARB     0x88AE
+#define GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB 0x88AF
+#define GL_PROGRAM_ADDRESS_REGISTERS_ARB  0x88B0
+#define GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB 0x88B1
+#define GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B2
+#define GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B3
+#define GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB 0x88B4
+#define GL_MAX_PROGRAM_ENV_PARAMETERS_ARB 0x88B5
+#define GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB 0x88B6
+#define GL_TRANSPOSE_CURRENT_MATRIX_ARB   0x88B7
+#define GL_MATRIX0_ARB                    0x88C0
+#define GL_MATRIX1_ARB                    0x88C1
+#define GL_MATRIX2_ARB                    0x88C2
+#define GL_MATRIX3_ARB                    0x88C3
+#define GL_MATRIX4_ARB                    0x88C4
+#define GL_MATRIX5_ARB                    0x88C5
+#define GL_MATRIX6_ARB                    0x88C6
+#define GL_MATRIX7_ARB                    0x88C7
+#define GL_MATRIX8_ARB                    0x88C8
+#define GL_MATRIX9_ARB                    0x88C9
+#define GL_MATRIX10_ARB                   0x88CA
+#define GL_MATRIX11_ARB                   0x88CB
+#define GL_MATRIX12_ARB                   0x88CC
+#define GL_MATRIX13_ARB                   0x88CD
+#define GL_MATRIX14_ARB                   0x88CE
+#define GL_MATRIX15_ARB                   0x88CF
+#define GL_MATRIX16_ARB                   0x88D0
+#define GL_MATRIX17_ARB                   0x88D1
+#define GL_MATRIX18_ARB                   0x88D2
+#define GL_MATRIX19_ARB                   0x88D3
+#define GL_MATRIX20_ARB                   0x88D4
+#define GL_MATRIX21_ARB                   0x88D5
+#define GL_MATRIX22_ARB                   0x88D6
+#define GL_MATRIX23_ARB                   0x88D7
+#define GL_MATRIX24_ARB                   0x88D8
+#define GL_MATRIX25_ARB                   0x88D9
+#define GL_MATRIX26_ARB                   0x88DA
+#define GL_MATRIX27_ARB                   0x88DB
+#define GL_MATRIX28_ARB                   0x88DC
+#define GL_MATRIX29_ARB                   0x88DD
+#define GL_MATRIX30_ARB                   0x88DE
+#define GL_MATRIX31_ARB                   0x88DF
+#endif
+
+#ifndef GL_ARB_fragment_program
+#define GL_FRAGMENT_PROGRAM_ARB           0x8804
+#define GL_PROGRAM_ALU_INSTRUCTIONS_ARB   0x8805
+#define GL_PROGRAM_TEX_INSTRUCTIONS_ARB   0x8806
+#define GL_PROGRAM_TEX_INDIRECTIONS_ARB   0x8807
+#define GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x8808
+#define GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x8809
+#define GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x880A
+#define GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB 0x880B
+#define GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB 0x880C
+#define GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB 0x880D
+#define GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x880E
+#define GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x880F
+#define GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x8810
+#define GL_MAX_TEXTURE_COORDS_ARB         0x8871
+#define GL_MAX_TEXTURE_IMAGE_UNITS_ARB    0x8872
+#endif
+
+#ifndef GL_ARB_vertex_buffer_object
+#define GL_BUFFER_SIZE_ARB                0x8764
+#define GL_BUFFER_USAGE_ARB               0x8765
+#define GL_ARRAY_BUFFER_ARB               0x8892
+#define GL_ELEMENT_ARRAY_BUFFER_ARB       0x8893
+#define GL_ARRAY_BUFFER_BINDING_ARB       0x8894
+#define GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB 0x8895
+#define GL_VERTEX_ARRAY_BUFFER_BINDING_ARB 0x8896
+#define GL_NORMAL_ARRAY_BUFFER_BINDING_ARB 0x8897
+#define GL_COLOR_ARRAY_BUFFER_BINDING_ARB 0x8898
+#define GL_INDEX_ARRAY_BUFFER_BINDING_ARB 0x8899
+#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB 0x889A
+#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB 0x889B
+#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB 0x889C
+#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB 0x889D
+#define GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB 0x889E
+#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB 0x889F
+#define GL_READ_ONLY_ARB                  0x88B8
+#define GL_WRITE_ONLY_ARB                 0x88B9
+#define GL_READ_WRITE_ARB                 0x88BA
+#define GL_BUFFER_ACCESS_ARB              0x88BB
+#define GL_BUFFER_MAPPED_ARB              0x88BC
+#define GL_BUFFER_MAP_POINTER_ARB         0x88BD
+#define GL_STREAM_DRAW_ARB                0x88E0
+#define GL_STREAM_READ_ARB                0x88E1
+#define GL_STREAM_COPY_ARB                0x88E2
+#define GL_STATIC_DRAW_ARB                0x88E4
+#define GL_STATIC_READ_ARB                0x88E5
+#define GL_STATIC_COPY_ARB                0x88E6
+#define GL_DYNAMIC_DRAW_ARB               0x88E8
+#define GL_DYNAMIC_READ_ARB               0x88E9
+#define GL_DYNAMIC_COPY_ARB               0x88EA
+#endif
+
+#ifndef GL_ARB_occlusion_query
+#define GL_QUERY_COUNTER_BITS_ARB         0x8864
+#define GL_CURRENT_QUERY_ARB              0x8865
+#define GL_QUERY_RESULT_ARB               0x8866
+#define GL_QUERY_RESULT_AVAILABLE_ARB     0x8867
+#define GL_SAMPLES_PASSED_ARB             0x8914
+#endif
+
+#ifndef GL_ARB_shader_objects
+#define GL_PROGRAM_OBJECT_ARB             0x8B40
+#define GL_SHADER_OBJECT_ARB              0x8B48
+#define GL_OBJECT_TYPE_ARB                0x8B4E
+#define GL_OBJECT_SUBTYPE_ARB             0x8B4F
+#define GL_FLOAT_VEC2_ARB                 0x8B50
+#define GL_FLOAT_VEC3_ARB                 0x8B51
+#define GL_FLOAT_VEC4_ARB                 0x8B52
+#define GL_INT_VEC2_ARB                   0x8B53
+#define GL_INT_VEC3_ARB                   0x8B54
+#define GL_INT_VEC4_ARB                   0x8B55
+#define GL_BOOL_ARB                       0x8B56
+#define GL_BOOL_VEC2_ARB                  0x8B57
+#define GL_BOOL_VEC3_ARB                  0x8B58
+#define GL_BOOL_VEC4_ARB                  0x8B59
+#define GL_FLOAT_MAT2_ARB                 0x8B5A
+#define GL_FLOAT_MAT3_ARB                 0x8B5B
+#define GL_FLOAT_MAT4_ARB                 0x8B5C
+#define GL_SAMPLER_1D_ARB                 0x8B5D
+#define GL_SAMPLER_2D_ARB                 0x8B5E
+#define GL_SAMPLER_3D_ARB                 0x8B5F
+#define GL_SAMPLER_CUBE_ARB               0x8B60
+#define GL_SAMPLER_1D_SHADOW_ARB          0x8B61
+#define GL_SAMPLER_2D_SHADOW_ARB          0x8B62
+#define GL_SAMPLER_2D_RECT_ARB            0x8B63
+#define GL_SAMPLER_2D_RECT_SHADOW_ARB     0x8B64
+#define GL_OBJECT_DELETE_STATUS_ARB       0x8B80
+#define GL_OBJECT_COMPILE_STATUS_ARB      0x8B81
+#define GL_OBJECT_LINK_STATUS_ARB         0x8B82
+#define GL_OBJECT_VALIDATE_STATUS_ARB     0x8B83
+#define GL_OBJECT_INFO_LOG_LENGTH_ARB     0x8B84
+#define GL_OBJECT_ATTACHED_OBJECTS_ARB    0x8B85
+#define GL_OBJECT_ACTIVE_UNIFORMS_ARB     0x8B86
+#define GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB 0x8B87
+#define GL_OBJECT_SHADER_SOURCE_LENGTH_ARB 0x8B88
+#endif
+
+#ifndef GL_ARB_vertex_shader
+#define GL_VERTEX_SHADER_ARB              0x8B31
+#define GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB 0x8B4A
+#define GL_MAX_VARYING_FLOATS_ARB         0x8B4B
+#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB 0x8B4C
+#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB 0x8B4D
+#define GL_OBJECT_ACTIVE_ATTRIBUTES_ARB   0x8B89
+#define GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB 0x8B8A
+#endif
+
+#ifndef GL_ARB_fragment_shader
+#define GL_FRAGMENT_SHADER_ARB            0x8B30
+#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB 0x8B49
+#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB 0x8B8B
+#endif
+
+#ifndef GL_ARB_shading_language_100
+#define GL_SHADING_LANGUAGE_VERSION_ARB   0x8B8C
+#endif
+
+#ifndef GL_ARB_texture_non_power_of_two
+#endif
+
+#ifndef GL_ARB_point_sprite
+#define GL_POINT_SPRITE_ARB               0x8861
+#define GL_COORD_REPLACE_ARB              0x8862
+#endif
+
+#ifndef GL_ARB_fragment_program_shadow
+#endif
+
+#ifndef GL_ARB_draw_buffers
+#define GL_MAX_DRAW_BUFFERS_ARB           0x8824
+#define GL_DRAW_BUFFER0_ARB               0x8825
+#define GL_DRAW_BUFFER1_ARB               0x8826
+#define GL_DRAW_BUFFER2_ARB               0x8827
+#define GL_DRAW_BUFFER3_ARB               0x8828
+#define GL_DRAW_BUFFER4_ARB               0x8829
+#define GL_DRAW_BUFFER5_ARB               0x882A
+#define GL_DRAW_BUFFER6_ARB               0x882B
+#define GL_DRAW_BUFFER7_ARB               0x882C
+#define GL_DRAW_BUFFER8_ARB               0x882D
+#define GL_DRAW_BUFFER9_ARB               0x882E
+#define GL_DRAW_BUFFER10_ARB              0x882F
+#define GL_DRAW_BUFFER11_ARB              0x8830
+#define GL_DRAW_BUFFER12_ARB              0x8831
+#define GL_DRAW_BUFFER13_ARB              0x8832
+#define GL_DRAW_BUFFER14_ARB              0x8833
+#define GL_DRAW_BUFFER15_ARB              0x8834
+#endif
+
+#ifndef GL_ARB_texture_rectangle
+#define GL_TEXTURE_RECTANGLE_ARB          0x84F5
+#define GL_TEXTURE_BINDING_RECTANGLE_ARB  0x84F6
+#define GL_PROXY_TEXTURE_RECTANGLE_ARB    0x84F7
+#define GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB 0x84F8
+#endif
+
+#ifndef GL_ARB_color_buffer_float
+#define GL_RGBA_FLOAT_MODE_ARB            0x8820
+#define GL_CLAMP_VERTEX_COLOR_ARB         0x891A
+#define GL_CLAMP_FRAGMENT_COLOR_ARB       0x891B
+#define GL_CLAMP_READ_COLOR_ARB           0x891C
+#define GL_FIXED_ONLY_ARB                 0x891D
+#endif
+
+#ifndef GL_ARB_half_float_pixel
+#define GL_HALF_FLOAT_ARB                 0x140B
+#endif
+
+#ifndef GL_ARB_texture_float
+#define GL_TEXTURE_RED_TYPE_ARB           0x8C10
+#define GL_TEXTURE_GREEN_TYPE_ARB         0x8C11
+#define GL_TEXTURE_BLUE_TYPE_ARB          0x8C12
+#define GL_TEXTURE_ALPHA_TYPE_ARB         0x8C13
+#define GL_TEXTURE_LUMINANCE_TYPE_ARB     0x8C14
+#define GL_TEXTURE_INTENSITY_TYPE_ARB     0x8C15
+#define GL_TEXTURE_DEPTH_TYPE_ARB         0x8C16
+#define GL_UNSIGNED_NORMALIZED_ARB        0x8C17
+#define GL_RGBA32F_ARB                    0x8814
+#define GL_RGB32F_ARB                     0x8815
+#define GL_ALPHA32F_ARB                   0x8816
+#define GL_INTENSITY32F_ARB               0x8817
+#define GL_LUMINANCE32F_ARB               0x8818
+#define GL_LUMINANCE_ALPHA32F_ARB         0x8819
+#define GL_RGBA16F_ARB                    0x881A
+#define GL_RGB16F_ARB                     0x881B
+#define GL_ALPHA16F_ARB                   0x881C
+#define GL_INTENSITY16F_ARB               0x881D
+#define GL_LUMINANCE16F_ARB               0x881E
+#define GL_LUMINANCE_ALPHA16F_ARB         0x881F
+#endif
+
+#ifndef GL_ARB_pixel_buffer_object
+#define GL_PIXEL_PACK_BUFFER_ARB          0x88EB
+#define GL_PIXEL_UNPACK_BUFFER_ARB        0x88EC
+#define GL_PIXEL_PACK_BUFFER_BINDING_ARB  0x88ED
+#define GL_PIXEL_UNPACK_BUFFER_BINDING_ARB 0x88EF
+#endif
+
+#ifndef GL_EXT_abgr
+#define GL_ABGR_EXT                       0x8000
+#endif
+
+#ifndef GL_EXT_blend_color
+#define GL_CONSTANT_COLOR_EXT             0x8001
+#define GL_ONE_MINUS_CONSTANT_COLOR_EXT   0x8002
+#define GL_CONSTANT_ALPHA_EXT             0x8003
+#define GL_ONE_MINUS_CONSTANT_ALPHA_EXT   0x8004
+#define GL_BLEND_COLOR_EXT                0x8005
+#endif
+
+#ifndef GL_EXT_polygon_offset
+#define GL_POLYGON_OFFSET_EXT             0x8037
+#define GL_POLYGON_OFFSET_FACTOR_EXT      0x8038
+#define GL_POLYGON_OFFSET_BIAS_EXT        0x8039
+#endif
+
+#ifndef GL_EXT_texture
+#define GL_ALPHA4_EXT                     0x803B
+#define GL_ALPHA8_EXT                     0x803C
+#define GL_ALPHA12_EXT                    0x803D
+#define GL_ALPHA16_EXT                    0x803E
+#define GL_LUMINANCE4_EXT                 0x803F
+#define GL_LUMINANCE8_EXT                 0x8040
+#define GL_LUMINANCE12_EXT                0x8041
+#define GL_LUMINANCE16_EXT                0x8042
+#define GL_LUMINANCE4_ALPHA4_EXT          0x8043
+#define GL_LUMINANCE6_ALPHA2_EXT          0x8044
+#define GL_LUMINANCE8_ALPHA8_EXT          0x8045
+#define GL_LUMINANCE12_ALPHA4_EXT         0x8046
+#define GL_LUMINANCE12_ALPHA12_EXT        0x8047
+#define GL_LUMINANCE16_ALPHA16_EXT        0x8048
+#define GL_INTENSITY_EXT                  0x8049
+#define GL_INTENSITY4_EXT                 0x804A
+#define GL_INTENSITY8_EXT                 0x804B
+#define GL_INTENSITY12_EXT                0x804C
+#define GL_INTENSITY16_EXT                0x804D
+#define GL_RGB2_EXT                       0x804E
+#define GL_RGB4_EXT                       0x804F
+#define GL_RGB5_EXT                       0x8050
+#define GL_RGB8_EXT                       0x8051
+#define GL_RGB10_EXT                      0x8052
+#define GL_RGB12_EXT                      0x8053
+#define GL_RGB16_EXT                      0x8054
+#define GL_RGBA2_EXT                      0x8055
+#define GL_RGBA4_EXT                      0x8056
+#define GL_RGB5_A1_EXT                    0x8057
+#define GL_RGBA8_EXT                      0x8058
+#define GL_RGB10_A2_EXT                   0x8059
+#define GL_RGBA12_EXT                     0x805A
+#define GL_RGBA16_EXT                     0x805B
+#define GL_TEXTURE_RED_SIZE_EXT           0x805C
+#define GL_TEXTURE_GREEN_SIZE_EXT         0x805D
+#define GL_TEXTURE_BLUE_SIZE_EXT          0x805E
+#define GL_TEXTURE_ALPHA_SIZE_EXT         0x805F
+#define GL_TEXTURE_LUMINANCE_SIZE_EXT     0x8060
+#define GL_TEXTURE_INTENSITY_SIZE_EXT     0x8061
+#define GL_REPLACE_EXT                    0x8062
+#define GL_PROXY_TEXTURE_1D_EXT           0x8063
+#define GL_PROXY_TEXTURE_2D_EXT           0x8064
+#define GL_TEXTURE_TOO_LARGE_EXT          0x8065
+#endif
+
+#ifndef GL_EXT_texture3D
+#define GL_PACK_SKIP_IMAGES_EXT           0x806B
+#define GL_PACK_IMAGE_HEIGHT_EXT          0x806C
+#define GL_UNPACK_SKIP_IMAGES_EXT         0x806D
+#define GL_UNPACK_IMAGE_HEIGHT_EXT        0x806E
+#define GL_TEXTURE_3D_EXT                 0x806F
+#define GL_PROXY_TEXTURE_3D_EXT           0x8070
+#define GL_TEXTURE_DEPTH_EXT              0x8071
+#define GL_TEXTURE_WRAP_R_EXT             0x8072
+#define GL_MAX_3D_TEXTURE_SIZE_EXT        0x8073
+#endif
+
+#ifndef GL_SGIS_texture_filter4
+#define GL_FILTER4_SGIS                   0x8146
+#define GL_TEXTURE_FILTER4_SIZE_SGIS      0x8147
+#endif
+
+#ifndef GL_EXT_subtexture
+#endif
+
+#ifndef GL_EXT_copy_texture
+#endif
+
+#ifndef GL_EXT_histogram
+#define GL_HISTOGRAM_EXT                  0x8024
+#define GL_PROXY_HISTOGRAM_EXT            0x8025
+#define GL_HISTOGRAM_WIDTH_EXT            0x8026
+#define GL_HISTOGRAM_FORMAT_EXT           0x8027
+#define GL_HISTOGRAM_RED_SIZE_EXT         0x8028
+#define GL_HISTOGRAM_GREEN_SIZE_EXT       0x8029
+#define GL_HISTOGRAM_BLUE_SIZE_EXT        0x802A
+#define GL_HISTOGRAM_ALPHA_SIZE_EXT       0x802B
+#define GL_HISTOGRAM_LUMINANCE_SIZE_EXT   0x802C
+#define GL_HISTOGRAM_SINK_EXT             0x802D
+#define GL_MINMAX_EXT                     0x802E
+#define GL_MINMAX_FORMAT_EXT              0x802F
+#define GL_MINMAX_SINK_EXT                0x8030
+#define GL_TABLE_TOO_LARGE_EXT            0x8031
+#endif
+
+#ifndef GL_EXT_convolution
+#define GL_CONVOLUTION_1D_EXT             0x8010
+#define GL_CONVOLUTION_2D_EXT             0x8011
+#define GL_SEPARABLE_2D_EXT               0x8012
+#define GL_CONVOLUTION_BORDER_MODE_EXT    0x8013
+#define GL_CONVOLUTION_FILTER_SCALE_EXT   0x8014
+#define GL_CONVOLUTION_FILTER_BIAS_EXT    0x8015
+#define GL_REDUCE_EXT                     0x8016
+#define GL_CONVOLUTION_FORMAT_EXT         0x8017
+#define GL_CONVOLUTION_WIDTH_EXT          0x8018
+#define GL_CONVOLUTION_HEIGHT_EXT         0x8019
+#define GL_MAX_CONVOLUTION_WIDTH_EXT      0x801A
+#define GL_MAX_CONVOLUTION_HEIGHT_EXT     0x801B
+#define GL_POST_CONVOLUTION_RED_SCALE_EXT 0x801C
+#define GL_POST_CONVOLUTION_GREEN_SCALE_EXT 0x801D
+#define GL_POST_CONVOLUTION_BLUE_SCALE_EXT 0x801E
+#define GL_POST_CONVOLUTION_ALPHA_SCALE_EXT 0x801F
+#define GL_POST_CONVOLUTION_RED_BIAS_EXT  0x8020
+#define GL_POST_CONVOLUTION_GREEN_BIAS_EXT 0x8021
+#define GL_POST_CONVOLUTION_BLUE_BIAS_EXT 0x8022
+#define GL_POST_CONVOLUTION_ALPHA_BIAS_EXT 0x8023
+#endif
+
+#ifndef GL_SGI_color_matrix
+#define GL_COLOR_MATRIX_SGI               0x80B1
+#define GL_COLOR_MATRIX_STACK_DEPTH_SGI   0x80B2
+#define GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI 0x80B3
+#define GL_POST_COLOR_MATRIX_RED_SCALE_SGI 0x80B4
+#define GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI 0x80B5
+#define GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI 0x80B6
+#define GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI 0x80B7
+#define GL_POST_COLOR_MATRIX_RED_BIAS_SGI 0x80B8
+#define GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI 0x80B9
+#define GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI 0x80BA
+#define GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI 0x80BB
+#endif
+
+#ifndef GL_SGI_color_table
+#define GL_COLOR_TABLE_SGI                0x80D0
+#define GL_POST_CONVOLUTION_COLOR_TABLE_SGI 0x80D1
+#define GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0x80D2
+#define GL_PROXY_COLOR_TABLE_SGI          0x80D3
+#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI 0x80D4
+#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0x80D5
+#define GL_COLOR_TABLE_SCALE_SGI          0x80D6
+#define GL_COLOR_TABLE_BIAS_SGI           0x80D7
+#define GL_COLOR_TABLE_FORMAT_SGI         0x80D8
+#define GL_COLOR_TABLE_WIDTH_SGI          0x80D9
+#define GL_COLOR_TABLE_RED_SIZE_SGI       0x80DA
+#define GL_COLOR_TABLE_GREEN_SIZE_SGI     0x80DB
+#define GL_COLOR_TABLE_BLUE_SIZE_SGI      0x80DC
+#define GL_COLOR_TABLE_ALPHA_SIZE_SGI     0x80DD
+#define GL_COLOR_TABLE_LUMINANCE_SIZE_SGI 0x80DE
+#define GL_COLOR_TABLE_INTENSITY_SIZE_SGI 0x80DF
+#endif
+
+#ifndef GL_SGIS_pixel_texture
+#define GL_PIXEL_TEXTURE_SGIS             0x8353
+#define GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS 0x8354
+#define GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS 0x8355
+#define GL_PIXEL_GROUP_COLOR_SGIS         0x8356
+#endif
+
+#ifndef GL_SGIX_pixel_texture
+#define GL_PIXEL_TEX_GEN_SGIX             0x8139
+#define GL_PIXEL_TEX_GEN_MODE_SGIX        0x832B
+#endif
+
+#ifndef GL_SGIS_texture4D
+#define GL_PACK_SKIP_VOLUMES_SGIS         0x8130
+#define GL_PACK_IMAGE_DEPTH_SGIS          0x8131
+#define GL_UNPACK_SKIP_VOLUMES_SGIS       0x8132
+#define GL_UNPACK_IMAGE_DEPTH_SGIS        0x8133
+#define GL_TEXTURE_4D_SGIS                0x8134
+#define GL_PROXY_TEXTURE_4D_SGIS          0x8135
+#define GL_TEXTURE_4DSIZE_SGIS            0x8136
+#define GL_TEXTURE_WRAP_Q_SGIS            0x8137
+#define GL_MAX_4D_TEXTURE_SIZE_SGIS       0x8138
+#define GL_TEXTURE_4D_BINDING_SGIS        0x814F
+#endif
+
+#ifndef GL_SGI_texture_color_table
+#define GL_TEXTURE_COLOR_TABLE_SGI        0x80BC
+#define GL_PROXY_TEXTURE_COLOR_TABLE_SGI  0x80BD
+#endif
+
+#ifndef GL_EXT_cmyka
+#define GL_CMYK_EXT                       0x800C
+#define GL_CMYKA_EXT                      0x800D
+#define GL_PACK_CMYK_HINT_EXT             0x800E
+#define GL_UNPACK_CMYK_HINT_EXT           0x800F
+#endif
+
+#ifndef GL_EXT_texture_object
+#define GL_TEXTURE_PRIORITY_EXT           0x8066
+#define GL_TEXTURE_RESIDENT_EXT           0x8067
+#define GL_TEXTURE_1D_BINDING_EXT         0x8068
+#define GL_TEXTURE_2D_BINDING_EXT         0x8069
+#define GL_TEXTURE_3D_BINDING_EXT         0x806A
+#endif
+
+#ifndef GL_SGIS_detail_texture
+#define GL_DETAIL_TEXTURE_2D_SGIS         0x8095
+#define GL_DETAIL_TEXTURE_2D_BINDING_SGIS 0x8096
+#define GL_LINEAR_DETAIL_SGIS             0x8097
+#define GL_LINEAR_DETAIL_ALPHA_SGIS       0x8098
+#define GL_LINEAR_DETAIL_COLOR_SGIS       0x8099
+#define GL_DETAIL_TEXTURE_LEVEL_SGIS      0x809A
+#define GL_DETAIL_TEXTURE_MODE_SGIS       0x809B
+#define GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS 0x809C
+#endif
+
+#ifndef GL_SGIS_sharpen_texture
+#define GL_LINEAR_SHARPEN_SGIS            0x80AD
+#define GL_LINEAR_SHARPEN_ALPHA_SGIS      0x80AE
+#define GL_LINEAR_SHARPEN_COLOR_SGIS      0x80AF
+#define GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS 0x80B0
+#endif
+
+#ifndef GL_EXT_packed_pixels
+#define GL_UNSIGNED_BYTE_3_3_2_EXT        0x8032
+#define GL_UNSIGNED_SHORT_4_4_4_4_EXT     0x8033
+#define GL_UNSIGNED_SHORT_5_5_5_1_EXT     0x8034
+#define GL_UNSIGNED_INT_8_8_8_8_EXT       0x8035
+#define GL_UNSIGNED_INT_10_10_10_2_EXT    0x8036
+#endif
+
+#ifndef GL_SGIS_texture_lod
+#define GL_TEXTURE_MIN_LOD_SGIS           0x813A
+#define GL_TEXTURE_MAX_LOD_SGIS           0x813B
+#define GL_TEXTURE_BASE_LEVEL_SGIS        0x813C
+#define GL_TEXTURE_MAX_LEVEL_SGIS         0x813D
+#endif
+
+#ifndef GL_SGIS_multisample
+#define GL_MULTISAMPLE_SGIS               0x809D
+#define GL_SAMPLE_ALPHA_TO_MASK_SGIS      0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE_SGIS       0x809F
+#define GL_SAMPLE_MASK_SGIS               0x80A0
+#define GL_1PASS_SGIS                     0x80A1
+#define GL_2PASS_0_SGIS                   0x80A2
+#define GL_2PASS_1_SGIS                   0x80A3
+#define GL_4PASS_0_SGIS                   0x80A4
+#define GL_4PASS_1_SGIS                   0x80A5
+#define GL_4PASS_2_SGIS                   0x80A6
+#define GL_4PASS_3_SGIS                   0x80A7
+#define GL_SAMPLE_BUFFERS_SGIS            0x80A8
+#define GL_SAMPLES_SGIS                   0x80A9
+#define GL_SAMPLE_MASK_VALUE_SGIS         0x80AA
+#define GL_SAMPLE_MASK_INVERT_SGIS        0x80AB
+#define GL_SAMPLE_PATTERN_SGIS            0x80AC
+#endif
+
+#ifndef GL_EXT_rescale_normal
+#define GL_RESCALE_NORMAL_EXT             0x803A
+#endif
+
+#ifndef GL_EXT_vertex_array
+#define GL_VERTEX_ARRAY_EXT               0x8074
+#define GL_NORMAL_ARRAY_EXT               0x8075
+#define GL_COLOR_ARRAY_EXT                0x8076
+#define GL_INDEX_ARRAY_EXT                0x8077
+#define GL_TEXTURE_COORD_ARRAY_EXT        0x8078
+#define GL_EDGE_FLAG_ARRAY_EXT            0x8079
+#define GL_VERTEX_ARRAY_SIZE_EXT          0x807A
+#define GL_VERTEX_ARRAY_TYPE_EXT          0x807B
+#define GL_VERTEX_ARRAY_STRIDE_EXT        0x807C
+#define GL_VERTEX_ARRAY_COUNT_EXT         0x807D
+#define GL_NORMAL_ARRAY_TYPE_EXT          0x807E
+#define GL_NORMAL_ARRAY_STRIDE_EXT        0x807F
+#define GL_NORMAL_ARRAY_COUNT_EXT         0x8080
+#define GL_COLOR_ARRAY_SIZE_EXT           0x8081
+#define GL_COLOR_ARRAY_TYPE_EXT           0x8082
+#define GL_COLOR_ARRAY_STRIDE_EXT         0x8083
+#define GL_COLOR_ARRAY_COUNT_EXT          0x8084
+#define GL_INDEX_ARRAY_TYPE_EXT           0x8085
+#define GL_INDEX_ARRAY_STRIDE_EXT         0x8086
+#define GL_INDEX_ARRAY_COUNT_EXT          0x8087
+#define GL_TEXTURE_COORD_ARRAY_SIZE_EXT   0x8088
+#define GL_TEXTURE_COORD_ARRAY_TYPE_EXT   0x8089
+#define GL_TEXTURE_COORD_ARRAY_STRIDE_EXT 0x808A
+#define GL_TEXTURE_COORD_ARRAY_COUNT_EXT  0x808B
+#define GL_EDGE_FLAG_ARRAY_STRIDE_EXT     0x808C
+#define GL_EDGE_FLAG_ARRAY_COUNT_EXT      0x808D
+#define GL_VERTEX_ARRAY_POINTER_EXT       0x808E
+#define GL_NORMAL_ARRAY_POINTER_EXT       0x808F
+#define GL_COLOR_ARRAY_POINTER_EXT        0x8090
+#define GL_INDEX_ARRAY_POINTER_EXT        0x8091
+#define GL_TEXTURE_COORD_ARRAY_POINTER_EXT 0x8092
+#define GL_EDGE_FLAG_ARRAY_POINTER_EXT    0x8093
+#endif
+
+#ifndef GL_EXT_misc_attribute
+#endif
+
+#ifndef GL_SGIS_generate_mipmap
+#define GL_GENERATE_MIPMAP_SGIS           0x8191
+#define GL_GENERATE_MIPMAP_HINT_SGIS      0x8192
+#endif
+
+#ifndef GL_SGIX_clipmap
+#define GL_LINEAR_CLIPMAP_LINEAR_SGIX     0x8170
+#define GL_TEXTURE_CLIPMAP_CENTER_SGIX    0x8171
+#define GL_TEXTURE_CLIPMAP_FRAME_SGIX     0x8172
+#define GL_TEXTURE_CLIPMAP_OFFSET_SGIX    0x8173
+#define GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX 0x8174
+#define GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX 0x8175
+#define GL_TEXTURE_CLIPMAP_DEPTH_SGIX     0x8176
+#define GL_MAX_CLIPMAP_DEPTH_SGIX         0x8177
+#define GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX 0x8178
+#define GL_NEAREST_CLIPMAP_NEAREST_SGIX   0x844D
+#define GL_NEAREST_CLIPMAP_LINEAR_SGIX    0x844E
+#define GL_LINEAR_CLIPMAP_NEAREST_SGIX    0x844F
+#endif
+
+#ifndef GL_SGIX_shadow
+#define GL_TEXTURE_COMPARE_SGIX           0x819A
+#define GL_TEXTURE_COMPARE_OPERATOR_SGIX  0x819B
+#define GL_TEXTURE_LEQUAL_R_SGIX          0x819C
+#define GL_TEXTURE_GEQUAL_R_SGIX          0x819D
+#endif
+
+#ifndef GL_SGIS_texture_edge_clamp
+#define GL_CLAMP_TO_EDGE_SGIS             0x812F
+#endif
+
+#ifndef GL_SGIS_texture_border_clamp
+#define GL_CLAMP_TO_BORDER_SGIS           0x812D
+#endif
+
+#ifndef GL_EXT_blend_minmax
+#define GL_FUNC_ADD_EXT                   0x8006
+#define GL_MIN_EXT                        0x8007
+#define GL_MAX_EXT                        0x8008
+#define GL_BLEND_EQUATION_EXT             0x8009
+#endif
+
+#ifndef GL_EXT_blend_subtract
+#define GL_FUNC_SUBTRACT_EXT              0x800A
+#define GL_FUNC_REVERSE_SUBTRACT_EXT      0x800B
+#endif
+
+#ifndef GL_EXT_blend_logic_op
+#endif
+
+#ifndef GL_SGIX_interlace
+#define GL_INTERLACE_SGIX                 0x8094
+#endif
+
+#ifndef GL_SGIX_pixel_tiles
+#define GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX 0x813E
+#define GL_PIXEL_TILE_CACHE_INCREMENT_SGIX 0x813F
+#define GL_PIXEL_TILE_WIDTH_SGIX          0x8140
+#define GL_PIXEL_TILE_HEIGHT_SGIX         0x8141
+#define GL_PIXEL_TILE_GRID_WIDTH_SGIX     0x8142
+#define GL_PIXEL_TILE_GRID_HEIGHT_SGIX    0x8143
+#define GL_PIXEL_TILE_GRID_DEPTH_SGIX     0x8144
+#define GL_PIXEL_TILE_CACHE_SIZE_SGIX     0x8145
+#endif
+
+#ifndef GL_SGIS_texture_select
+#define GL_DUAL_ALPHA4_SGIS               0x8110
+#define GL_DUAL_ALPHA8_SGIS               0x8111
+#define GL_DUAL_ALPHA12_SGIS              0x8112
+#define GL_DUAL_ALPHA16_SGIS              0x8113
+#define GL_DUAL_LUMINANCE4_SGIS           0x8114
+#define GL_DUAL_LUMINANCE8_SGIS           0x8115
+#define GL_DUAL_LUMINANCE12_SGIS          0x8116
+#define GL_DUAL_LUMINANCE16_SGIS          0x8117
+#define GL_DUAL_INTENSITY4_SGIS           0x8118
+#define GL_DUAL_INTENSITY8_SGIS           0x8119
+#define GL_DUAL_INTENSITY12_SGIS          0x811A
+#define GL_DUAL_INTENSITY16_SGIS          0x811B
+#define GL_DUAL_LUMINANCE_ALPHA4_SGIS     0x811C
+#define GL_DUAL_LUMINANCE_ALPHA8_SGIS     0x811D
+#define GL_QUAD_ALPHA4_SGIS               0x811E
+#define GL_QUAD_ALPHA8_SGIS               0x811F
+#define GL_QUAD_LUMINANCE4_SGIS           0x8120
+#define GL_QUAD_LUMINANCE8_SGIS           0x8121
+#define GL_QUAD_INTENSITY4_SGIS           0x8122
+#define GL_QUAD_INTENSITY8_SGIS           0x8123
+#define GL_DUAL_TEXTURE_SELECT_SGIS       0x8124
+#define GL_QUAD_TEXTURE_SELECT_SGIS       0x8125
+#endif
+
+#ifndef GL_SGIX_sprite
+#define GL_SPRITE_SGIX                    0x8148
+#define GL_SPRITE_MODE_SGIX               0x8149
+#define GL_SPRITE_AXIS_SGIX               0x814A
+#define GL_SPRITE_TRANSLATION_SGIX        0x814B
+#define GL_SPRITE_AXIAL_SGIX              0x814C
+#define GL_SPRITE_OBJECT_ALIGNED_SGIX     0x814D
+#define GL_SPRITE_EYE_ALIGNED_SGIX        0x814E
+#endif
+
+#ifndef GL_SGIX_texture_multi_buffer
+#define GL_TEXTURE_MULTI_BUFFER_HINT_SGIX 0x812E
+#endif
+
+#ifndef GL_EXT_point_parameters
+#define GL_POINT_SIZE_MIN_EXT             0x8126
+#define GL_POINT_SIZE_MAX_EXT             0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE_EXT  0x8128
+#define GL_DISTANCE_ATTENUATION_EXT       0x8129
+#endif
+
+#ifndef GL_SGIS_point_parameters
+#define GL_POINT_SIZE_MIN_SGIS            0x8126
+#define GL_POINT_SIZE_MAX_SGIS            0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE_SGIS 0x8128
+#define GL_DISTANCE_ATTENUATION_SGIS      0x8129
+#endif
+
+#ifndef GL_SGIX_instruments
+#define GL_INSTRUMENT_BUFFER_POINTER_SGIX 0x8180
+#define GL_INSTRUMENT_MEASUREMENTS_SGIX   0x8181
+#endif
+
+#ifndef GL_SGIX_texture_scale_bias
+#define GL_POST_TEXTURE_FILTER_BIAS_SGIX  0x8179
+#define GL_POST_TEXTURE_FILTER_SCALE_SGIX 0x817A
+#define GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX 0x817B
+#define GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX 0x817C
+#endif
+
+#ifndef GL_SGIX_framezoom
+#define GL_FRAMEZOOM_SGIX                 0x818B
+#define GL_FRAMEZOOM_FACTOR_SGIX          0x818C
+#define GL_MAX_FRAMEZOOM_FACTOR_SGIX      0x818D
+#endif
+
+#ifndef GL_SGIX_tag_sample_buffer
+#endif
+
+#ifndef GL_FfdMaskSGIX
+#define GL_TEXTURE_DEFORMATION_BIT_SGIX   0x00000001
+#define GL_GEOMETRY_DEFORMATION_BIT_SGIX  0x00000002
+#endif
+
+#ifndef GL_SGIX_polynomial_ffd
+#define GL_GEOMETRY_DEFORMATION_SGIX      0x8194
+#define GL_TEXTURE_DEFORMATION_SGIX       0x8195
+#define GL_DEFORMATIONS_MASK_SGIX         0x8196
+#define GL_MAX_DEFORMATION_ORDER_SGIX     0x8197
+#endif
+
+#ifndef GL_SGIX_reference_plane
+#define GL_REFERENCE_PLANE_SGIX           0x817D
+#define GL_REFERENCE_PLANE_EQUATION_SGIX  0x817E
+#endif
+
+#ifndef GL_SGIX_flush_raster
+#endif
+
+#ifndef GL_SGIX_depth_texture
+#define GL_DEPTH_COMPONENT16_SGIX         0x81A5
+#define GL_DEPTH_COMPONENT24_SGIX         0x81A6
+#define GL_DEPTH_COMPONENT32_SGIX         0x81A7
+#endif
+
+#ifndef GL_SGIS_fog_function
+#define GL_FOG_FUNC_SGIS                  0x812A
+#define GL_FOG_FUNC_POINTS_SGIS           0x812B
+#define GL_MAX_FOG_FUNC_POINTS_SGIS       0x812C
+#endif
+
+#ifndef GL_SGIX_fog_offset
+#define GL_FOG_OFFSET_SGIX                0x8198
+#define GL_FOG_OFFSET_VALUE_SGIX          0x8199
+#endif
+
+#ifndef GL_HP_image_transform
+#define GL_IMAGE_SCALE_X_HP               0x8155
+#define GL_IMAGE_SCALE_Y_HP               0x8156
+#define GL_IMAGE_TRANSLATE_X_HP           0x8157
+#define GL_IMAGE_TRANSLATE_Y_HP           0x8158
+#define GL_IMAGE_ROTATE_ANGLE_HP          0x8159
+#define GL_IMAGE_ROTATE_ORIGIN_X_HP       0x815A
+#define GL_IMAGE_ROTATE_ORIGIN_Y_HP       0x815B
+#define GL_IMAGE_MAG_FILTER_HP            0x815C
+#define GL_IMAGE_MIN_FILTER_HP            0x815D
+#define GL_IMAGE_CUBIC_WEIGHT_HP          0x815E
+#define GL_CUBIC_HP                       0x815F
+#define GL_AVERAGE_HP                     0x8160
+#define GL_IMAGE_TRANSFORM_2D_HP          0x8161
+#define GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP 0x8162
+#define GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP 0x8163
+#endif
+
+#ifndef GL_HP_convolution_border_modes
+#define GL_IGNORE_BORDER_HP               0x8150
+#define GL_CONSTANT_BORDER_HP             0x8151
+#define GL_REPLICATE_BORDER_HP            0x8153
+#define GL_CONVOLUTION_BORDER_COLOR_HP    0x8154
+#endif
+
+#ifndef GL_INGR_palette_buffer
+#endif
+
+#ifndef GL_SGIX_texture_add_env
+#define GL_TEXTURE_ENV_BIAS_SGIX          0x80BE
+#endif
+
+#ifndef GL_EXT_color_subtable
+#endif
+
+#ifndef GL_PGI_vertex_hints
+#define GL_VERTEX_DATA_HINT_PGI           0x1A22A
+#define GL_VERTEX_CONSISTENT_HINT_PGI     0x1A22B
+#define GL_MATERIAL_SIDE_HINT_PGI         0x1A22C
+#define GL_MAX_VERTEX_HINT_PGI            0x1A22D
+#define GL_COLOR3_BIT_PGI                 0x00010000
+#define GL_COLOR4_BIT_PGI                 0x00020000
+#define GL_EDGEFLAG_BIT_PGI               0x00040000
+#define GL_INDEX_BIT_PGI                  0x00080000
+#define GL_MAT_AMBIENT_BIT_PGI            0x00100000
+#define GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI 0x00200000
+#define GL_MAT_DIFFUSE_BIT_PGI            0x00400000
+#define GL_MAT_EMISSION_BIT_PGI           0x00800000
+#define GL_MAT_COLOR_INDEXES_BIT_PGI      0x01000000
+#define GL_MAT_SHININESS_BIT_PGI          0x02000000
+#define GL_MAT_SPECULAR_BIT_PGI           0x04000000
+#define GL_NORMAL_BIT_PGI                 0x08000000
+#define GL_TEXCOORD1_BIT_PGI              0x10000000
+#define GL_TEXCOORD2_BIT_PGI              0x20000000
+#define GL_TEXCOORD3_BIT_PGI              0x40000000
+#define GL_TEXCOORD4_BIT_PGI              0x80000000
+#define GL_VERTEX23_BIT_PGI               0x00000004
+#define GL_VERTEX4_BIT_PGI                0x00000008
+#endif
+
+#ifndef GL_PGI_misc_hints
+#define GL_PREFER_DOUBLEBUFFER_HINT_PGI   0x1A1F8
+#define GL_CONSERVE_MEMORY_HINT_PGI       0x1A1FD
+#define GL_RECLAIM_MEMORY_HINT_PGI        0x1A1FE
+#define GL_NATIVE_GRAPHICS_HANDLE_PGI     0x1A202
+#define GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI 0x1A203
+#define GL_NATIVE_GRAPHICS_END_HINT_PGI   0x1A204
+#define GL_ALWAYS_FAST_HINT_PGI           0x1A20C
+#define GL_ALWAYS_SOFT_HINT_PGI           0x1A20D
+#define GL_ALLOW_DRAW_OBJ_HINT_PGI        0x1A20E
+#define GL_ALLOW_DRAW_WIN_HINT_PGI        0x1A20F
+#define GL_ALLOW_DRAW_FRG_HINT_PGI        0x1A210
+#define GL_ALLOW_DRAW_MEM_HINT_PGI        0x1A211
+#define GL_STRICT_DEPTHFUNC_HINT_PGI      0x1A216
+#define GL_STRICT_LIGHTING_HINT_PGI       0x1A217
+#define GL_STRICT_SCISSOR_HINT_PGI        0x1A218
+#define GL_FULL_STIPPLE_HINT_PGI          0x1A219
+#define GL_CLIP_NEAR_HINT_PGI             0x1A220
+#define GL_CLIP_FAR_HINT_PGI              0x1A221
+#define GL_WIDE_LINE_HINT_PGI             0x1A222
+#define GL_BACK_NORMALS_HINT_PGI          0x1A223
+#endif
+
+#ifndef GL_EXT_paletted_texture
+#define GL_COLOR_INDEX1_EXT               0x80E2
+#define GL_COLOR_INDEX2_EXT               0x80E3
+#define GL_COLOR_INDEX4_EXT               0x80E4
+#define GL_COLOR_INDEX8_EXT               0x80E5
+#define GL_COLOR_INDEX12_EXT              0x80E6
+#define GL_COLOR_INDEX16_EXT              0x80E7
+#define GL_TEXTURE_INDEX_SIZE_EXT         0x80ED
+#endif
+
+#ifndef GL_EXT_clip_volume_hint
+#define GL_CLIP_VOLUME_CLIPPING_HINT_EXT  0x80F0
+#endif
+
+#ifndef GL_SGIX_list_priority
+#define GL_LIST_PRIORITY_SGIX             0x8182
+#endif
+
+#ifndef GL_SGIX_ir_instrument1
+#define GL_IR_INSTRUMENT1_SGIX            0x817F
+#endif
+
+#ifndef GL_SGIX_calligraphic_fragment
+#define GL_CALLIGRAPHIC_FRAGMENT_SGIX     0x8183
+#endif
+
+#ifndef GL_SGIX_texture_lod_bias
+#define GL_TEXTURE_LOD_BIAS_S_SGIX        0x818E
+#define GL_TEXTURE_LOD_BIAS_T_SGIX        0x818F
+#define GL_TEXTURE_LOD_BIAS_R_SGIX        0x8190
+#endif
+
+#ifndef GL_SGIX_shadow_ambient
+#define GL_SHADOW_AMBIENT_SGIX            0x80BF
+#endif
+
+#ifndef GL_EXT_index_texture
+#endif
+
+#ifndef GL_EXT_index_material
+#define GL_INDEX_MATERIAL_EXT             0x81B8
+#define GL_INDEX_MATERIAL_PARAMETER_EXT   0x81B9
+#define GL_INDEX_MATERIAL_FACE_EXT        0x81BA
+#endif
+
+#ifndef GL_EXT_index_func
+#define GL_INDEX_TEST_EXT                 0x81B5
+#define GL_INDEX_TEST_FUNC_EXT            0x81B6
+#define GL_INDEX_TEST_REF_EXT             0x81B7
+#endif
+
+#ifndef GL_EXT_index_array_formats
+#define GL_IUI_V2F_EXT                    0x81AD
+#define GL_IUI_V3F_EXT                    0x81AE
+#define GL_IUI_N3F_V2F_EXT                0x81AF
+#define GL_IUI_N3F_V3F_EXT                0x81B0
+#define GL_T2F_IUI_V2F_EXT                0x81B1
+#define GL_T2F_IUI_V3F_EXT                0x81B2
+#define GL_T2F_IUI_N3F_V2F_EXT            0x81B3
+#define GL_T2F_IUI_N3F_V3F_EXT            0x81B4
+#endif
+
+#ifndef GL_EXT_compiled_vertex_array
+#define GL_ARRAY_ELEMENT_LOCK_FIRST_EXT   0x81A8
+#define GL_ARRAY_ELEMENT_LOCK_COUNT_EXT   0x81A9
+#endif
+
+#ifndef GL_EXT_cull_vertex
+#define GL_CULL_VERTEX_EXT                0x81AA
+#define GL_CULL_VERTEX_EYE_POSITION_EXT   0x81AB
+#define GL_CULL_VERTEX_OBJECT_POSITION_EXT 0x81AC
+#endif
+
+#ifndef GL_SGIX_ycrcb
+#define GL_YCRCB_422_SGIX                 0x81BB
+#define GL_YCRCB_444_SGIX                 0x81BC
+#endif
+
+#ifndef GL_SGIX_fragment_lighting
+#define GL_FRAGMENT_LIGHTING_SGIX         0x8400
+#define GL_FRAGMENT_COLOR_MATERIAL_SGIX   0x8401
+#define GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX 0x8402
+#define GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX 0x8403
+#define GL_MAX_FRAGMENT_LIGHTS_SGIX       0x8404
+#define GL_MAX_ACTIVE_LIGHTS_SGIX         0x8405
+#define GL_CURRENT_RASTER_NORMAL_SGIX     0x8406
+#define GL_LIGHT_ENV_MODE_SGIX            0x8407
+#define GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX 0x8408
+#define GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX 0x8409
+#define GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX 0x840A
+#define GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX 0x840B
+#define GL_FRAGMENT_LIGHT0_SGIX           0x840C
+#define GL_FRAGMENT_LIGHT1_SGIX           0x840D
+#define GL_FRAGMENT_LIGHT2_SGIX           0x840E
+#define GL_FRAGMENT_LIGHT3_SGIX           0x840F
+#define GL_FRAGMENT_LIGHT4_SGIX           0x8410
+#define GL_FRAGMENT_LIGHT5_SGIX           0x8411
+#define GL_FRAGMENT_LIGHT6_SGIX           0x8412
+#define GL_FRAGMENT_LIGHT7_SGIX           0x8413
+#endif
+
+#ifndef GL_IBM_rasterpos_clip
+#define GL_RASTER_POSITION_UNCLIPPED_IBM  0x19262
+#endif
+
+#ifndef GL_HP_texture_lighting
+#define GL_TEXTURE_LIGHTING_MODE_HP       0x8167
+#define GL_TEXTURE_POST_SPECULAR_HP       0x8168
+#define GL_TEXTURE_PRE_SPECULAR_HP        0x8169
+#endif
+
+#ifndef GL_EXT_draw_range_elements
+#define GL_MAX_ELEMENTS_VERTICES_EXT      0x80E8
+#define GL_MAX_ELEMENTS_INDICES_EXT       0x80E9
+#endif
+
+#ifndef GL_WIN_phong_shading
+#define GL_PHONG_WIN                      0x80EA
+#define GL_PHONG_HINT_WIN                 0x80EB
+#endif
+
+#ifndef GL_WIN_specular_fog
+#define GL_FOG_SPECULAR_TEXTURE_WIN       0x80EC
+#endif
+
+#ifndef GL_EXT_light_texture
+#define GL_FRAGMENT_MATERIAL_EXT          0x8349
+#define GL_FRAGMENT_NORMAL_EXT            0x834A
+#define GL_FRAGMENT_COLOR_EXT             0x834C
+#define GL_ATTENUATION_EXT                0x834D
+#define GL_SHADOW_ATTENUATION_EXT         0x834E
+#define GL_TEXTURE_APPLICATION_MODE_EXT   0x834F
+#define GL_TEXTURE_LIGHT_EXT              0x8350
+#define GL_TEXTURE_MATERIAL_FACE_EXT      0x8351
+#define GL_TEXTURE_MATERIAL_PARAMETER_EXT 0x8352
+/* reuse GL_FRAGMENT_DEPTH_EXT */
+#endif
+
+#ifndef GL_SGIX_blend_alpha_minmax
+#define GL_ALPHA_MIN_SGIX                 0x8320
+#define GL_ALPHA_MAX_SGIX                 0x8321
+#endif
+
+#ifndef GL_SGIX_impact_pixel_texture
+#define GL_PIXEL_TEX_GEN_Q_CEILING_SGIX   0x8184
+#define GL_PIXEL_TEX_GEN_Q_ROUND_SGIX     0x8185
+#define GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX     0x8186
+#define GL_PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX 0x8187
+#define GL_PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX 0x8188
+#define GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX    0x8189
+#define GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX    0x818A
+#endif
+
+#ifndef GL_EXT_bgra
+#define GL_BGR_EXT                        0x80E0
+#define GL_BGRA_EXT                       0x80E1
+#endif
+
+#ifndef GL_SGIX_async
+#define GL_ASYNC_MARKER_SGIX              0x8329
+#endif
+
+#ifndef GL_SGIX_async_pixel
+#define GL_ASYNC_TEX_IMAGE_SGIX           0x835C
+#define GL_ASYNC_DRAW_PIXELS_SGIX         0x835D
+#define GL_ASYNC_READ_PIXELS_SGIX         0x835E
+#define GL_MAX_ASYNC_TEX_IMAGE_SGIX       0x835F
+#define GL_MAX_ASYNC_DRAW_PIXELS_SGIX     0x8360
+#define GL_MAX_ASYNC_READ_PIXELS_SGIX     0x8361
+#endif
+
+#ifndef GL_SGIX_async_histogram
+#define GL_ASYNC_HISTOGRAM_SGIX           0x832C
+#define GL_MAX_ASYNC_HISTOGRAM_SGIX       0x832D
+#endif
+
+#ifndef GL_INTEL_texture_scissor
+#endif
+
+#ifndef GL_INTEL_parallel_arrays
+#define GL_PARALLEL_ARRAYS_INTEL          0x83F4
+#define GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL 0x83F5
+#define GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL 0x83F6
+#define GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL 0x83F7
+#define GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL 0x83F8
+#endif
+
+#ifndef GL_HP_occlusion_test
+#define GL_OCCLUSION_TEST_HP              0x8165
+#define GL_OCCLUSION_TEST_RESULT_HP       0x8166
+#endif
+
+#ifndef GL_EXT_pixel_transform
+#define GL_PIXEL_TRANSFORM_2D_EXT         0x8330
+#define GL_PIXEL_MAG_FILTER_EXT           0x8331
+#define GL_PIXEL_MIN_FILTER_EXT           0x8332
+#define GL_PIXEL_CUBIC_WEIGHT_EXT         0x8333
+#define GL_CUBIC_EXT                      0x8334
+#define GL_AVERAGE_EXT                    0x8335
+#define GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT 0x8336
+#define GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT 0x8337
+#define GL_PIXEL_TRANSFORM_2D_MATRIX_EXT  0x8338
+#endif
+
+#ifndef GL_EXT_pixel_transform_color_table
+#endif
+
+#ifndef GL_EXT_shared_texture_palette
+#define GL_SHARED_TEXTURE_PALETTE_EXT     0x81FB
+#endif
+
+#ifndef GL_EXT_separate_specular_color
+#define GL_LIGHT_MODEL_COLOR_CONTROL_EXT  0x81F8
+#define GL_SINGLE_COLOR_EXT               0x81F9
+#define GL_SEPARATE_SPECULAR_COLOR_EXT    0x81FA
+#endif
+
+#ifndef GL_EXT_secondary_color
+#define GL_COLOR_SUM_EXT                  0x8458
+#define GL_CURRENT_SECONDARY_COLOR_EXT    0x8459
+#define GL_SECONDARY_COLOR_ARRAY_SIZE_EXT 0x845A
+#define GL_SECONDARY_COLOR_ARRAY_TYPE_EXT 0x845B
+#define GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT 0x845C
+#define GL_SECONDARY_COLOR_ARRAY_POINTER_EXT 0x845D
+#define GL_SECONDARY_COLOR_ARRAY_EXT      0x845E
+#endif
+
+#ifndef GL_EXT_texture_perturb_normal
+#define GL_PERTURB_EXT                    0x85AE
+#define GL_TEXTURE_NORMAL_EXT             0x85AF
+#endif
+
+#ifndef GL_EXT_multi_draw_arrays
+#endif
+
+#ifndef GL_EXT_fog_coord
+#define GL_FOG_COORDINATE_SOURCE_EXT      0x8450
+#define GL_FOG_COORDINATE_EXT             0x8451
+#define GL_FRAGMENT_DEPTH_EXT             0x8452
+#define GL_CURRENT_FOG_COORDINATE_EXT     0x8453
+#define GL_FOG_COORDINATE_ARRAY_TYPE_EXT  0x8454
+#define GL_FOG_COORDINATE_ARRAY_STRIDE_EXT 0x8455
+#define GL_FOG_COORDINATE_ARRAY_POINTER_EXT 0x8456
+#define GL_FOG_COORDINATE_ARRAY_EXT       0x8457
+#endif
+
+#ifndef GL_REND_screen_coordinates
+#define GL_SCREEN_COORDINATES_REND        0x8490
+#define GL_INVERTED_SCREEN_W_REND         0x8491
+#endif
+
+#ifndef GL_EXT_coordinate_frame
+#define GL_TANGENT_ARRAY_EXT              0x8439
+#define GL_BINORMAL_ARRAY_EXT             0x843A
+#define GL_CURRENT_TANGENT_EXT            0x843B
+#define GL_CURRENT_BINORMAL_EXT           0x843C
+#define GL_TANGENT_ARRAY_TYPE_EXT         0x843E
+#define GL_TANGENT_ARRAY_STRIDE_EXT       0x843F
+#define GL_BINORMAL_ARRAY_TYPE_EXT        0x8440
+#define GL_BINORMAL_ARRAY_STRIDE_EXT      0x8441
+#define GL_TANGENT_ARRAY_POINTER_EXT      0x8442
+#define GL_BINORMAL_ARRAY_POINTER_EXT     0x8443
+#define GL_MAP1_TANGENT_EXT               0x8444
+#define GL_MAP2_TANGENT_EXT               0x8445
+#define GL_MAP1_BINORMAL_EXT              0x8446
+#define GL_MAP2_BINORMAL_EXT              0x8447
+#endif
+
+#ifndef GL_EXT_texture_env_combine
+#define GL_COMBINE_EXT                    0x8570
+#define GL_COMBINE_RGB_EXT                0x8571
+#define GL_COMBINE_ALPHA_EXT              0x8572
+#define GL_RGB_SCALE_EXT                  0x8573
+#define GL_ADD_SIGNED_EXT                 0x8574
+#define GL_INTERPOLATE_EXT                0x8575
+#define GL_CONSTANT_EXT                   0x8576
+#define GL_PRIMARY_COLOR_EXT              0x8577
+#define GL_PREVIOUS_EXT                   0x8578
+#define GL_SOURCE0_RGB_EXT                0x8580
+#define GL_SOURCE1_RGB_EXT                0x8581
+#define GL_SOURCE2_RGB_EXT                0x8582
+#define GL_SOURCE0_ALPHA_EXT              0x8588
+#define GL_SOURCE1_ALPHA_EXT              0x8589
+#define GL_SOURCE2_ALPHA_EXT              0x858A
+#define GL_OPERAND0_RGB_EXT               0x8590
+#define GL_OPERAND1_RGB_EXT               0x8591
+#define GL_OPERAND2_RGB_EXT               0x8592
+#define GL_OPERAND0_ALPHA_EXT             0x8598
+#define GL_OPERAND1_ALPHA_EXT             0x8599
+#define GL_OPERAND2_ALPHA_EXT             0x859A
+#endif
+
+#ifndef GL_APPLE_specular_vector
+#define GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE 0x85B0
+#endif
+
+#ifndef GL_APPLE_transform_hint
+#define GL_TRANSFORM_HINT_APPLE           0x85B1
+#endif
+
+#ifndef GL_SGIX_fog_scale
+#define GL_FOG_SCALE_SGIX                 0x81FC
+#define GL_FOG_SCALE_VALUE_SGIX           0x81FD
+#endif
+
+#ifndef GL_SUNX_constant_data
+#define GL_UNPACK_CONSTANT_DATA_SUNX      0x81D5
+#define GL_TEXTURE_CONSTANT_DATA_SUNX     0x81D6
+#endif
+
+#ifndef GL_SUN_global_alpha
+#define GL_GLOBAL_ALPHA_SUN               0x81D9
+#define GL_GLOBAL_ALPHA_FACTOR_SUN        0x81DA
+#endif
+
+#ifndef GL_SUN_triangle_list
+#define GL_RESTART_SUN                    0x0001
+#define GL_REPLACE_MIDDLE_SUN             0x0002
+#define GL_REPLACE_OLDEST_SUN             0x0003
+#define GL_TRIANGLE_LIST_SUN              0x81D7
+#define GL_REPLACEMENT_CODE_SUN           0x81D8
+#define GL_REPLACEMENT_CODE_ARRAY_SUN     0x85C0
+#define GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN 0x85C1
+#define GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN 0x85C2
+#define GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN 0x85C3
+#define GL_R1UI_V3F_SUN                   0x85C4
+#define GL_R1UI_C4UB_V3F_SUN              0x85C5
+#define GL_R1UI_C3F_V3F_SUN               0x85C6
+#define GL_R1UI_N3F_V3F_SUN               0x85C7
+#define GL_R1UI_C4F_N3F_V3F_SUN           0x85C8
+#define GL_R1UI_T2F_V3F_SUN               0x85C9
+#define GL_R1UI_T2F_N3F_V3F_SUN           0x85CA
+#define GL_R1UI_T2F_C4F_N3F_V3F_SUN       0x85CB
+#endif
+
+#ifndef GL_SUN_vertex
+#endif
+
+#ifndef GL_EXT_blend_func_separate
+#define GL_BLEND_DST_RGB_EXT              0x80C8
+#define GL_BLEND_SRC_RGB_EXT              0x80C9
+#define GL_BLEND_DST_ALPHA_EXT            0x80CA
+#define GL_BLEND_SRC_ALPHA_EXT            0x80CB
+#endif
+
+#ifndef GL_INGR_color_clamp
+#define GL_RED_MIN_CLAMP_INGR             0x8560
+#define GL_GREEN_MIN_CLAMP_INGR           0x8561
+#define GL_BLUE_MIN_CLAMP_INGR            0x8562
+#define GL_ALPHA_MIN_CLAMP_INGR           0x8563
+#define GL_RED_MAX_CLAMP_INGR             0x8564
+#define GL_GREEN_MAX_CLAMP_INGR           0x8565
+#define GL_BLUE_MAX_CLAMP_INGR            0x8566
+#define GL_ALPHA_MAX_CLAMP_INGR           0x8567
+#endif
+
+#ifndef GL_INGR_interlace_read
+#define GL_INTERLACE_READ_INGR            0x8568
+#endif
+
+#ifndef GL_EXT_stencil_wrap
+#define GL_INCR_WRAP_EXT                  0x8507
+#define GL_DECR_WRAP_EXT                  0x8508
+#endif
+
+#ifndef GL_EXT_422_pixels
+#define GL_422_EXT                        0x80CC
+#define GL_422_REV_EXT                    0x80CD
+#define GL_422_AVERAGE_EXT                0x80CE
+#define GL_422_REV_AVERAGE_EXT            0x80CF
+#endif
+
+#ifndef GL_NV_texgen_reflection
+#define GL_NORMAL_MAP_NV                  0x8511
+#define GL_REFLECTION_MAP_NV              0x8512
+#endif
+
+#ifndef GL_EXT_texture_cube_map
+#define GL_NORMAL_MAP_EXT                 0x8511
+#define GL_REFLECTION_MAP_EXT             0x8512
+#define GL_TEXTURE_CUBE_MAP_EXT           0x8513
+#define GL_TEXTURE_BINDING_CUBE_MAP_EXT   0x8514
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT 0x8515
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT 0x8516
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT 0x8517
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT 0x8518
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT 0x8519
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT 0x851A
+#define GL_PROXY_TEXTURE_CUBE_MAP_EXT     0x851B
+#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT  0x851C
+#endif
+
+#ifndef GL_SUN_convolution_border_modes
+#define GL_WRAP_BORDER_SUN                0x81D4
+#endif
+
+#ifndef GL_EXT_texture_env_add
+#endif
+
+#ifndef GL_EXT_texture_lod_bias
+#define GL_MAX_TEXTURE_LOD_BIAS_EXT       0x84FD
+#define GL_TEXTURE_FILTER_CONTROL_EXT     0x8500
+#define GL_TEXTURE_LOD_BIAS_EXT           0x8501
+#endif
+
+#ifndef GL_EXT_texture_filter_anisotropic
+#define GL_TEXTURE_MAX_ANISOTROPY_EXT     0x84FE
+#define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF
+#endif
+
+#ifndef GL_EXT_vertex_weighting
+#define GL_MODELVIEW0_STACK_DEPTH_EXT     GL_MODELVIEW_STACK_DEPTH
+#define GL_MODELVIEW1_STACK_DEPTH_EXT     0x8502
+#define GL_MODELVIEW0_MATRIX_EXT          GL_MODELVIEW_MATRIX
+#define GL_MODELVIEW1_MATRIX_EXT          0x8506
+#define GL_VERTEX_WEIGHTING_EXT           0x8509
+#define GL_MODELVIEW0_EXT                 GL_MODELVIEW
+#define GL_MODELVIEW1_EXT                 0x850A
+#define GL_CURRENT_VERTEX_WEIGHT_EXT      0x850B
+#define GL_VERTEX_WEIGHT_ARRAY_EXT        0x850C
+#define GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT   0x850D
+#define GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT   0x850E
+#define GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT 0x850F
+#define GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT 0x8510
+#endif
+
+#ifndef GL_NV_light_max_exponent
+#define GL_MAX_SHININESS_NV               0x8504
+#define GL_MAX_SPOT_EXPONENT_NV           0x8505
+#endif
+
+#ifndef GL_NV_vertex_array_range
+#define GL_VERTEX_ARRAY_RANGE_NV          0x851D
+#define GL_VERTEX_ARRAY_RANGE_LENGTH_NV   0x851E
+#define GL_VERTEX_ARRAY_RANGE_VALID_NV    0x851F
+#define GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV 0x8520
+#define GL_VERTEX_ARRAY_RANGE_POINTER_NV  0x8521
+#endif
+
+#ifndef GL_NV_register_combiners
+#define GL_REGISTER_COMBINERS_NV          0x8522
+#define GL_VARIABLE_A_NV                  0x8523
+#define GL_VARIABLE_B_NV                  0x8524
+#define GL_VARIABLE_C_NV                  0x8525
+#define GL_VARIABLE_D_NV                  0x8526
+#define GL_VARIABLE_E_NV                  0x8527
+#define GL_VARIABLE_F_NV                  0x8528
+#define GL_VARIABLE_G_NV                  0x8529
+#define GL_CONSTANT_COLOR0_NV             0x852A
+#define GL_CONSTANT_COLOR1_NV             0x852B
+#define GL_PRIMARY_COLOR_NV               0x852C
+#define GL_SECONDARY_COLOR_NV             0x852D
+#define GL_SPARE0_NV                      0x852E
+#define GL_SPARE1_NV                      0x852F
+#define GL_DISCARD_NV                     0x8530
+#define GL_E_TIMES_F_NV                   0x8531
+#define GL_SPARE0_PLUS_SECONDARY_COLOR_NV 0x8532
+#define GL_UNSIGNED_IDENTITY_NV           0x8536
+#define GL_UNSIGNED_INVERT_NV             0x8537
+#define GL_EXPAND_NORMAL_NV               0x8538
+#define GL_EXPAND_NEGATE_NV               0x8539
+#define GL_HALF_BIAS_NORMAL_NV            0x853A
+#define GL_HALF_BIAS_NEGATE_NV            0x853B
+#define GL_SIGNED_IDENTITY_NV             0x853C
+#define GL_SIGNED_NEGATE_NV               0x853D
+#define GL_SCALE_BY_TWO_NV                0x853E
+#define GL_SCALE_BY_FOUR_NV               0x853F
+#define GL_SCALE_BY_ONE_HALF_NV           0x8540
+#define GL_BIAS_BY_NEGATIVE_ONE_HALF_NV   0x8541
+#define GL_COMBINER_INPUT_NV              0x8542
+#define GL_COMBINER_MAPPING_NV            0x8543
+#define GL_COMBINER_COMPONENT_USAGE_NV    0x8544
+#define GL_COMBINER_AB_DOT_PRODUCT_NV     0x8545
+#define GL_COMBINER_CD_DOT_PRODUCT_NV     0x8546
+#define GL_COMBINER_MUX_SUM_NV            0x8547
+#define GL_COMBINER_SCALE_NV              0x8548
+#define GL_COMBINER_BIAS_NV               0x8549
+#define GL_COMBINER_AB_OUTPUT_NV          0x854A
+#define GL_COMBINER_CD_OUTPUT_NV          0x854B
+#define GL_COMBINER_SUM_OUTPUT_NV         0x854C
+#define GL_MAX_GENERAL_COMBINERS_NV       0x854D
+#define GL_NUM_GENERAL_COMBINERS_NV       0x854E
+#define GL_COLOR_SUM_CLAMP_NV             0x854F
+#define GL_COMBINER0_NV                   0x8550
+#define GL_COMBINER1_NV                   0x8551
+#define GL_COMBINER2_NV                   0x8552
+#define GL_COMBINER3_NV                   0x8553
+#define GL_COMBINER4_NV                   0x8554
+#define GL_COMBINER5_NV                   0x8555
+#define GL_COMBINER6_NV                   0x8556
+#define GL_COMBINER7_NV                   0x8557
+/* reuse GL_TEXTURE0_ARB */
+/* reuse GL_TEXTURE1_ARB */
+/* reuse GL_ZERO */
+/* reuse GL_NONE */
+/* reuse GL_FOG */
+#endif
+
+#ifndef GL_NV_fog_distance
+#define GL_FOG_DISTANCE_MODE_NV           0x855A
+#define GL_EYE_RADIAL_NV                  0x855B
+#define GL_EYE_PLANE_ABSOLUTE_NV          0x855C
+/* reuse GL_EYE_PLANE */
+#endif
+
+#ifndef GL_NV_texgen_emboss
+#define GL_EMBOSS_LIGHT_NV                0x855D
+#define GL_EMBOSS_CONSTANT_NV             0x855E
+#define GL_EMBOSS_MAP_NV                  0x855F
+#endif
+
+#ifndef GL_NV_blend_square
+#endif
+
+#ifndef GL_NV_texture_env_combine4
+#define GL_COMBINE4_NV                    0x8503
+#define GL_SOURCE3_RGB_NV                 0x8583
+#define GL_SOURCE3_ALPHA_NV               0x858B
+#define GL_OPERAND3_RGB_NV                0x8593
+#define GL_OPERAND3_ALPHA_NV              0x859B
+#endif
+
+#ifndef GL_MESA_resize_buffers
+#endif
+
+#ifndef GL_MESA_window_pos
+#endif
+
+#ifndef GL_EXT_texture_compression_s3tc
+#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT   0x83F0
+#define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT  0x83F1
+#define GL_COMPRESSED_RGBA_S3TC_DXT3_EXT  0x83F2
+#define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT  0x83F3
+#endif
+
+#ifndef GL_IBM_cull_vertex
+#define GL_CULL_VERTEX_IBM                103050
+#endif
+
+#ifndef GL_IBM_multimode_draw_arrays
+#endif
+
+#ifndef GL_IBM_vertex_array_lists
+#define GL_VERTEX_ARRAY_LIST_IBM          103070
+#define GL_NORMAL_ARRAY_LIST_IBM          103071
+#define GL_COLOR_ARRAY_LIST_IBM           103072
+#define GL_INDEX_ARRAY_LIST_IBM           103073
+#define GL_TEXTURE_COORD_ARRAY_LIST_IBM   103074
+#define GL_EDGE_FLAG_ARRAY_LIST_IBM       103075
+#define GL_FOG_COORDINATE_ARRAY_LIST_IBM  103076
+#define GL_SECONDARY_COLOR_ARRAY_LIST_IBM 103077
+#define GL_VERTEX_ARRAY_LIST_STRIDE_IBM   103080
+#define GL_NORMAL_ARRAY_LIST_STRIDE_IBM   103081
+#define GL_COLOR_ARRAY_LIST_STRIDE_IBM    103082
+#define GL_INDEX_ARRAY_LIST_STRIDE_IBM    103083
+#define GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM 103084
+#define GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM 103085
+#define GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM 103086
+#define GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM 103087
+#endif
+
+#ifndef GL_SGIX_subsample
+#define GL_PACK_SUBSAMPLE_RATE_SGIX       0x85A0
+#define GL_UNPACK_SUBSAMPLE_RATE_SGIX     0x85A1
+#define GL_PIXEL_SUBSAMPLE_4444_SGIX      0x85A2
+#define GL_PIXEL_SUBSAMPLE_2424_SGIX      0x85A3
+#define GL_PIXEL_SUBSAMPLE_4242_SGIX      0x85A4
+#endif
+
+#ifndef GL_SGIX_ycrcb_subsample
+#endif
+
+#ifndef GL_SGIX_ycrcba
+#define GL_YCRCB_SGIX                     0x8318
+#define GL_YCRCBA_SGIX                    0x8319
+#endif
+
+#ifndef GL_SGI_depth_pass_instrument
+#define GL_DEPTH_PASS_INSTRUMENT_SGIX     0x8310
+#define GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX 0x8311
+#define GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX 0x8312
+#endif
+
+#ifndef GL_3DFX_texture_compression_FXT1
+#define GL_COMPRESSED_RGB_FXT1_3DFX       0x86B0
+#define GL_COMPRESSED_RGBA_FXT1_3DFX      0x86B1
+#endif
+
+#ifndef GL_3DFX_multisample
+#define GL_MULTISAMPLE_3DFX               0x86B2
+#define GL_SAMPLE_BUFFERS_3DFX            0x86B3
+#define GL_SAMPLES_3DFX                   0x86B4
+#define GL_MULTISAMPLE_BIT_3DFX           0x20000000
+#endif
+
+#ifndef GL_3DFX_tbuffer
+#endif
+
+#ifndef GL_EXT_multisample
+#define GL_MULTISAMPLE_EXT                0x809D
+#define GL_SAMPLE_ALPHA_TO_MASK_EXT       0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE_EXT        0x809F
+#define GL_SAMPLE_MASK_EXT                0x80A0
+#define GL_1PASS_EXT                      0x80A1
+#define GL_2PASS_0_EXT                    0x80A2
+#define GL_2PASS_1_EXT                    0x80A3
+#define GL_4PASS_0_EXT                    0x80A4
+#define GL_4PASS_1_EXT                    0x80A5
+#define GL_4PASS_2_EXT                    0x80A6
+#define GL_4PASS_3_EXT                    0x80A7
+#define GL_SAMPLE_BUFFERS_EXT             0x80A8
+#define GL_SAMPLES_EXT                    0x80A9
+#define GL_SAMPLE_MASK_VALUE_EXT          0x80AA
+#define GL_SAMPLE_MASK_INVERT_EXT         0x80AB
+#define GL_SAMPLE_PATTERN_EXT             0x80AC
+#define GL_MULTISAMPLE_BIT_EXT            0x20000000
+#endif
+
+#ifndef GL_SGIX_vertex_preclip
+#define GL_VERTEX_PRECLIP_SGIX            0x83EE
+#define GL_VERTEX_PRECLIP_HINT_SGIX       0x83EF
+#endif
+
+#ifndef GL_SGIX_convolution_accuracy
+#define GL_CONVOLUTION_HINT_SGIX          0x8316
+#endif
+
+#ifndef GL_SGIX_resample
+#define GL_PACK_RESAMPLE_SGIX             0x842C
+#define GL_UNPACK_RESAMPLE_SGIX           0x842D
+#define GL_RESAMPLE_REPLICATE_SGIX        0x842E
+#define GL_RESAMPLE_ZERO_FILL_SGIX        0x842F
+#define GL_RESAMPLE_DECIMATE_SGIX         0x8430
+#endif
+
+#ifndef GL_SGIS_point_line_texgen
+#define GL_EYE_DISTANCE_TO_POINT_SGIS     0x81F0
+#define GL_OBJECT_DISTANCE_TO_POINT_SGIS  0x81F1
+#define GL_EYE_DISTANCE_TO_LINE_SGIS      0x81F2
+#define GL_OBJECT_DISTANCE_TO_LINE_SGIS   0x81F3
+#define GL_EYE_POINT_SGIS                 0x81F4
+#define GL_OBJECT_POINT_SGIS              0x81F5
+#define GL_EYE_LINE_SGIS                  0x81F6
+#define GL_OBJECT_LINE_SGIS               0x81F7
+#endif
+
+#ifndef GL_SGIS_texture_color_mask
+#define GL_TEXTURE_COLOR_WRITEMASK_SGIS   0x81EF
+#endif
+
+#ifndef GL_EXT_texture_env_dot3
+#define GL_DOT3_RGB_EXT                   0x8740
+#define GL_DOT3_RGBA_EXT                  0x8741
+#endif
+
+#ifndef GL_ATI_texture_mirror_once
+#define GL_MIRROR_CLAMP_ATI               0x8742
+#define GL_MIRROR_CLAMP_TO_EDGE_ATI       0x8743
+#endif
+
+#ifndef GL_NV_fence
+#define GL_ALL_COMPLETED_NV               0x84F2
+#define GL_FENCE_STATUS_NV                0x84F3
+#define GL_FENCE_CONDITION_NV             0x84F4
+#endif
+
+#ifndef GL_IBM_texture_mirrored_repeat
+#define GL_MIRRORED_REPEAT_IBM            0x8370
+#endif
+
+#ifndef GL_NV_evaluators
+#define GL_EVAL_2D_NV                     0x86C0
+#define GL_EVAL_TRIANGULAR_2D_NV          0x86C1
+#define GL_MAP_TESSELLATION_NV            0x86C2
+#define GL_MAP_ATTRIB_U_ORDER_NV          0x86C3
+#define GL_MAP_ATTRIB_V_ORDER_NV          0x86C4
+#define GL_EVAL_FRACTIONAL_TESSELLATION_NV 0x86C5
+#define GL_EVAL_VERTEX_ATTRIB0_NV         0x86C6
+#define GL_EVAL_VERTEX_ATTRIB1_NV         0x86C7
+#define GL_EVAL_VERTEX_ATTRIB2_NV         0x86C8
+#define GL_EVAL_VERTEX_ATTRIB3_NV         0x86C9
+#define GL_EVAL_VERTEX_ATTRIB4_NV         0x86CA
+#define GL_EVAL_VERTEX_ATTRIB5_NV         0x86CB
+#define GL_EVAL_VERTEX_ATTRIB6_NV         0x86CC
+#define GL_EVAL_VERTEX_ATTRIB7_NV         0x86CD
+#define GL_EVAL_VERTEX_ATTRIB8_NV         0x86CE
+#define GL_EVAL_VERTEX_ATTRIB9_NV         0x86CF
+#define GL_EVAL_VERTEX_ATTRIB10_NV        0x86D0
+#define GL_EVAL_VERTEX_ATTRIB11_NV        0x86D1
+#define GL_EVAL_VERTEX_ATTRIB12_NV        0x86D2
+#define GL_EVAL_VERTEX_ATTRIB13_NV        0x86D3
+#define GL_EVAL_VERTEX_ATTRIB14_NV        0x86D4
+#define GL_EVAL_VERTEX_ATTRIB15_NV        0x86D5
+#define GL_MAX_MAP_TESSELLATION_NV        0x86D6
+#define GL_MAX_RATIONAL_EVAL_ORDER_NV     0x86D7
+#endif
+
+#ifndef GL_NV_packed_depth_stencil
+#define GL_DEPTH_STENCIL_NV               0x84F9
+#define GL_UNSIGNED_INT_24_8_NV           0x84FA
+#endif
+
+#ifndef GL_NV_register_combiners2
+#define GL_PER_STAGE_CONSTANTS_NV         0x8535
+#endif
+
+#ifndef GL_NV_texture_compression_vtc
+#endif
+
+#ifndef GL_NV_texture_rectangle
+#define GL_TEXTURE_RECTANGLE_NV           0x84F5
+#define GL_TEXTURE_BINDING_RECTANGLE_NV   0x84F6
+#define GL_PROXY_TEXTURE_RECTANGLE_NV     0x84F7
+#define GL_MAX_RECTANGLE_TEXTURE_SIZE_NV  0x84F8
+#endif
+
+#ifndef GL_NV_texture_shader
+#define GL_OFFSET_TEXTURE_RECTANGLE_NV    0x864C
+#define GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV 0x864D
+#define GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV 0x864E
+#define GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV 0x86D9
+#define GL_UNSIGNED_INT_S8_S8_8_8_NV      0x86DA
+#define GL_UNSIGNED_INT_8_8_S8_S8_REV_NV  0x86DB
+#define GL_DSDT_MAG_INTENSITY_NV          0x86DC
+#define GL_SHADER_CONSISTENT_NV           0x86DD
+#define GL_TEXTURE_SHADER_NV              0x86DE
+#define GL_SHADER_OPERATION_NV            0x86DF
+#define GL_CULL_MODES_NV                  0x86E0
+#define GL_OFFSET_TEXTURE_MATRIX_NV       0x86E1
+#define GL_OFFSET_TEXTURE_SCALE_NV        0x86E2
+#define GL_OFFSET_TEXTURE_BIAS_NV         0x86E3
+#define GL_OFFSET_TEXTURE_2D_MATRIX_NV    GL_OFFSET_TEXTURE_MATRIX_NV
+#define GL_OFFSET_TEXTURE_2D_SCALE_NV     GL_OFFSET_TEXTURE_SCALE_NV
+#define GL_OFFSET_TEXTURE_2D_BIAS_NV      GL_OFFSET_TEXTURE_BIAS_NV
+#define GL_PREVIOUS_TEXTURE_INPUT_NV      0x86E4
+#define GL_CONST_EYE_NV                   0x86E5
+#define GL_PASS_THROUGH_NV                0x86E6
+#define GL_CULL_FRAGMENT_NV               0x86E7
+#define GL_OFFSET_TEXTURE_2D_NV           0x86E8
+#define GL_DEPENDENT_AR_TEXTURE_2D_NV     0x86E9
+#define GL_DEPENDENT_GB_TEXTURE_2D_NV     0x86EA
+#define GL_DOT_PRODUCT_NV                 0x86EC
+#define GL_DOT_PRODUCT_DEPTH_REPLACE_NV   0x86ED
+#define GL_DOT_PRODUCT_TEXTURE_2D_NV      0x86EE
+#define GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV 0x86F0
+#define GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV 0x86F1
+#define GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV 0x86F2
+#define GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV 0x86F3
+#define GL_HILO_NV                        0x86F4
+#define GL_DSDT_NV                        0x86F5
+#define GL_DSDT_MAG_NV                    0x86F6
+#define GL_DSDT_MAG_VIB_NV                0x86F7
+#define GL_HILO16_NV                      0x86F8
+#define GL_SIGNED_HILO_NV                 0x86F9
+#define GL_SIGNED_HILO16_NV               0x86FA
+#define GL_SIGNED_RGBA_NV                 0x86FB
+#define GL_SIGNED_RGBA8_NV                0x86FC
+#define GL_SIGNED_RGB_NV                  0x86FE
+#define GL_SIGNED_RGB8_NV                 0x86FF
+#define GL_SIGNED_LUMINANCE_NV            0x8701
+#define GL_SIGNED_LUMINANCE8_NV           0x8702
+#define GL_SIGNED_LUMINANCE_ALPHA_NV      0x8703
+#define GL_SIGNED_LUMINANCE8_ALPHA8_NV    0x8704
+#define GL_SIGNED_ALPHA_NV                0x8705
+#define GL_SIGNED_ALPHA8_NV               0x8706
+#define GL_SIGNED_INTENSITY_NV            0x8707
+#define GL_SIGNED_INTENSITY8_NV           0x8708
+#define GL_DSDT8_NV                       0x8709
+#define GL_DSDT8_MAG8_NV                  0x870A
+#define GL_DSDT8_MAG8_INTENSITY8_NV       0x870B
+#define GL_SIGNED_RGB_UNSIGNED_ALPHA_NV   0x870C
+#define GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV 0x870D
+#define GL_HI_SCALE_NV                    0x870E
+#define GL_LO_SCALE_NV                    0x870F
+#define GL_DS_SCALE_NV                    0x8710
+#define GL_DT_SCALE_NV                    0x8711
+#define GL_MAGNITUDE_SCALE_NV             0x8712
+#define GL_VIBRANCE_SCALE_NV              0x8713
+#define GL_HI_BIAS_NV                     0x8714
+#define GL_LO_BIAS_NV                     0x8715
+#define GL_DS_BIAS_NV                     0x8716
+#define GL_DT_BIAS_NV                     0x8717
+#define GL_MAGNITUDE_BIAS_NV              0x8718
+#define GL_VIBRANCE_BIAS_NV               0x8719
+#define GL_TEXTURE_BORDER_VALUES_NV       0x871A
+#define GL_TEXTURE_HI_SIZE_NV             0x871B
+#define GL_TEXTURE_LO_SIZE_NV             0x871C
+#define GL_TEXTURE_DS_SIZE_NV             0x871D
+#define GL_TEXTURE_DT_SIZE_NV             0x871E
+#define GL_TEXTURE_MAG_SIZE_NV            0x871F
+#endif
+
+#ifndef GL_NV_texture_shader2
+#define GL_DOT_PRODUCT_TEXTURE_3D_NV      0x86EF
+#endif
+
+#ifndef GL_NV_vertex_array_range2
+#define GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV 0x8533
+#endif
+
+#ifndef GL_NV_vertex_program
+#define GL_VERTEX_PROGRAM_NV              0x8620
+#define GL_VERTEX_STATE_PROGRAM_NV        0x8621
+#define GL_ATTRIB_ARRAY_SIZE_NV           0x8623
+#define GL_ATTRIB_ARRAY_STRIDE_NV         0x8624
+#define GL_ATTRIB_ARRAY_TYPE_NV           0x8625
+#define GL_CURRENT_ATTRIB_NV              0x8626
+#define GL_PROGRAM_LENGTH_NV              0x8627
+#define GL_PROGRAM_STRING_NV              0x8628
+#define GL_MODELVIEW_PROJECTION_NV        0x8629
+#define GL_IDENTITY_NV                    0x862A
+#define GL_INVERSE_NV                     0x862B
+#define GL_TRANSPOSE_NV                   0x862C
+#define GL_INVERSE_TRANSPOSE_NV           0x862D
+#define GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV 0x862E
+#define GL_MAX_TRACK_MATRICES_NV          0x862F
+#define GL_MATRIX0_NV                     0x8630
+#define GL_MATRIX1_NV                     0x8631
+#define GL_MATRIX2_NV                     0x8632
+#define GL_MATRIX3_NV                     0x8633
+#define GL_MATRIX4_NV                     0x8634
+#define GL_MATRIX5_NV                     0x8635
+#define GL_MATRIX6_NV                     0x8636
+#define GL_MATRIX7_NV                     0x8637
+#define GL_CURRENT_MATRIX_STACK_DEPTH_NV  0x8640
+#define GL_CURRENT_MATRIX_NV              0x8641
+#define GL_VERTEX_PROGRAM_POINT_SIZE_NV   0x8642
+#define GL_VERTEX_PROGRAM_TWO_SIDE_NV     0x8643
+#define GL_PROGRAM_PARAMETER_NV           0x8644
+#define GL_ATTRIB_ARRAY_POINTER_NV        0x8645
+#define GL_PROGRAM_TARGET_NV              0x8646
+#define GL_PROGRAM_RESIDENT_NV            0x8647
+#define GL_TRACK_MATRIX_NV                0x8648
+#define GL_TRACK_MATRIX_TRANSFORM_NV      0x8649
+#define GL_VERTEX_PROGRAM_BINDING_NV      0x864A
+#define GL_PROGRAM_ERROR_POSITION_NV      0x864B
+#define GL_VERTEX_ATTRIB_ARRAY0_NV        0x8650
+#define GL_VERTEX_ATTRIB_ARRAY1_NV        0x8651
+#define GL_VERTEX_ATTRIB_ARRAY2_NV        0x8652
+#define GL_VERTEX_ATTRIB_ARRAY3_NV        0x8653
+#define GL_VERTEX_ATTRIB_ARRAY4_NV        0x8654
+#define GL_VERTEX_ATTRIB_ARRAY5_NV        0x8655
+#define GL_VERTEX_ATTRIB_ARRAY6_NV        0x8656
+#define GL_VERTEX_ATTRIB_ARRAY7_NV        0x8657
+#define GL_VERTEX_ATTRIB_ARRAY8_NV        0x8658
+#define GL_VERTEX_ATTRIB_ARRAY9_NV        0x8659
+#define GL_VERTEX_ATTRIB_ARRAY10_NV       0x865A
+#define GL_VERTEX_ATTRIB_ARRAY11_NV       0x865B
+#define GL_VERTEX_ATTRIB_ARRAY12_NV       0x865C
+#define GL_VERTEX_ATTRIB_ARRAY13_NV       0x865D
+#define GL_VERTEX_ATTRIB_ARRAY14_NV       0x865E
+#define GL_VERTEX_ATTRIB_ARRAY15_NV       0x865F
+#define GL_MAP1_VERTEX_ATTRIB0_4_NV       0x8660
+#define GL_MAP1_VERTEX_ATTRIB1_4_NV       0x8661
+#define GL_MAP1_VERTEX_ATTRIB2_4_NV       0x8662
+#define GL_MAP1_VERTEX_ATTRIB3_4_NV       0x8663
+#define GL_MAP1_VERTEX_ATTRIB4_4_NV       0x8664
+#define GL_MAP1_VERTEX_ATTRIB5_4_NV       0x8665
+#define GL_MAP1_VERTEX_ATTRIB6_4_NV       0x8666
+#define GL_MAP1_VERTEX_ATTRIB7_4_NV       0x8667
+#define GL_MAP1_VERTEX_ATTRIB8_4_NV       0x8668
+#define GL_MAP1_VERTEX_ATTRIB9_4_NV       0x8669
+#define GL_MAP1_VERTEX_ATTRIB10_4_NV      0x866A
+#define GL_MAP1_VERTEX_ATTRIB11_4_NV      0x866B
+#define GL_MAP1_VERTEX_ATTRIB12_4_NV      0x866C
+#define GL_MAP1_VERTEX_ATTRIB13_4_NV      0x866D
+#define GL_MAP1_VERTEX_ATTRIB14_4_NV      0x866E
+#define GL_MAP1_VERTEX_ATTRIB15_4_NV      0x866F
+#define GL_MAP2_VERTEX_ATTRIB0_4_NV       0x8670
+#define GL_MAP2_VERTEX_ATTRIB1_4_NV       0x8671
+#define GL_MAP2_VERTEX_ATTRIB2_4_NV       0x8672
+#define GL_MAP2_VERTEX_ATTRIB3_4_NV       0x8673
+#define GL_MAP2_VERTEX_ATTRIB4_4_NV       0x8674
+#define GL_MAP2_VERTEX_ATTRIB5_4_NV       0x8675
+#define GL_MAP2_VERTEX_ATTRIB6_4_NV       0x8676
+#define GL_MAP2_VERTEX_ATTRIB7_4_NV       0x8677
+#define GL_MAP2_VERTEX_ATTRIB8_4_NV       0x8678
+#define GL_MAP2_VERTEX_ATTRIB9_4_NV       0x8679
+#define GL_MAP2_VERTEX_ATTRIB10_4_NV      0x867A
+#define GL_MAP2_VERTEX_ATTRIB11_4_NV      0x867B
+#define GL_MAP2_VERTEX_ATTRIB12_4_NV      0x867C
+#define GL_MAP2_VERTEX_ATTRIB13_4_NV      0x867D
+#define GL_MAP2_VERTEX_ATTRIB14_4_NV      0x867E
+#define GL_MAP2_VERTEX_ATTRIB15_4_NV      0x867F
+#endif
+
+#ifndef GL_SGIX_texture_coordinate_clamp
+#define GL_TEXTURE_MAX_CLAMP_S_SGIX       0x8369
+#define GL_TEXTURE_MAX_CLAMP_T_SGIX       0x836A
+#define GL_TEXTURE_MAX_CLAMP_R_SGIX       0x836B
+#endif
+
+#ifndef GL_SGIX_scalebias_hint
+#define GL_SCALEBIAS_HINT_SGIX            0x8322
+#endif
+
+#ifndef GL_OML_interlace
+#define GL_INTERLACE_OML                  0x8980
+#define GL_INTERLACE_READ_OML             0x8981
+#endif
+
+#ifndef GL_OML_subsample
+#define GL_FORMAT_SUBSAMPLE_24_24_OML     0x8982
+#define GL_FORMAT_SUBSAMPLE_244_244_OML   0x8983
+#endif
+
+#ifndef GL_OML_resample
+#define GL_PACK_RESAMPLE_OML              0x8984
+#define GL_UNPACK_RESAMPLE_OML            0x8985
+#define GL_RESAMPLE_REPLICATE_OML         0x8986
+#define GL_RESAMPLE_ZERO_FILL_OML         0x8987
+#define GL_RESAMPLE_AVERAGE_OML           0x8988
+#define GL_RESAMPLE_DECIMATE_OML          0x8989
+#endif
+
+#ifndef GL_NV_copy_depth_to_color
+#define GL_DEPTH_STENCIL_TO_RGBA_NV       0x886E
+#define GL_DEPTH_STENCIL_TO_BGRA_NV       0x886F
+#endif
+
+#ifndef GL_ATI_envmap_bumpmap
+#define GL_BUMP_ROT_MATRIX_ATI            0x8775
+#define GL_BUMP_ROT_MATRIX_SIZE_ATI       0x8776
+#define GL_BUMP_NUM_TEX_UNITS_ATI         0x8777
+#define GL_BUMP_TEX_UNITS_ATI             0x8778
+#define GL_DUDV_ATI                       0x8779
+#define GL_DU8DV8_ATI                     0x877A
+#define GL_BUMP_ENVMAP_ATI                0x877B
+#define GL_BUMP_TARGET_ATI                0x877C
+#endif
+
+#ifndef GL_ATI_fragment_shader
+#define GL_FRAGMENT_SHADER_ATI            0x8920
+#define GL_REG_0_ATI                      0x8921
+#define GL_REG_1_ATI                      0x8922
+#define GL_REG_2_ATI                      0x8923
+#define GL_REG_3_ATI                      0x8924
+#define GL_REG_4_ATI                      0x8925
+#define GL_REG_5_ATI                      0x8926
+#define GL_REG_6_ATI                      0x8927
+#define GL_REG_7_ATI                      0x8928
+#define GL_REG_8_ATI                      0x8929
+#define GL_REG_9_ATI                      0x892A
+#define GL_REG_10_ATI                     0x892B
+#define GL_REG_11_ATI                     0x892C
+#define GL_REG_12_ATI                     0x892D
+#define GL_REG_13_ATI                     0x892E
+#define GL_REG_14_ATI                     0x892F
+#define GL_REG_15_ATI                     0x8930
+#define GL_REG_16_ATI                     0x8931
+#define GL_REG_17_ATI                     0x8932
+#define GL_REG_18_ATI                     0x8933
+#define GL_REG_19_ATI                     0x8934
+#define GL_REG_20_ATI                     0x8935
+#define GL_REG_21_ATI                     0x8936
+#define GL_REG_22_ATI                     0x8937
+#define GL_REG_23_ATI                     0x8938
+#define GL_REG_24_ATI                     0x8939
+#define GL_REG_25_ATI                     0x893A
+#define GL_REG_26_ATI                     0x893B
+#define GL_REG_27_ATI                     0x893C
+#define GL_REG_28_ATI                     0x893D
+#define GL_REG_29_ATI                     0x893E
+#define GL_REG_30_ATI                     0x893F
+#define GL_REG_31_ATI                     0x8940
+#define GL_CON_0_ATI                      0x8941
+#define GL_CON_1_ATI                      0x8942
+#define GL_CON_2_ATI                      0x8943
+#define GL_CON_3_ATI                      0x8944
+#define GL_CON_4_ATI                      0x8945
+#define GL_CON_5_ATI                      0x8946
+#define GL_CON_6_ATI                      0x8947
+#define GL_CON_7_ATI                      0x8948
+#define GL_CON_8_ATI                      0x8949
+#define GL_CON_9_ATI                      0x894A
+#define GL_CON_10_ATI                     0x894B
+#define GL_CON_11_ATI                     0x894C
+#define GL_CON_12_ATI                     0x894D
+#define GL_CON_13_ATI                     0x894E
+#define GL_CON_14_ATI                     0x894F
+#define GL_CON_15_ATI                     0x8950
+#define GL_CON_16_ATI                     0x8951
+#define GL_CON_17_ATI                     0x8952
+#define GL_CON_18_ATI                     0x8953
+#define GL_CON_19_ATI                     0x8954
+#define GL_CON_20_ATI                     0x8955
+#define GL_CON_21_ATI                     0x8956
+#define GL_CON_22_ATI                     0x8957
+#define GL_CON_23_ATI                     0x8958
+#define GL_CON_24_ATI                     0x8959
+#define GL_CON_25_ATI                     0x895A
+#define GL_CON_26_ATI                     0x895B
+#define GL_CON_27_ATI                     0x895C
+#define GL_CON_28_ATI                     0x895D
+#define GL_CON_29_ATI                     0x895E
+#define GL_CON_30_ATI                     0x895F
+#define GL_CON_31_ATI                     0x8960
+#define GL_MOV_ATI                        0x8961
+#define GL_ADD_ATI                        0x8963
+#define GL_MUL_ATI                        0x8964
+#define GL_SUB_ATI                        0x8965
+#define GL_DOT3_ATI                       0x8966
+#define GL_DOT4_ATI                       0x8967
+#define GL_MAD_ATI                        0x8968
+#define GL_LERP_ATI                       0x8969
+#define GL_CND_ATI                        0x896A
+#define GL_CND0_ATI                       0x896B
+#define GL_DOT2_ADD_ATI                   0x896C
+#define GL_SECONDARY_INTERPOLATOR_ATI     0x896D
+#define GL_NUM_FRAGMENT_REGISTERS_ATI     0x896E
+#define GL_NUM_FRAGMENT_CONSTANTS_ATI     0x896F
+#define GL_NUM_PASSES_ATI                 0x8970
+#define GL_NUM_INSTRUCTIONS_PER_PASS_ATI  0x8971
+#define GL_NUM_INSTRUCTIONS_TOTAL_ATI     0x8972
+#define GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI 0x8973
+#define GL_NUM_LOOPBACK_COMPONENTS_ATI    0x8974
+#define GL_COLOR_ALPHA_PAIRING_ATI        0x8975
+#define GL_SWIZZLE_STR_ATI                0x8976
+#define GL_SWIZZLE_STQ_ATI                0x8977
+#define GL_SWIZZLE_STR_DR_ATI             0x8978
+#define GL_SWIZZLE_STQ_DQ_ATI             0x8979
+#define GL_SWIZZLE_STRQ_ATI               0x897A
+#define GL_SWIZZLE_STRQ_DQ_ATI            0x897B
+#define GL_RED_BIT_ATI                    0x00000001
+#define GL_GREEN_BIT_ATI                  0x00000002
+#define GL_BLUE_BIT_ATI                   0x00000004
+#define GL_2X_BIT_ATI                     0x00000001
+#define GL_4X_BIT_ATI                     0x00000002
+#define GL_8X_BIT_ATI                     0x00000004
+#define GL_HALF_BIT_ATI                   0x00000008
+#define GL_QUARTER_BIT_ATI                0x00000010
+#define GL_EIGHTH_BIT_ATI                 0x00000020
+#define GL_SATURATE_BIT_ATI               0x00000040
+#define GL_COMP_BIT_ATI                   0x00000002
+#define GL_NEGATE_BIT_ATI                 0x00000004
+#define GL_BIAS_BIT_ATI                   0x00000008
+#endif
+
+#ifndef GL_ATI_pn_triangles
+#define GL_PN_TRIANGLES_ATI               0x87F0
+#define GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI 0x87F1
+#define GL_PN_TRIANGLES_POINT_MODE_ATI    0x87F2
+#define GL_PN_TRIANGLES_NORMAL_MODE_ATI   0x87F3
+#define GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI 0x87F4
+#define GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI 0x87F5
+#define GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI 0x87F6
+#define GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI 0x87F7
+#define GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI 0x87F8
+#endif
+
+#ifndef GL_ATI_vertex_array_object
+#define GL_STATIC_ATI                     0x8760
+#define GL_DYNAMIC_ATI                    0x8761
+#define GL_PRESERVE_ATI                   0x8762
+#define GL_DISCARD_ATI                    0x8763
+#define GL_OBJECT_BUFFER_SIZE_ATI         0x8764
+#define GL_OBJECT_BUFFER_USAGE_ATI        0x8765
+#define GL_ARRAY_OBJECT_BUFFER_ATI        0x8766
+#define GL_ARRAY_OBJECT_OFFSET_ATI        0x8767
+#endif
+
+#ifndef GL_EXT_vertex_shader
+#define GL_VERTEX_SHADER_EXT              0x8780
+#define GL_VERTEX_SHADER_BINDING_EXT      0x8781
+#define GL_OP_INDEX_EXT                   0x8782
+#define GL_OP_NEGATE_EXT                  0x8783
+#define GL_OP_DOT3_EXT                    0x8784
+#define GL_OP_DOT4_EXT                    0x8785
+#define GL_OP_MUL_EXT                     0x8786
+#define GL_OP_ADD_EXT                     0x8787
+#define GL_OP_MADD_EXT                    0x8788
+#define GL_OP_FRAC_EXT                    0x8789
+#define GL_OP_MAX_EXT                     0x878A
+#define GL_OP_MIN_EXT                     0x878B
+#define GL_OP_SET_GE_EXT                  0x878C
+#define GL_OP_SET_LT_EXT                  0x878D
+#define GL_OP_CLAMP_EXT                   0x878E
+#define GL_OP_FLOOR_EXT                   0x878F
+#define GL_OP_ROUND_EXT                   0x8790
+#define GL_OP_EXP_BASE_2_EXT              0x8791
+#define GL_OP_LOG_BASE_2_EXT              0x8792
+#define GL_OP_POWER_EXT                   0x8793
+#define GL_OP_RECIP_EXT                   0x8794
+#define GL_OP_RECIP_SQRT_EXT              0x8795
+#define GL_OP_SUB_EXT                     0x8796
+#define GL_OP_CROSS_PRODUCT_EXT           0x8797
+#define GL_OP_MULTIPLY_MATRIX_EXT         0x8798
+#define GL_OP_MOV_EXT                     0x8799
+#define GL_OUTPUT_VERTEX_EXT              0x879A
+#define GL_OUTPUT_COLOR0_EXT              0x879B
+#define GL_OUTPUT_COLOR1_EXT              0x879C
+#define GL_OUTPUT_TEXTURE_COORD0_EXT      0x879D
+#define GL_OUTPUT_TEXTURE_COORD1_EXT      0x879E
+#define GL_OUTPUT_TEXTURE_COORD2_EXT      0x879F
+#define GL_OUTPUT_TEXTURE_COORD3_EXT      0x87A0
+#define GL_OUTPUT_TEXTURE_COORD4_EXT      0x87A1
+#define GL_OUTPUT_TEXTURE_COORD5_EXT      0x87A2
+#define GL_OUTPUT_TEXTURE_COORD6_EXT      0x87A3
+#define GL_OUTPUT_TEXTURE_COORD7_EXT      0x87A4
+#define GL_OUTPUT_TEXTURE_COORD8_EXT      0x87A5
+#define GL_OUTPUT_TEXTURE_COORD9_EXT      0x87A6
+#define GL_OUTPUT_TEXTURE_COORD10_EXT     0x87A7
+#define GL_OUTPUT_TEXTURE_COORD11_EXT     0x87A8
+#define GL_OUTPUT_TEXTURE_COORD12_EXT     0x87A9
+#define GL_OUTPUT_TEXTURE_COORD13_EXT     0x87AA
+#define GL_OUTPUT_TEXTURE_COORD14_EXT     0x87AB
+#define GL_OUTPUT_TEXTURE_COORD15_EXT     0x87AC
+#define GL_OUTPUT_TEXTURE_COORD16_EXT     0x87AD
+#define GL_OUTPUT_TEXTURE_COORD17_EXT     0x87AE
+#define GL_OUTPUT_TEXTURE_COORD18_EXT     0x87AF
+#define GL_OUTPUT_TEXTURE_COORD19_EXT     0x87B0
+#define GL_OUTPUT_TEXTURE_COORD20_EXT     0x87B1
+#define GL_OUTPUT_TEXTURE_COORD21_EXT     0x87B2
+#define GL_OUTPUT_TEXTURE_COORD22_EXT     0x87B3
+#define GL_OUTPUT_TEXTURE_COORD23_EXT     0x87B4
+#define GL_OUTPUT_TEXTURE_COORD24_EXT     0x87B5
+#define GL_OUTPUT_TEXTURE_COORD25_EXT     0x87B6
+#define GL_OUTPUT_TEXTURE_COORD26_EXT     0x87B7
+#define GL_OUTPUT_TEXTURE_COORD27_EXT     0x87B8
+#define GL_OUTPUT_TEXTURE_COORD28_EXT     0x87B9
+#define GL_OUTPUT_TEXTURE_COORD29_EXT     0x87BA
+#define GL_OUTPUT_TEXTURE_COORD30_EXT     0x87BB
+#define GL_OUTPUT_TEXTURE_COORD31_EXT     0x87BC
+#define GL_OUTPUT_FOG_EXT                 0x87BD
+#define GL_SCALAR_EXT                     0x87BE
+#define GL_VECTOR_EXT                     0x87BF
+#define GL_MATRIX_EXT                     0x87C0
+#define GL_VARIANT_EXT                    0x87C1
+#define GL_INVARIANT_EXT                  0x87C2
+#define GL_LOCAL_CONSTANT_EXT             0x87C3
+#define GL_LOCAL_EXT                      0x87C4
+#define GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87C5
+#define GL_MAX_VERTEX_SHADER_VARIANTS_EXT 0x87C6
+#define GL_MAX_VERTEX_SHADER_INVARIANTS_EXT 0x87C7
+#define GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87C8
+#define GL_MAX_VERTEX_SHADER_LOCALS_EXT   0x87C9
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87CA
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT 0x87CB
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87CC
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT 0x87CD
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT 0x87CE
+#define GL_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87CF
+#define GL_VERTEX_SHADER_VARIANTS_EXT     0x87D0
+#define GL_VERTEX_SHADER_INVARIANTS_EXT   0x87D1
+#define GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87D2
+#define GL_VERTEX_SHADER_LOCALS_EXT       0x87D3
+#define GL_VERTEX_SHADER_OPTIMIZED_EXT    0x87D4
+#define GL_X_EXT                          0x87D5
+#define GL_Y_EXT                          0x87D6
+#define GL_Z_EXT                          0x87D7
+#define GL_W_EXT                          0x87D8
+#define GL_NEGATIVE_X_EXT                 0x87D9
+#define GL_NEGATIVE_Y_EXT                 0x87DA
+#define GL_NEGATIVE_Z_EXT                 0x87DB
+#define GL_NEGATIVE_W_EXT                 0x87DC
+#define GL_ZERO_EXT                       0x87DD
+#define GL_ONE_EXT                        0x87DE
+#define GL_NEGATIVE_ONE_EXT               0x87DF
+#define GL_NORMALIZED_RANGE_EXT           0x87E0
+#define GL_FULL_RANGE_EXT                 0x87E1
+#define GL_CURRENT_VERTEX_EXT             0x87E2
+#define GL_MVP_MATRIX_EXT                 0x87E3
+#define GL_VARIANT_VALUE_EXT              0x87E4
+#define GL_VARIANT_DATATYPE_EXT           0x87E5
+#define GL_VARIANT_ARRAY_STRIDE_EXT       0x87E6
+#define GL_VARIANT_ARRAY_TYPE_EXT         0x87E7
+#define GL_VARIANT_ARRAY_EXT              0x87E8
+#define GL_VARIANT_ARRAY_POINTER_EXT      0x87E9
+#define GL_INVARIANT_VALUE_EXT            0x87EA
+#define GL_INVARIANT_DATATYPE_EXT         0x87EB
+#define GL_LOCAL_CONSTANT_VALUE_EXT       0x87EC
+#define GL_LOCAL_CONSTANT_DATATYPE_EXT    0x87ED
+#endif
+
+#ifndef GL_ATI_vertex_streams
+#define GL_MAX_VERTEX_STREAMS_ATI         0x876B
+#define GL_VERTEX_STREAM0_ATI             0x876C
+#define GL_VERTEX_STREAM1_ATI             0x876D
+#define GL_VERTEX_STREAM2_ATI             0x876E
+#define GL_VERTEX_STREAM3_ATI             0x876F
+#define GL_VERTEX_STREAM4_ATI             0x8770
+#define GL_VERTEX_STREAM5_ATI             0x8771
+#define GL_VERTEX_STREAM6_ATI             0x8772
+#define GL_VERTEX_STREAM7_ATI             0x8773
+#define GL_VERTEX_SOURCE_ATI              0x8774
+#endif
+
+#ifndef GL_ATI_element_array
+#define GL_ELEMENT_ARRAY_ATI              0x8768
+#define GL_ELEMENT_ARRAY_TYPE_ATI         0x8769
+#define GL_ELEMENT_ARRAY_POINTER_ATI      0x876A
+#endif
+
+#ifndef GL_SUN_mesh_array
+#define GL_QUAD_MESH_SUN                  0x8614
+#define GL_TRIANGLE_MESH_SUN              0x8615
+#endif
+
+#ifndef GL_SUN_slice_accum
+#define GL_SLICE_ACCUM_SUN                0x85CC
+#endif
+
+#ifndef GL_NV_multisample_filter_hint
+#define GL_MULTISAMPLE_FILTER_HINT_NV     0x8534
+#endif
+
+#ifndef GL_NV_depth_clamp
+#define GL_DEPTH_CLAMP_NV                 0x864F
+#endif
+
+#ifndef GL_NV_occlusion_query
+#define GL_PIXEL_COUNTER_BITS_NV          0x8864
+#define GL_CURRENT_OCCLUSION_QUERY_ID_NV  0x8865
+#define GL_PIXEL_COUNT_NV                 0x8866
+#define GL_PIXEL_COUNT_AVAILABLE_NV       0x8867
+#endif
+
+#ifndef GL_NV_point_sprite
+#define GL_POINT_SPRITE_NV                0x8861
+#define GL_COORD_REPLACE_NV               0x8862
+#define GL_POINT_SPRITE_R_MODE_NV         0x8863
+#endif
+
+#ifndef GL_NV_texture_shader3
+#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV 0x8850
+#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV 0x8851
+#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8852
+#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV 0x8853
+#define GL_OFFSET_HILO_TEXTURE_2D_NV      0x8854
+#define GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV 0x8855
+#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV 0x8856
+#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8857
+#define GL_DEPENDENT_HILO_TEXTURE_2D_NV   0x8858
+#define GL_DEPENDENT_RGB_TEXTURE_3D_NV    0x8859
+#define GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV 0x885A
+#define GL_DOT_PRODUCT_PASS_THROUGH_NV    0x885B
+#define GL_DOT_PRODUCT_TEXTURE_1D_NV      0x885C
+#define GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV 0x885D
+#define GL_HILO8_NV                       0x885E
+#define GL_SIGNED_HILO8_NV                0x885F
+#define GL_FORCE_BLUE_TO_ONE_NV           0x8860
+#endif
+
+#ifndef GL_NV_vertex_program1_1
+#endif
+
+#ifndef GL_EXT_shadow_funcs
+#endif
+
+#ifndef GL_EXT_stencil_two_side
+#define GL_STENCIL_TEST_TWO_SIDE_EXT      0x8910
+#define GL_ACTIVE_STENCIL_FACE_EXT        0x8911
+#endif
+
+#ifndef GL_ATI_text_fragment_shader
+#define GL_TEXT_FRAGMENT_SHADER_ATI       0x8200
+#endif
+
+#ifndef GL_APPLE_client_storage
+#define GL_UNPACK_CLIENT_STORAGE_APPLE    0x85B2
+#endif
+
+#ifndef GL_APPLE_element_array
+#define GL_ELEMENT_ARRAY_APPLE            0x8768
+#define GL_ELEMENT_ARRAY_TYPE_APPLE       0x8769
+#define GL_ELEMENT_ARRAY_POINTER_APPLE    0x876A
+#endif
+
+#ifndef GL_APPLE_fence
+#define GL_DRAW_PIXELS_APPLE              0x8A0A
+#define GL_FENCE_APPLE                    0x8A0B
+#endif
+
+#ifndef GL_APPLE_vertex_array_object
+#define GL_VERTEX_ARRAY_BINDING_APPLE     0x85B5
+#endif
+
+#ifndef GL_APPLE_vertex_array_range
+#define GL_VERTEX_ARRAY_RANGE_APPLE       0x851D
+#define GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE 0x851E
+#define GL_VERTEX_ARRAY_STORAGE_HINT_APPLE 0x851F
+#define GL_VERTEX_ARRAY_RANGE_POINTER_APPLE 0x8521
+#define GL_STORAGE_CACHED_APPLE           0x85BE
+#define GL_STORAGE_SHARED_APPLE           0x85BF
+#endif
+
+#ifndef GL_APPLE_ycbcr_422
+#define GL_YCBCR_422_APPLE                0x85B9
+#define GL_UNSIGNED_SHORT_8_8_APPLE       0x85BA
+#define GL_UNSIGNED_SHORT_8_8_REV_APPLE   0x85BB
+#endif
+
+#ifndef GL_S3_s3tc
+#define GL_RGB_S3TC                       0x83A0
+#define GL_RGB4_S3TC                      0x83A1
+#define GL_RGBA_S3TC                      0x83A2
+#define GL_RGBA4_S3TC                     0x83A3
+#endif
+
+#ifndef GL_ATI_draw_buffers
+#define GL_MAX_DRAW_BUFFERS_ATI           0x8824
+#define GL_DRAW_BUFFER0_ATI               0x8825
+#define GL_DRAW_BUFFER1_ATI               0x8826
+#define GL_DRAW_BUFFER2_ATI               0x8827
+#define GL_DRAW_BUFFER3_ATI               0x8828
+#define GL_DRAW_BUFFER4_ATI               0x8829
+#define GL_DRAW_BUFFER5_ATI               0x882A
+#define GL_DRAW_BUFFER6_ATI               0x882B
+#define GL_DRAW_BUFFER7_ATI               0x882C
+#define GL_DRAW_BUFFER8_ATI               0x882D
+#define GL_DRAW_BUFFER9_ATI               0x882E
+#define GL_DRAW_BUFFER10_ATI              0x882F
+#define GL_DRAW_BUFFER11_ATI              0x8830
+#define GL_DRAW_BUFFER12_ATI              0x8831
+#define GL_DRAW_BUFFER13_ATI              0x8832
+#define GL_DRAW_BUFFER14_ATI              0x8833
+#define GL_DRAW_BUFFER15_ATI              0x8834
+#endif
+
+#ifndef GL_ATI_pixel_format_float
+#define GL_TYPE_RGBA_FLOAT_ATI            0x8820
+#define GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI 0x8835
+#endif
+
+#ifndef GL_ATI_texture_env_combine3
+#define GL_MODULATE_ADD_ATI               0x8744
+#define GL_MODULATE_SIGNED_ADD_ATI        0x8745
+#define GL_MODULATE_SUBTRACT_ATI          0x8746
+#endif
+
+#ifndef GL_ATI_texture_float
+#define GL_RGBA_FLOAT32_ATI               0x8814
+#define GL_RGB_FLOAT32_ATI                0x8815
+#define GL_ALPHA_FLOAT32_ATI              0x8816
+#define GL_INTENSITY_FLOAT32_ATI          0x8817
+#define GL_LUMINANCE_FLOAT32_ATI          0x8818
+#define GL_LUMINANCE_ALPHA_FLOAT32_ATI    0x8819
+#define GL_RGBA_FLOAT16_ATI               0x881A
+#define GL_RGB_FLOAT16_ATI                0x881B
+#define GL_ALPHA_FLOAT16_ATI              0x881C
+#define GL_INTENSITY_FLOAT16_ATI          0x881D
+#define GL_LUMINANCE_FLOAT16_ATI          0x881E
+#define GL_LUMINANCE_ALPHA_FLOAT16_ATI    0x881F
+#endif
+
+#ifndef GL_NV_float_buffer
+#define GL_FLOAT_R_NV                     0x8880
+#define GL_FLOAT_RG_NV                    0x8881
+#define GL_FLOAT_RGB_NV                   0x8882
+#define GL_FLOAT_RGBA_NV                  0x8883
+#define GL_FLOAT_R16_NV                   0x8884
+#define GL_FLOAT_R32_NV                   0x8885
+#define GL_FLOAT_RG16_NV                  0x8886
+#define GL_FLOAT_RG32_NV                  0x8887
+#define GL_FLOAT_RGB16_NV                 0x8888
+#define GL_FLOAT_RGB32_NV                 0x8889
+#define GL_FLOAT_RGBA16_NV                0x888A
+#define GL_FLOAT_RGBA32_NV                0x888B
+#define GL_TEXTURE_FLOAT_COMPONENTS_NV    0x888C
+#define GL_FLOAT_CLEAR_COLOR_VALUE_NV     0x888D
+#define GL_FLOAT_RGBA_MODE_NV             0x888E
+#endif
+
+#ifndef GL_NV_fragment_program
+#define GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV 0x8868
+#define GL_FRAGMENT_PROGRAM_NV            0x8870
+#define GL_MAX_TEXTURE_COORDS_NV          0x8871
+#define GL_MAX_TEXTURE_IMAGE_UNITS_NV     0x8872
+#define GL_FRAGMENT_PROGRAM_BINDING_NV    0x8873
+#define GL_PROGRAM_ERROR_STRING_NV        0x8874
+#endif
+
+#ifndef GL_NV_half_float
+#define GL_HALF_FLOAT_NV                  0x140B
+#endif
+
+#ifndef GL_NV_pixel_data_range
+#define GL_WRITE_PIXEL_DATA_RANGE_NV      0x8878
+#define GL_READ_PIXEL_DATA_RANGE_NV       0x8879
+#define GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV 0x887A
+#define GL_READ_PIXEL_DATA_RANGE_LENGTH_NV 0x887B
+#define GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV 0x887C
+#define GL_READ_PIXEL_DATA_RANGE_POINTER_NV 0x887D
+#endif
+
+#ifndef GL_NV_primitive_restart
+#define GL_PRIMITIVE_RESTART_NV           0x8558
+#define GL_PRIMITIVE_RESTART_INDEX_NV     0x8559
+#endif
+
+#ifndef GL_NV_texture_expand_normal
+#define GL_TEXTURE_UNSIGNED_REMAP_MODE_NV 0x888F
+#endif
+
+#ifndef GL_NV_vertex_program2
+#endif
+
+#ifndef GL_ATI_map_object_buffer
+#endif
+
+#ifndef GL_ATI_separate_stencil
+#define GL_STENCIL_BACK_FUNC_ATI          0x8800
+#define GL_STENCIL_BACK_FAIL_ATI          0x8801
+#define GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI 0x8802
+#define GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI 0x8803
+#endif
+
+#ifndef GL_ATI_vertex_attrib_array_object
+#endif
+
+#ifndef GL_OES_read_format
+#define GL_IMPLEMENTATION_COLOR_READ_TYPE_OES 0x8B9A
+#define GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES 0x8B9B
+#endif
+
+#ifndef GL_EXT_depth_bounds_test
+#define GL_DEPTH_BOUNDS_TEST_EXT          0x8890
+#define GL_DEPTH_BOUNDS_EXT               0x8891
+#endif
+
+#ifndef GL_EXT_texture_mirror_clamp
+#define GL_MIRROR_CLAMP_EXT               0x8742
+#define GL_MIRROR_CLAMP_TO_EDGE_EXT       0x8743
+#define GL_MIRROR_CLAMP_TO_BORDER_EXT     0x8912
+#endif
+
+#ifndef GL_EXT_blend_equation_separate
+#define GL_BLEND_EQUATION_RGB_EXT         GL_BLEND_EQUATION
+#define GL_BLEND_EQUATION_ALPHA_EXT       0x883D
+#endif
+
+#ifndef GL_MESA_pack_invert
+#define GL_PACK_INVERT_MESA               0x8758
+#endif
+
+#ifndef GL_MESA_ycbcr_texture
+#define GL_UNSIGNED_SHORT_8_8_MESA        0x85BA
+#define GL_UNSIGNED_SHORT_8_8_REV_MESA    0x85BB
+#define GL_YCBCR_MESA                     0x8757
+#endif
+
+#ifndef GL_EXT_pixel_buffer_object
+#define GL_PIXEL_PACK_BUFFER_EXT          0x88EB
+#define GL_PIXEL_UNPACK_BUFFER_EXT        0x88EC
+#define GL_PIXEL_PACK_BUFFER_BINDING_EXT  0x88ED
+#define GL_PIXEL_UNPACK_BUFFER_BINDING_EXT 0x88EF
+#endif
+
+#ifndef GL_NV_fragment_program_option
+#endif
+
+#ifndef GL_NV_fragment_program2
+#define GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV 0x88F4
+#define GL_MAX_PROGRAM_CALL_DEPTH_NV      0x88F5
+#define GL_MAX_PROGRAM_IF_DEPTH_NV        0x88F6
+#define GL_MAX_PROGRAM_LOOP_DEPTH_NV      0x88F7
+#define GL_MAX_PROGRAM_LOOP_COUNT_NV      0x88F8
+#endif
+
+#ifndef GL_NV_vertex_program2_option
+/* reuse GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV */
+/* reuse GL_MAX_PROGRAM_CALL_DEPTH_NV */
+#endif
+
+#ifndef GL_NV_vertex_program3
+/* reuse GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB */
+#endif
+
+#ifndef GL_EXT_framebuffer_object
+#define GL_INVALID_FRAMEBUFFER_OPERATION_EXT 0x0506
+#define GL_MAX_RENDERBUFFER_SIZE_EXT      0x84E8
+#define GL_FRAMEBUFFER_BINDING_EXT        0x8CA6
+#define GL_RENDERBUFFER_BINDING_EXT       0x8CA7
+#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT 0x8CD0
+#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT 0x8CD1
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT 0x8CD2
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT 0x8CD3
+#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT 0x8CD4
+#define GL_FRAMEBUFFER_COMPLETE_EXT       0x8CD5
+#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT 0x8CD6
+#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT 0x8CD7
+#define GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT_EXT 0x8CD8
+#define GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT 0x8CD9
+#define GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT 0x8CDA
+#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT 0x8CDB
+#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT 0x8CDC
+#define GL_FRAMEBUFFER_UNSUPPORTED_EXT    0x8CDD
+#define GL_MAX_COLOR_ATTACHMENTS_EXT      0x8CDF
+#define GL_COLOR_ATTACHMENT0_EXT          0x8CE0
+#define GL_COLOR_ATTACHMENT1_EXT          0x8CE1
+#define GL_COLOR_ATTACHMENT2_EXT          0x8CE2
+#define GL_COLOR_ATTACHMENT3_EXT          0x8CE3
+#define GL_COLOR_ATTACHMENT4_EXT          0x8CE4
+#define GL_COLOR_ATTACHMENT5_EXT          0x8CE5
+#define GL_COLOR_ATTACHMENT6_EXT          0x8CE6
+#define GL_COLOR_ATTACHMENT7_EXT          0x8CE7
+#define GL_COLOR_ATTACHMENT8_EXT          0x8CE8
+#define GL_COLOR_ATTACHMENT9_EXT          0x8CE9
+#define GL_COLOR_ATTACHMENT10_EXT         0x8CEA
+#define GL_COLOR_ATTACHMENT11_EXT         0x8CEB
+#define GL_COLOR_ATTACHMENT12_EXT         0x8CEC
+#define GL_COLOR_ATTACHMENT13_EXT         0x8CED
+#define GL_COLOR_ATTACHMENT14_EXT         0x8CEE
+#define GL_COLOR_ATTACHMENT15_EXT         0x8CEF
+#define GL_DEPTH_ATTACHMENT_EXT           0x8D00
+#define GL_STENCIL_ATTACHMENT_EXT         0x8D20
+#define GL_FRAMEBUFFER_EXT                0x8D40
+#define GL_RENDERBUFFER_EXT               0x8D41
+#define GL_RENDERBUFFER_WIDTH_EXT         0x8D42
+#define GL_RENDERBUFFER_HEIGHT_EXT        0x8D43
+#define GL_RENDERBUFFER_INTERNAL_FORMAT_EXT 0x8D44
+#define GL_STENCIL_INDEX1_EXT             0x8D46
+#define GL_STENCIL_INDEX4_EXT             0x8D47
+#define GL_STENCIL_INDEX8_EXT             0x8D48
+#define GL_STENCIL_INDEX16_EXT            0x8D49
+#define GL_RENDERBUFFER_RED_SIZE_EXT      0x8D50
+#define GL_RENDERBUFFER_GREEN_SIZE_EXT    0x8D51
+#define GL_RENDERBUFFER_BLUE_SIZE_EXT     0x8D52
+#define GL_RENDERBUFFER_ALPHA_SIZE_EXT    0x8D53
+#define GL_RENDERBUFFER_DEPTH_SIZE_EXT    0x8D54
+#define GL_RENDERBUFFER_STENCIL_SIZE_EXT  0x8D55
+#endif
+
 #endif
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_backend.c bumpy-code/code/renderer/tr_backend.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_backend.c	2014-06-09 22:09:45.526844462 -0400
+++ bumpy-code/code/renderer/tr_backend.c	2014-06-09 22:14:52.594548735 -0400
@@ -24,6 +24,7 @@
 backEndData_t	*backEndData[SMP_FRAMES];
 backEndState_t	backEnd;
 
+int	EndSurfaceCount=0;
 
 static float	s_flipMatrix[16] = {
 	// convert from our coordinate system (looking down X)
@@ -40,6 +40,30 @@
 */
 void GL_Bind( image_t *image ) {
 	int texnum;
+	image_t *img;
+
+	if ( !image ) {
+		ri.Printf( PRINT_WARNING, "GL_Bind: NULL image\n" );
+		img = tr.defaultImage;
+	} else {
+		img = image;
+	}
+	texnum = img->texnum;
+
+	if ( r_nobind->integer && tr.dlightImage ) {		// performance evaluation option
+		texnum = tr.dlightImage->texnum;
+	}
+
+	if ( glState.currenttextures[glState.currenttmu] != texnum ) {
+		img->frameUsed = tr.frameCount;
+		glState.currenttextures[glState.currenttmu] = texnum;
+		qglBindTexture (GL_TEXTURE_2D, texnum);
+	}
+}
+
+void GL_BindCube( image_t *image ) 
+{
+	int texnum;
 
 	if ( !image ) {
 		ri.Printf( PRINT_WARNING, "GL_Bind: NULL image\n" );
@@ -53,8 +77,31 @@
 	}
 
 	if ( glState.currenttextures[glState.currenttmu] != texnum ) {
+
 		image->frameUsed = tr.frameCount;
 		glState.currenttextures[glState.currenttmu] = texnum;
+		qglBindTexture (GL_TEXTURE_CUBE_MAP, texnum);
+	}
+}
+
+
+void GL_BindCubeTexnum( int texnum ) 
+{
+
+	if ( glState.currenttextures[glState.currenttmu] != texnum ) 
+	{
+		glState.currenttextures[glState.currenttmu] = texnum;
+		qglBindTexture (GL_TEXTURE_CUBE_MAP, texnum);
+	}
+}
+
+
+void GL_BindTexnum( int texnum ) 
+{
+
+	if ( glState.currenttextures[glState.currenttmu] != texnum ) 
+	{
+		glState.currenttextures[glState.currenttmu] = texnum;
 		qglBindTexture (GL_TEXTURE_2D, texnum);
 	}
 }
@@ -82,7 +130,85 @@
 		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE1_ARB )\n" );
 		qglClientActiveTextureARB( GL_TEXTURE1_ARB );
 		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE1_ARB )\n" );
-	} else {
+	}
+	else if ( unit == 2 )
+	{
+		qglActiveTextureARB( GL_TEXTURE2_ARB );
+		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE2_ARB )\n" );
+		qglClientActiveTextureARB( GL_TEXTURE2_ARB );
+		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE2_ARB )\n" );
+	} 
+	else if ( unit == 3 )
+	{
+		qglActiveTextureARB( GL_TEXTURE3_ARB );
+		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE3_ARB )\n" );
+		qglClientActiveTextureARB( GL_TEXTURE3_ARB );
+		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE3_ARB )\n" );
+	} 
+	else if ( unit == 4 )
+	{
+		qglActiveTextureARB( GL_TEXTURE4_ARB );
+		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE4_ARB )\n" );
+		qglClientActiveTextureARB( GL_TEXTURE4_ARB );
+		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE4_ARB )\n" );
+	} 
+	else if ( unit == 5 )
+	{
+		qglActiveTextureARB( GL_TEXTURE5_ARB );
+		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE5_ARB )\n" );
+		qglClientActiveTextureARB( GL_TEXTURE5_ARB );
+		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE5_ARB )\n" );
+	} 
+	else if ( unit == 6 )
+	{
+		qglActiveTextureARB( GL_TEXTURE6_ARB );
+		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE6_ARB )\n" );
+		qglClientActiveTextureARB( GL_TEXTURE6_ARB );
+		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE6_ARB )\n" );
+	} 
+	else if ( unit == 7 )
+	{
+		qglActiveTextureARB( GL_TEXTURE7_ARB );
+		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE7_ARB )\n" );
+		qglClientActiveTextureARB( GL_TEXTURE7_ARB );
+		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE7_ARB )\n" );
+	} 
+	else if ( unit == 8 )
+	{
+		qglActiveTextureARB( GL_TEXTURE8_ARB );
+		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE8_ARB )\n" );
+		qglClientActiveTextureARB( GL_TEXTURE8_ARB );
+		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE8_ARB )\n" );
+	} 
+	else if ( unit == 9 )
+	{
+		qglActiveTextureARB( GL_TEXTURE9_ARB );
+		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE9_ARB )\n" );
+		qglClientActiveTextureARB( GL_TEXTURE9_ARB );
+		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE9_ARB )\n" );
+	} 
+	else if ( unit == 10)
+	{
+		qglActiveTextureARB( GL_TEXTURE10_ARB );
+		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE10_ARB )\n" );
+		qglClientActiveTextureARB( GL_TEXTURE10_ARB );
+		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE10_ARB )\n" );
+	} 
+	else if ( unit == 11 )
+	{
+		qglActiveTextureARB( GL_TEXTURE11_ARB );
+		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE11_ARB )\n" );
+		qglClientActiveTextureARB( GL_TEXTURE11_ARB );
+		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE11_ARB )\n" );
+	} 
+	else if ( unit == 12 )
+	{
+		qglActiveTextureARB( GL_TEXTURE12_ARB );
+		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE12_ARB )\n" );
+		qglClientActiveTextureARB( GL_TEXTURE12_ARB );
+		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE12_ARB )\n" );
+	} 
+	else {
 		ri.Error( ERR_DROP, "GL_SelectTexture: unit = %i", unit );
 	}
 
@@ -118,6 +244,203 @@
 }
 
 
+
+void RB_SetupFragment( fragShader_t* frag, shader_t* shader )
+{
+	int uniform_location;
+	vec3_t forward;
+	int j=0;
+	
+	if (glState.currentFragShader==frag)
+		return;
+	
+	//We're going back to standard rendering now
+	//if (frag==NULL )
+	{
+		qglUseProgramObjectARB( 0 );
+		GL_UnBindVBO( );
+		
+		//turn off all texture units
+		for (j=1;j<13;j++)
+		{
+			GL_SelectTexture(j);
+			qglDisable( GL_TEXTURE_2D );
+			qglDisable( GL_TEXTURE_CUBE_MAP );
+			qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
+		}
+		GL_SelectTexture( 0 );	
+
+		glState.currentFragShader=frag;
+
+		if (frag==NULL ) return;
+	}
+
+	glState.currentFragShader=frag;
+	
+	//ENABLE A FRAGSHADER
+	GL_BindVBO(frag->vertexType);
+	qglUseProgramObjectARB(frag->program);
+
+	if (backEnd.viewParms.isMirror==qfalse)
+	{
+		uniform_location = qglGetUniformLocationARB(frag->program, "IN_eye_pos");
+		qglUniform3fARB(uniform_location, backEnd.refdef.vieworg[0],backEnd.refdef.vieworg[1],backEnd.refdef.vieworg[2]);
+		uniform_location = qglGetUniformLocationARB(frag->program, "IN_eye_vec");
+		VectorCopy( backEnd.refdef.viewaxis[0], forward );
+		qglUniform3fARB(uniform_location, forward[0],forward[1],forward[2]);
+	}
+	else
+	{
+		uniform_location = qglGetUniformLocationARB(frag->program, "IN_eye_pos");
+		qglUniform3fARB(uniform_location, backEnd.refdef.vieworg[0],backEnd.refdef.vieworg[1],backEnd.refdef.vieworg[2]);
+		uniform_location = qglGetUniformLocationARB(frag->program, "IN_eye_vec");
+		VectorCopy( backEnd.or.axis[0], forward );
+		qglUniform3fARB(uniform_location, forward[0],forward[1],forward[2]);
+
+	}
+	
+
+	//set the time for the animation
+	uniform_location = qglGetUniformLocationARB(frag->program, "time");
+	if (uniform_location>-1) qglUniform1fARB(uniform_location, backEnd.refdef.floatTime);
+	
+	//turn all the deforms off
+	uniform_location = qglGetUniformLocationARB(frag->program, "IN_deformtype");
+	if (uniform_location>-1) qglUniform1fARB(uniform_location, 0);
+
+
+
+	if (shader!=NULL)
+	{
+		//set the tiling
+		uniform_location = qglGetUniformLocationARB(frag->program, "scale");
+		if (uniform_location>-1) qglUniform1fARB(uniform_location,shader->scale );
+	
+		//set the refraction tint
+		uniform_location = qglGetUniformLocationARB(frag->program, "undertint");
+		if (uniform_location>-1) qglUniform3fARB(uniform_location,1,1,1);
+			
+		//overtint
+		uniform_location = qglGetUniformLocationARB(frag->program, "tint");
+		if (uniform_location>-1) qglUniform3fARB(uniform_location,shader->tint[0],shader->tint[1],shader->tint[2]);
+	}
+
+
+	if (backEnd.viewParms.isUnderwater)
+	{
+		//set the flip 		
+		uniform_location = qglGetUniformLocationARB(frag->program, "flip");		
+		if (uniform_location>-1) qglUniform1fARB(uniform_location,-1 );
+	}
+	else
+	{
+		uniform_location = qglGetUniformLocationARB(frag->program, "flip");		
+		if (uniform_location>-1) qglUniform1fARB(uniform_location,1 );
+
+	}
+
+	
+}
+
+void GL_BindVBO(int VBOMode)
+{
+	int oldMode=glState.VBOBound;
+
+	fragShader_t* frag=glState.currentFragShader;
+
+	//Unbind the vbo
+	if (glState.VBOBound!=VBOMode)
+	{
+		qglBindBufferARB(GL_ARRAY_BUFFER_ARB, 0);
+		qglBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
+		
+
+		if (glState.VBOBound==1)
+		{
+			//disable static vertexes		
+			qglDisableVertexAttribArrayARB(glState.currentFragShader->position_i);
+			qglDisableVertexAttribArrayARB(glState.currentFragShader->uv_i);
+			qglDisableVertexAttribArrayARB(glState.currentFragShader->light_uv_i);
+			qglDisableVertexAttribArrayARB(glState.currentFragShader->normal_i);
+			qglDisableVertexAttribArrayARB(glState.currentFragShader->stv_i);
+			qglDisableVertexAttribArrayARB(glState.currentFragShader->ttv_i);
+			qglDisableVertexAttribArrayARB(glState.currentFragShader->rgba_i);
+		}
+
+		/*if (glState.VBOBound==2)
+		{
+			qglDisableVertexAttribArrayARB(frag->position_i);
+			qglDisableVertexAttribArrayARB(frag->uv_i);
+			qglDisableVertexAttribArrayARB(frag->normal_i);
+			qglDisableVertexAttribArrayARB(frag->stv_i);
+			qglDisableVertexAttribArrayARB(frag->ttv_i);
+			qglDisableVertexAttribArrayARB(frag->rgba_i);
+			qglDisableVertexAttribArrayARB(frag->boneindexs_i);
+			qglDisableVertexAttribArrayARB(frag->boneweights_i);
+			qglDisableVertexAttribArrayARB(frag->pos0_i);
+			qglDisableVertexAttribArrayARB(frag->pos1_i);
+			qglDisableVertexAttribArrayARB(frag->pos2_i);
+			qglDisableVertexAttribArrayARB(frag->norm0_i);
+			qglDisableVertexAttribArrayARB(frag->norm1_i);
+			qglDisableVertexAttribArrayARB(frag->norm2_i);
+			qglDisableVertexAttribArrayARB(frag->tangent0_i);
+			qglDisableVertexAttribArrayARB(frag->tangent1_i);
+			qglDisableVertexAttribArrayARB(frag->tangent1_i);
+			qglDisableVertexAttribArrayARB(frag->bitangent0_i);
+			qglDisableVertexAttribArrayARB(frag->bitangent1_i);
+			qglDisableVertexAttribArrayARB(frag->bitangent2_i);
+		}*/
+		
+		glState.VBOBound=0;
+		if (VBOMode==0) return;
+	}
+
+	//bind the new vbo
+	glState.VBOBound=VBOMode;
+
+	if (glState.VBOBound==1) //Static vbo mode
+	{
+		qglBindBufferARB(GL_ARRAY_BUFFER_ARB, tr.VBO_vertexBuffer);
+		qglBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, tr.VBO_indexBuffer);
+
+		qglVertexPointer(3,GL_FLOAT,sizeof(staticVert_t),GEOMETRY_VERTEX_OFFSET(0, staticVert_t, position ));
+		qglTexCoordPointer(2,GL_FLOAT,sizeof(staticVert_t),GEOMETRY_VERTEX_OFFSET(0, staticVert_t, uv ));
+		qglTexCoordPointer(2,GL_FLOAT,sizeof(staticVert_t),GEOMETRY_VERTEX_OFFSET(0, staticVert_t, light_uv ));
+
+		qglEnableVertexAttribArrayARB(frag->position_i);
+		qglEnableVertexAttribArrayARB(frag->uv_i);
+		qglEnableVertexAttribArrayARB(frag->light_uv_i);
+		qglEnableVertexAttribArrayARB(frag->normal_i);
+		qglEnableVertexAttribArrayARB(frag->stv_i);
+		qglEnableVertexAttribArrayARB(frag->ttv_i);
+		qglEnableVertexAttribArrayARB(frag->rgba_i);
+
+		qglVertexAttribPointerARB(frag->position_i, 3, GL_FLOAT, GL_FALSE, sizeof(staticVert_t), GEOMETRY_VERTEX_OFFSET(0, staticVert_t, position ));
+		qglVertexAttribPointerARB(frag->uv_i, 2, GL_FLOAT, GL_FALSE, sizeof(staticVert_t), GEOMETRY_VERTEX_OFFSET(0, staticVert_t, uv ));		
+		qglVertexAttribPointerARB(frag->light_uv_i, 2, GL_FLOAT, GL_FALSE, sizeof(staticVert_t), GEOMETRY_VERTEX_OFFSET(0, staticVert_t, light_uv ));
+		qglVertexAttribPointerARB(frag->normal_i, 3, GL_FLOAT, GL_FALSE, sizeof(staticVert_t), GEOMETRY_VERTEX_OFFSET(0, staticVert_t, normal ));
+		qglVertexAttribPointerARB(frag->stv_i, 3, GL_FLOAT, GL_FALSE, sizeof(staticVert_t), GEOMETRY_VERTEX_OFFSET(0, staticVert_t, stv ));
+		qglVertexAttribPointerARB(frag->ttv_i, 3, GL_FLOAT, GL_FALSE, sizeof(staticVert_t), GEOMETRY_VERTEX_OFFSET(0, staticVert_t, ttv ));
+		qglVertexAttribPointerARB(frag->rgba_i, 4, GL_FLOAT, GL_FALSE, sizeof(staticVert_t), GEOMETRY_VERTEX_OFFSET(0, staticVert_t, rgba ));
+
+		qglEnableClientState(GL_VERTEX_ARRAY);
+		qglDisableClientState(GL_TEXTURE_COORD_ARRAY);
+		qglDisableClientState(GL_COLOR_ARRAY);
+
+	}
+	// other model formats go here, like hardware accelerated md5...
+}
+
+void GL_UnBindVBO()
+{
+	GL_BindVBO(0);
+	
+
+}
+
+
+
+
 /*
 ** GL_Cull
 */
@@ -468,6 +791,28 @@
 		qglClearColor( 0.0f, 0.0f, 0.0f, 1.0f );	// FIXME: get color of sky
 #endif
 	}
+		
+	
+	if (r_ext_vertex_buffer_object->integer && backEnd.viewParms.doWater )
+	{
+		clearBits |= GL_COLOR_BUFFER_BIT;
+		qglClearColor( 0, 0, 0, 1.0f );
+	}
+
+	//clear the backbuffer each target render
+	if (backEnd.refdef.pixelTarget!=NULL)
+	{
+		clearBits |= GL_COLOR_BUFFER_BIT;	
+		qglClearColor( 0.0f, 0.0f, 0.0f, 1.0f );	// FIXME: get color of sky
+	}
+
+
+	if (backEnd.refdef.rdflags & RDF_NOCLEAR)
+	{
+		clearBits=0;
+		clearBits=GL_COLOR_BUFFER_BIT;
+	}
+
 	qglClear( clearBits );
 
 	if ( ( backEnd.refdef.rdflags & RDF_HYPERSPACE ) )
@@ -506,6 +851,63 @@
 	} else {
 		qglDisable (GL_CLIP_PLANE0);
 	}
+
+
+	// clip to the plane of the water, only show whats underneath
+	if ( backEnd.viewParms.isWater==1 || backEnd.viewParms.isWater==2 ) 
+	{
+		vec4_t plane;
+		float bias=8.0f;
+	
+		plane[0]=backEnd.viewParms.waterPlane.normal[0];
+		plane[1]=backEnd.viewParms.waterPlane.normal[1];
+		plane[2]=backEnd.viewParms.waterPlane.normal[2];
+		plane[3]=backEnd.viewParms.waterPlane.dist; //fudge it 1 unit to clean up the edge cuts
+
+		//we're underwater  so flip
+		if (backEnd.viewParms.isUnderwater) 
+		{
+			plane[0]=-plane[0];
+			plane[1]=-plane[1];
+			plane[2]=-plane[2];
+			plane[3]=-plane[3];
+		}
+
+		if (backEnd.viewParms.isWater==1)
+		{
+			double f[4];
+			f[0]=plane[0];
+			f[1]=plane[1];
+			f[2]=plane[2];
+			f[3]=plane[3]+bias;
+
+			qglLoadMatrixf(backEnd.viewParms.world.modelMatrix );
+			qglClipPlane (GL_CLIP_PLANE1, f);
+			qglEnable (GL_CLIP_PLANE1);
+		}
+
+		if (backEnd.viewParms.isWater==2)
+		{
+			double f[4];
+			f[0]=-plane[0];
+			f[1]=-plane[1];
+			f[2]=-plane[2];
+			f[3]=-plane[3]+bias;
+
+			qglLoadMatrixf(backEnd.viewParms.world.modelMatrix );
+			qglClipPlane (GL_CLIP_PLANE1, f);
+			qglEnable (GL_CLIP_PLANE1);
+		}
+	}
+	else
+	{
+		qglDisable(GL_CLIP_PLANE1);
+		
+	}
+	
+	GL_Cull( CT_FRONT_SIDED );
+	
+	
 }
 
 
@@ -521,9 +923,10 @@
 	int				fogNum, oldFogNum;
 	int				entityNum, oldEntityNum;
 	int				dlighted, oldDlighted;
-	qboolean		depthRange, oldDepthRange;
+	qboolean		depthRange, oldDepthRange, isCrosshair, wasCrosshair;
 	int				i;
 	drawSurf_t		*drawSurf;
+	int			oldSurf;
 	int				oldSort;
 	float			originalTime;
 
@@ -539,14 +942,20 @@
 	oldShader = NULL;
 	oldFogNum = -1;
 	oldDepthRange = qfalse;
+	wasCrosshair = qfalse;
 	oldDlighted = qfalse;
 	oldSort = -1;
+	oldSurf = -1;
+	
 	depthRange = qfalse;
 
 	backEnd.pc.c_surfaces += numDrawSurfs;
 
-	for (i = 0, drawSurf = drawSurfs ; i < numDrawSurfs ; i++, drawSurf++) {
-		if ( drawSurf->sort == oldSort ) {
+	for (i = 0, drawSurf = drawSurfs ; i < numDrawSurfs ; i++, drawSurf++)
+	{
+
+		if (drawSurf->sort == oldSort )  
+		{
 			// fast path, same as previous sort
 			rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
 			continue;
@@ -567,13 +978,14 @@
 			oldShader = shader;
 			oldFogNum = fogNum;
 			oldDlighted = dlighted;
+			oldSurf   = *drawSurf->surface;
 		}
 
 		//
 		// change the modelview matrix if needed
 		//
 		if ( entityNum != oldEntityNum ) {
-			depthRange = qfalse;
+			depthRange = isCrosshair = qfalse;
 
 			if ( entityNum != ENTITYNUM_WORLD ) {
 				backEnd.currentEntity = &backEnd.refdef.entities[entityNum];
@@ -590,9 +1002,13 @@
 					R_TransformDlights( backEnd.refdef.num_dlights, backEnd.refdef.dlights, &backEnd.or );
 				}
 
-				if ( backEnd.currentEntity->e.renderfx & RF_DEPTHHACK ) {
+				if ( backEnd.currentEntity->e.renderfx & RF_DEPTHHACK )
+				{
 					// hack the depth range to prevent view model from poking into walls
 					depthRange = qtrue;
+					
+					if(backEnd.currentEntity->e.renderfx & RF_CROSSHAIR)
+						isCrosshair = qtrue;
 				}
 			} else {
 				backEnd.currentEntity = &tr.worldEntity;
@@ -607,15 +1023,54 @@
 			qglLoadMatrixf( backEnd.or.modelMatrix );
 
 			//
-			// change depthrange if needed
+			// change depthrange. Also change projection matrix so first person weapon does not look like coming
+			// out of the screen.
 			//
-			if ( oldDepthRange != depthRange ) {
-				if ( depthRange ) {
+			if ( oldDepthRange != depthRange || wasCrosshair != isCrosshair )
+			{
+				if ( depthRange )
+				{
+					if ( backEnd.viewParms.stereoFrame != STEREO_CENTER )
+					{
+						if ( isCrosshair )
+						{
+							if ( oldDepthRange )
+							{
+								// was not a crosshair but now is, change back proj matrix
+								qglMatrixMode(GL_PROJECTION);
+								qglLoadMatrixf(backEnd.viewParms.projectionMatrix);
+								qglMatrixMode(GL_MODELVIEW);
+							}
+						}
+						else
+						{
+							viewParms_t temp = backEnd.viewParms;
+
+							R_SetupProjection(&temp, r_znear->value, qfalse);
+
+							qglMatrixMode(GL_PROJECTION);
+							qglLoadMatrixf(temp.projectionMatrix);
+							qglMatrixMode(GL_MODELVIEW);
+						}
+					}
+
+					if(!oldDepthRange)
 					qglDepthRange (0, 0.3);
-				} else {
+				}
+				else
+				{
+					if ( !wasCrosshair && backEnd.viewParms.stereoFrame != STEREO_CENTER )
+					{
+						qglMatrixMode(GL_PROJECTION);
+						qglLoadMatrixf(backEnd.viewParms.projectionMatrix);
+						qglMatrixMode(GL_MODELVIEW);
+					}
+
 					qglDepthRange (0, 1);
 				}
+
 				oldDepthRange = depthRange;
+				wasCrosshair = isCrosshair;
 			}
 
 			oldEntityNum = entityNum;
@@ -628,7 +1083,13 @@
 	backEnd.refdef.floatTime = originalTime;
 
 	// draw the contents of the last shader batch
-	if (oldShader != NULL) {
+	if (oldShader != NULL) 
+	{
+		EndSurfaceCount++;	
+		if (EndSurfaceCount==2)
+		{
+			EndSurfaceCount=2;
+		}
 		RB_EndSurface();
 	}
 
@@ -646,6 +1107,42 @@
 
 	// add light flares on lights that aren't obscured
 	RB_RenderFlares();
+
+	// post process for dof, bloom 
+	RB_PostProcess();
+
+	// copy the underwater view if we have one
+	if (backEnd.viewParms.isWater==1)
+	{
+		//Copy scene
+		GL_SelectTexture(0);
+		GL_BindTexnum(tr.underwaterTexnum);
+		qglCopyTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0,0,0, WATER_RES_X, WATER_RES_Y ); 
+	}
+	// copy the reflected view if we have one
+	if (backEnd.viewParms.isWater==2)
+	{
+		//Copy scene
+		GL_SelectTexture(0);
+		GL_BindTexnum(tr.reflectionTexnum);
+		qglCopyTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0,0,0, WATER_RES_X,WATER_RES_Y ); 
+	}
+
+	// make a copy if we want one
+	if (tr.refdef.pixelTarget)
+	{
+		int i;
+		
+		// Bugfix: drivers absolutely hate running in high res and using qglReadPixels near the top or bottom edge.
+		// soo.. lets do it in the middle.
+		qglReadPixels( glConfig.vidWidth / 2,glConfig.vidHeight / 2,tr.refdef.pixelTargetX, tr.refdef.pixelTargetY, GL_RGBA, GL_UNSIGNED_BYTE, tr.refdef.pixelTarget);
+		
+		for (i=0;i<tr.refdef.pixelTargetX*tr.refdef.pixelTargetY;i++)
+		{
+			tr.refdef.pixelTarget[(i*4)+3]=255; //set the alpha pure white
+		}
+	}
+
 }
 
 
@@ -681,6 +1178,7 @@
 
 	qglDisable( GL_CULL_FACE );
 	qglDisable( GL_CLIP_PLANE0 );
+	qglDisable( GL_CLIP_PLANE1 );
 
 	// set time for 2D shaders
 	backEnd.refdef.time = ri.Milliseconds();
@@ -732,8 +1230,8 @@
 		qglTexImage2D( GL_TEXTURE_2D, 0, GL_RGB8, cols, rows, 0, GL_RGBA, GL_UNSIGNED_BYTE, data );
 		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
 		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
-		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP );
-		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP );	
+		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
+		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );	
 	} else {
 		if (dirty) {
 			// otherwise, just subimage upload it so that drivers can tell we are going to be changing
@@ -774,8 +1272,8 @@
 		qglTexImage2D( GL_TEXTURE_2D, 0, GL_RGB8, cols, rows, 0, GL_RGBA, GL_UNSIGNED_BYTE, data );
 		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
 		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
-		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP );
-		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP );	
+		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
+		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );	
 	} else {
 		if (dirty) {
 			// otherwise, just subimage upload it so that drivers can tell we are going to be changing
@@ -822,6 +1320,9 @@
 	}
 
 	shader = cmd->shader;
+	if ( !shader )
+		return (const void *)(cmd + 1);
+
 	if ( shader != tess.shader ) {
 		if ( tess.numIndexes ) {
 			RB_EndSurface();
@@ -900,6 +1401,9 @@
 	backEnd.refdef = cmd->refdef;
 	backEnd.viewParms = cmd->viewParms;
 
+	//TODO Maybe check for rdf_noworld stuff but q3mme has full 3d ui
+	backEnd.doneSurfaces = qtrue;
+	
 	RB_RenderDrawSurfList( cmd->drawSurfs, cmd->numDrawSurfs );
 
 	return (const void *)(cmd + 1);
@@ -984,10 +1488,46 @@
 	qglFinish();
 
 	end = ri.Milliseconds();
-	ri.Printf( PRINT_ALL, "%i msec to draw all images\n", end - start );
+	ri.Printf( PRINT_DEVELOPER, "%i msec to draw all images\n", end - start );
 
 }
 
+/*
+=============
+RB_ColorMask
+
+=============
+*/
+const void *RB_ColorMask(const void *data)
+{
+	const colorMaskCommand_t *cmd = data;
+
+	qglColorMask(cmd->rgba[0], cmd->rgba[1], cmd->rgba[2], cmd->rgba[3]);
+	
+	return (const void *)(cmd + 1);
+}
+
+/*
+=============
+RB_ClearDepth
+
+=============
+*/
+const void *RB_ClearDepth(const void *data)
+{
+	const clearDepthCommand_t *cmd = data;
+	
+	if(tess.numIndexes)
+		RB_EndSurface();
+
+	// texture swapping test
+	if (r_showImages->integer)
+		RB_ShowImages();
+
+	qglClear(GL_DEPTH_BUFFER_BIT);
+	
+	return (const void *)(cmd + 1);
+}
 
 /*
 =============
@@ -1039,6 +1579,9 @@
 
 	backEnd.projection2D = qfalse;
 
+	backEnd.doneBloom = qfalse;
+	backEnd.doneSurfaces = qfalse;
+	
 	return (const void *)(cmd + 1);
 }
 
@@ -1084,7 +1627,12 @@
 		case RC_VIDEOFRAME:
 			data = RB_TakeVideoFrameCmd( data );
 			break;
-
+		case RC_COLORMASK:
+			data = RB_ColorMask(data);
+			break;
+		case RC_CLEARDEPTH:
+			data = RB_ClearDepth(data);
+			break;
 		case RC_END_OF_LIST:
 		default:
 			// stop rendering on this thread
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_bsp.c bumpy-code/code/renderer/tr_bsp.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_bsp.c	2014-06-09 22:09:45.527844455 -0400
+++ bumpy-code/code/renderer/tr_bsp.c	2014-06-09 22:14:52.595548728 -0400
@@ -39,8 +40,40 @@
 int			c_subdivisions;
 int			c_gridVerts;
 
+
+srfSurfaceDecal_t* TempDecalStore;
+int			numTempDecalStore;
+
+static void R_CalculateTangents( void );
+static void R_OptimizeSurfaces_bySurface( void );
+
+
 //===============================================================================
 
+/*
+==============
+R_InitVBO
+==============
+*/
+void	R_InitVBO( void ) 
+{
+	//27:  This should probably be relocated
+
+	//tr.staticIndexData;
+	//tr.staticVertexData;
+	if (qglGenBuffersARB==NULL) return;
+
+	qglGenBuffersARB(1, &tr.VBO_indexBuffer);
+	qglGenBuffersARB(1, &tr.VBO_vertexBuffer);
+	qglBindBufferARB(GL_ARRAY_BUFFER_ARB, tr.VBO_vertexBuffer);
+	qglBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, tr.VBO_indexBuffer);
+	qglBufferDataARB(GL_ARRAY_BUFFER_ARB, (GLsizeiptrARB)(tr.numStaticVertex * sizeof(staticVert_t)),tr.staticVertexData, GL_STATIC_DRAW);
+	
+	qglBufferDataARB(GL_ELEMENT_ARRAY_BUFFER_ARB, (GLsizeiptrARB)(tr.numStaticIndex * sizeof(unsigned int)), tr.staticIndexData, GL_STATIC_DRAW);
+	qglBindBufferARB(GL_ARRAY_BUFFER_ARB, 0);
+	qglBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
+}
+
 static void HSVtoRGB( float h, float s, float v, float rgb[3] )
 {
 	int i;
@@ -205,14 +239,269 @@
 			}
 		}
 		tr.lightmaps[i] = R_CreateImage( va("*lightmap%d",i), image, 
-			LIGHTMAP_SIZE, LIGHTMAP_SIZE, qfalse, qfalse, GL_CLAMP );
+			LIGHTMAP_SIZE, LIGHTMAP_SIZE, qfalse, qfalse, GL_CLAMP_TO_EDGE,qfalse,qfalse );
 	}
 
 	if ( r_lightmap->integer == 2 )	{
-		ri.Printf( PRINT_ALL, "Brightest lightmap value: %d\n", ( int ) ( maxIntensity * 255 ) );
+		ri.Printf( PRINT_DEVELOPER, "Brightest lightmap value: %d\n", ( int ) ( maxIntensity * 255 ) );
+	}
+}
+
+//27 update: We create a single 1024x1024 monstrosity and pack everything in
+static	void R_LoadFatLightmaps( lump_t *l )
+{
+	byte		*buf, *buf_p;
+	int			len;
+	int			i;
+
+	//int		BIGSIZE=2048;
+	//int		BIGNUM=16;
+
+	byte		*fatbuffer;
+	int   xoff,yoff,x,y;
+
+	tr.fatLightmapSize=2048;
+	tr.fatLightmapStep=16;
+
+	len = l->filelen;
+	if ( !len ) {
+		return;
+	}
+	buf = fileBase + l->fileofs;
+
+	// we are about to upload textures
+	R_SyncRenderThread();
+
+	// create all the lightmaps
+	tr.numLightmaps = len / (LIGHTMAP_SIZE * LIGHTMAP_SIZE * 3);
+//	if ( tr.numLightmaps == 1 ) {
+		//FIXME: HACK: maps with only one lightmap turn up fullbright for some reason.
+		//this avoids this, but isn't the correct solution.
+//		tr.numLightmaps++;
+	if ( tr.numLightmaps >= MAX_LIGHTMAPS ) { // 20051020 misantropia
+		ri.Printf( PRINT_WARNING, "WARNING: number of lightmaps > MAX_LIGHTMAPS\n" );
+		tr.numLightmaps = MAX_LIGHTMAPS;
+	}
+
+	// if we are in r_vertexLight mode, we don't need the lightmaps at all
+	if ( r_vertexLight->integer || glConfig.hardwareType == GLHW_PERMEDIA2 ) {
+		return;
+	}
+	
+	if (tr.numLightmaps<65) 
+	{
+		//Optimize: use a 1024 if we can get away with it
+		tr.fatLightmapSize=1024;
+		tr.fatLightmapStep=8;
+
+	}
+	fatbuffer = ri.Hunk_AllocateTempMemory( sizeof(byte)* tr.fatLightmapSize*tr.fatLightmapSize*4 );
+
+	memset(fatbuffer,128,tr.fatLightmapSize*tr.fatLightmapSize*4);
+	for ( i = 0 ; i < tr.numLightmaps ; i++ ) 
+	{
+		// expand the 24 bit on-disk to 32 bit
+		buf_p = buf + i * LIGHTMAP_SIZE*LIGHTMAP_SIZE * 3;
+		
+		xoff = i % tr.fatLightmapStep;
+		yoff = i / tr.fatLightmapStep;
+
+		//if (tr.radbumping==qfalse)
+		if (1)
+		{
+			for ( y = 0 ; y < LIGHTMAP_SIZE ; y++ ) 
+			{
+				for ( x = 0 ; x < LIGHTMAP_SIZE ; x++ ) 
+				{
+					int index = (x+(y*tr.fatLightmapSize))+((xoff*LIGHTMAP_SIZE)+(yoff*tr.fatLightmapSize*LIGHTMAP_SIZE));
+					fatbuffer[(index*4)+0 ]=buf_p[((x+(y*LIGHTMAP_SIZE))*3)+0];
+					fatbuffer[(index*4)+1 ]=buf_p[((x+(y*LIGHTMAP_SIZE))*3)+1];
+					fatbuffer[(index*4)+2 ]=buf_p[((x+(y*LIGHTMAP_SIZE))*3)+2];
+					fatbuffer[(index*4)+3 ]=255;
+				}
+			}
+		}
+		/*else
+		{
+			//We need to darken the lightmaps a little bit when mixing radbump and fallback path rendering
+			//because radbump will be darker due to the error introduced by using 3 basis vector probes for lighting instead of surf normal.
+			for ( y = 0 ; y < LIGHTMAP_SIZE ; y++ ) 
+			{
+				for ( x = 0 ; x < LIGHTMAP_SIZE ; x++ ) 
+				{
+					int index = (x+(y*tr.fatLightmapSize))+((xoff*LIGHTMAP_SIZE)+(yoff*tr.fatLightmapSize*LIGHTMAP_SIZE));
+					fatbuffer[(index*4)+0 ]=(byte)(((float)buf_p[((x+(y*LIGHTMAP_SIZE))*3)+0])*scale);
+					fatbuffer[(index*4)+1 ]=(byte)(((float)buf_p[((x+(y*LIGHTMAP_SIZE))*3)+1])*scale);
+					fatbuffer[(index*4)+2 ]=(byte)(((float)buf_p[((x+(y*LIGHTMAP_SIZE))*3)+2])*scale);
+					fatbuffer[(index*4)+3 ]=255;
+				}
+			}
+
+		}*/
+
+		
+	}
+	//memset(fatbuffer,128,tr.fatLightmapSize*tr.fatLightmapSize*4);
+	
+	tr.fatlightmap = R_CreateImage("*fatmap", fatbuffer, tr.fatLightmapSize, tr.fatLightmapSize, qfalse, qfalse, GL_CLAMP,qfalse,qfalse );
+
+	ri.Hunk_FreeTempMemory(fatbuffer);
+}
+
+void R_CheckForRadbumping( const char* name )
+{
+	char radfilename[1024];
+	char filename[1024];
+	byte		*buffer;
+	int result;
+
+	if ( !r_ext_vertex_shader->integer ) 
+	{
+		tr.radbumping = qfalse;
+		return;
+	}
+
+	COM_StripExtension(name, &filename[0], sizeof(filename));
+	Com_sprintf( radfilename, sizeof(radfilename), "%s.rad", filename );
+
+	ri.Printf( PRINT_DEVELOPER, "Checking for availability of radbumping in %s...", radfilename );
+
+	//result = ri.FS_ReadFile( radfilename, (void **)&buffer );
+	result = ri.FS_FileExists(radfilename);
+
+	if ( ( tr.radbumping = (result > 0 ) ) )
+	{
+		ri.Printf( PRINT_DEVELOPER, "yes %i\n", result );
+	}
+	else
+	{
+		ri.Printf( PRINT_DEVELOPER, "no %i\n", result );
+	}
+}
+
+void R_LoadRadFile( const char* name, lump_t *l )
+{
+	if (r_simpleshaders->integer>0) return;
+	
+	//Attempt to load the radbump stuff if it exists
+	if (r_ext_vertex_shader->integer )
+	{
+		char radfilename[1024];
+		char filename[1024];
+		byte		*buffer;
+		byte		*buf_p;
+		byte		*buf;
+		int j;
+		int result;
+		float darken=0.5f;
+
+		byte		*fatbuffer;
+		int   xoff,yoff,x,y,i;
+		int   components;
+		int max=0;
+		
+	
+		COM_StripExtension( name, &filename[0], sizeof( filename ) );
+		Com_sprintf( radfilename, sizeof( radfilename ), "%s.rad", filename );
+//		if (FS_FileExists(radfilename)==qtrue) //27 Bugfix: FS_FileExists doesnt check inside pak files. The correct way is just to use ri.FS_ReadFile and check the result.
+
+		result = ri.FS_ReadFile( radfilename, (void **)&buffer );
+
+		//Figure out if we have a specular part
+		components=result / (sizeof(byte)* LIGHTMAP_SIZE*LIGHTMAP_SIZE*3) ;
+		if ( components / 4 == tr.numLightmaps )
+		{
+			max=4;  //yes we have specular
+		}
+		else
+		{
+			max=3;   //No we dont, so create a dummy specular map
+			ri.Printf( PRINT_DEVELOPER, "No specular available in .RAD file... update your map.");
+		}
+
+
+		if (result>0)
+		{
+			
+
+			fatbuffer = ri.Hunk_AllocateTempMemory( sizeof(byte)* tr.fatLightmapSize*tr.fatLightmapSize* max );
+			memset(fatbuffer,128,tr.fatLightmapSize*tr.fatLightmapSize*max);
+			
+			for ( j=0;j<max;j++)
+			{
+				for ( i = 0 ; i < tr.numLightmaps ; i++ ) 
+				{
+					// expand the 24 bit on-disk to 32 bit
+					buf_p = (buffer + i * LIGHTMAP_SIZE*LIGHTMAP_SIZE * 3)+ (j*  (LIGHTMAP_SIZE*LIGHTMAP_SIZE * 3)*tr.numLightmaps ) ;
+			
+					xoff = i % tr.fatLightmapStep;
+					yoff = i / tr.fatLightmapStep;
+
+					for ( y = 0 ; y < LIGHTMAP_SIZE ; y++ ) 
+					{
+						for ( x = 0 ; x < LIGHTMAP_SIZE ; x++ ) 
+						{
+							int index = (x+(y*tr.fatLightmapSize))+((xoff*LIGHTMAP_SIZE)+(yoff*tr.fatLightmapSize*LIGHTMAP_SIZE));
+							fatbuffer[(index*4)+0 ]=buf_p[((x+(y*LIGHTMAP_SIZE))*3)+0];
+							fatbuffer[(index*4)+1 ]=buf_p[((x+(y*LIGHTMAP_SIZE))*3)+1];
+							fatbuffer[(index*4)+2 ]=buf_p[((x+(y*LIGHTMAP_SIZE))*3)+2];
+							fatbuffer[(index*4)+3 ]=255;
+						}
+					}
+				}
+				if (j==0) tr.radbump[j] = R_CreateImage("*radmap0", fatbuffer, tr.fatLightmapSize, tr.fatLightmapSize, qfalse, qfalse, GL_CLAMP,qfalse,qfalse );
+				if (j==1) tr.radbump[j] = R_CreateImage("*radmap1", fatbuffer, tr.fatLightmapSize, tr.fatLightmapSize, qfalse, qfalse, GL_CLAMP,qfalse,qfalse );
+				if (j==2) tr.radbump[j] = R_CreateImage("*radmap2", fatbuffer, tr.fatLightmapSize, tr.fatLightmapSize, qfalse, qfalse, GL_CLAMP,qfalse,qfalse );
+				if (j==3) tr.radbump[j] = R_CreateImage("*radmap3", fatbuffer, tr.fatLightmapSize, tr.fatLightmapSize, qfalse, qfalse, GL_CLAMP,qfalse,qfalse );
+			}
+
+			if (max==3)
+			{
+				
+				//Create a dummy spec channel full of 0's			
+				memset(fatbuffer,0,4);
+				tr.radbump[3] = R_CreateImage("*radmap3", fatbuffer, 1, 1, qfalse, qfalse, GL_CLAMP,qfalse,qfalse );
+			}
+
+			ri.Hunk_FreeTempMemory(fatbuffer);
+			ri.FS_FreeFile( buffer );
+		}
+		else
+		{
+			//autogen one from the lightmaps
+			fatbuffer = ri.Hunk_AllocateTempMemory( sizeof(byte)* tr.fatLightmapSize*tr.fatLightmapSize*4 );
+			memset(fatbuffer,128,tr.fatLightmapSize*tr.fatLightmapSize*4);
+
+			buf = fileBase + l->fileofs;
+			
+			for ( i = 0 ; i < tr.numLightmaps ; i++ ) 
+			{
+		
+				buf_p = buf + i * LIGHTMAP_SIZE*LIGHTMAP_SIZE * 3;
+				
+				xoff = i % tr.fatLightmapStep;
+				yoff = i / tr.fatLightmapStep;
+				for ( y = 0 ; y < LIGHTMAP_SIZE ; y++ ) 
+				{
+					for ( x = 0 ; x < LIGHTMAP_SIZE ; x++ ) 
+					{
+						int index = (x+(y*tr.fatLightmapSize))+((xoff*LIGHTMAP_SIZE)+(yoff*tr.fatLightmapSize*LIGHTMAP_SIZE));
+						fatbuffer[(index*4)+0 ]=buf_p[((x+(y*LIGHTMAP_SIZE))*3)+0] * darken;
+						fatbuffer[(index*4)+1 ]=buf_p[((x+(y*LIGHTMAP_SIZE))*3)+1] * darken;
+						fatbuffer[(index*4)+2 ]=buf_p[((x+(y*LIGHTMAP_SIZE))*3)+2] * darken;
+						fatbuffer[(index*4)+3 ]=255;
 	}
 }
+			}
+			tr.radbump[2] = tr.radbump[1] = tr.radbump[0] = R_CreateImage("*radmap0", fatbuffer, tr.fatLightmapSize, tr.fatLightmapSize, qfalse, qfalse, GL_CLAMP ,qfalse,qfalse);
+			memset(fatbuffer,0,4);
+			tr.radbump[3] = R_CreateImage("*radmap3", fatbuffer, 1, 1, qfalse, qfalse, GL_CLAMP,qfalse,qfalse );
+			
+			ri.Hunk_FreeTempMemory(fatbuffer);
 
+		}
+	}
+}
 
 /*
 =================
@@ -298,6 +587,35 @@
 	return shader;
 }
 
+
+void R_BufferAllocTris(int* StartIndex,int* StartVertex,int numIndicies,int numVerts)
+{
+	if (tr.numStaticIndex+numIndicies>r_maxstaticverts->integer-1 ||tr.numStaticVertex+numVerts>r_maxstaticverts->integer-1)
+	{
+		ri.Error (ERR_DROP, "LoadMap: Ran out of static Verts.  Increase r_maxstaticverts.");
+
+	}
+	*StartIndex=tr.numStaticIndex;
+	*StartVertex=tr.numStaticVertex;
+	tr.numStaticIndex+=numIndicies;
+	tr.numStaticVertex+=numVerts;
+}
+
+
+float FatPackU(float input,int lightmapnum)
+{
+	int x= lightmapnum % tr.fatLightmapStep;
+	
+	return (input/((float)tr.fatLightmapStep))+ ( (1.0/((float)tr.fatLightmapStep)) * (float)x );
+
+}
+
+float FatPackV(float input,int lightmapnum)
+{
+	int y= lightmapnum / ((float)tr.fatLightmapStep);
+	return (input/((float)tr.fatLightmapStep))+ ( (1.0/((float)tr.fatLightmapStep)) * (float)y );
+}
+
 /*
 ===============
 ParseFace
@@ -306,21 +624,98 @@
 static void ParseFace( dsurface_t *ds, drawVert_t *verts, msurface_t *surf, int *indexes  ) {
 	int			i, j;
 	srfSurfaceFace_t	*cv;
+	srfSurfaceStatic_t	*sv;
 	int			numPoints, numIndexes;
 	int			lightmapNum;
 	int			sfaceSize, ofsIndexes;
+	staticVert_t		*data;
+	unsigned int		*indexs;
+	int			realLightmapNum;
 
-	lightmapNum = LittleLong( ds->lightmapNum );
+	realLightmapNum = LittleLong( ds->lightmapNum );
+	lightmapNum = 0;
 
 	// get fog volume
 	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
 
 	// get shader value
+	if (realLightmapNum<0) lightmapNum=realLightmapNum;
 	surf->shader = ShaderForShaderNum( ds->shaderNum, lightmapNum );
 	if ( r_singleShader->integer && !surf->shader->isSky ) {
 		surf->shader = tr.defaultShader;
 	}
 
+	if ( surf->fogIndex==0)
+	{
+		surf->shader = GLSLOptimizeShader(surf->shader);
+	}
+
+	//27: Static mesh optimization 
+	if (r_ext_vertex_buffer_object->integer && surf->shader->isGLSLStatic)
+	{
+		//we're a lightmapped texture, so we don't build a regular surface
+		numPoints = LittleLong( ds->numVerts );
+		numIndexes = LittleLong( ds->numIndexes );
+		sfaceSize = sizeof(srfSurfaceStatic_t);
+		sv = ri.Hunk_Alloc( sfaceSize, h_low );
+		sv->surfaceType=SF_STATIC;
+		sv->numIndices = numIndexes;
+		sv->numVerts = numPoints;
+
+		R_BufferAllocTris(&sv->startIndex,&sv->startVertex,sv->numIndices,sv->numVerts);
+		
+		data = &tr.staticVertexData[sv->startVertex];
+		indexs = &tr.staticIndexData[sv->startIndex];
+		
+		verts += LittleLong( ds->firstVert );
+		for ( i = 0 ; i < sv->numVerts ; i++ ) 
+		{
+			data[i].position[0] = LittleFloat( verts[i].xyz[0] );
+			data[i].position[1] = LittleFloat( verts[i].xyz[1] );
+			data[i].position[2] = LittleFloat( verts[i].xyz[2] );
+			
+			data[i].uv[0] = LittleFloat( verts[i].st[0] );
+			data[i].uv[1] = LittleFloat( verts[i].st[1] );
+			
+
+			data[i].light_uv[0] =  FatPackU(LittleFloat( verts[i].lightmap[0] ),realLightmapNum);
+			data[i].light_uv[1] =  FatPackV(LittleFloat( verts[i].lightmap[1] ),realLightmapNum);
+			
+
+			data[i].normal[0] = LittleFloat( verts[i].normal[0] );
+			data[i].normal[1] = LittleFloat( verts[i].normal[1] );
+			data[i].normal[2] = LittleFloat( verts[i].normal[2] ); 
+
+			data[i].rgba[0] = verts[i].color[0] / 255.0f;
+			data[i].rgba[1] = verts[i].color[1] / 255.0f;
+			data[i].rgba[2] = verts[i].color[2] / 255.0f;
+			data[i].rgba[3] = verts[i].color[3]  / 255.0f;
+		}
+		
+		indexes += LittleLong( ds->firstIndex );
+		for ( i= 0 ; i < sv->numIndices; i++ )
+		{
+			indexs[i]= LittleLong( indexes[ i ] )+sv->startVertex; // indexes are all 0 based..
+		}
+
+		sv->shader=surf->shader;
+		sv->surfnum=rand()% 1000;
+		surf->data = (surfaceType_t *)sv;
+		
+		
+		if (r_decals->integer) 
+		{
+			//For each tri, add it to the decal list
+			for ( i= 0 ; i < sv->numIndices; i+=3 )
+			{
+				R_StoreDecalSurf(data[indexes[i] ].position,data[indexes[i+1]].position,data[indexes[i+2]].position,surf);
+			}
+		}
+
+
+		return;
+	}
+
 	numPoints = LittleLong( ds->numVerts );
 	if (numPoints > MAX_FACE_POINTS) {
 		ri.Printf( PRINT_WARNING, "WARNING: MAX_FACE_POINTS exceeded: %i\n", numPoints);
@@ -346,10 +741,12 @@
 		for ( j = 0 ; j < 3 ; j++ ) {
 			cv->points[i][j] = LittleFloat( verts[i].xyz[j] );
 		}
-		for ( j = 0 ; j < 2 ; j++ ) {
-			cv->points[i][3+j] = LittleFloat( verts[i].st[j] );
-			cv->points[i][5+j] = LittleFloat( verts[i].lightmap[j] );
-		}
+		
+			cv->points[i][3] = LittleFloat( verts[i].st[0] );
+			cv->points[i][4] = LittleFloat( verts[i].st[1] );
+			cv->points[i][5] =FatPackU( LittleFloat( verts[i].lightmap[0] ), realLightmapNum);
+			cv->points[i][6] =FatPackV( LittleFloat( verts[i].lightmap[1] ), realLightmapNum);
+		
 		R_ColorShiftLightingBytes( verts[i].color, (byte *)&cv->points[i][7] );
 	}
 
@@ -367,61 +764,266 @@
 	cv->plane.type = PlaneTypeForNormal( cv->plane.normal );
 
 	surf->data = (surfaceType_t *)cv;
+
+	if (r_decals->integer)
+	{
+		//check to see if its insane to decal this surface
+		if (!(surf->shader->surfaceFlags & SURF_NOMARKS) &&
+			!(surf->shader->surfaceFlags & SURF_NONSOLID) &&
+			surf->shader->numDeforms==0 &&
+			cv->plane.type ==PLANE_NON_AXIAL)
+		{
+			for ( i = 0 ; i < numIndexes ; i+=3 )
+			{
+				int Index0,Index1,Index2;
+				Index0 = LittleLong( indexes[i+0] );
+				Index1 = LittleLong( indexes[i+1] );
+				Index2 = LittleLong( indexes[i+2] );
+				R_StoreDecalSurf(verts[Index0].xyz,verts[Index1].xyz,verts[Index2].xyz, surf);
+			}
+		}
+	}
 }
 
 
-/*
-===============
-ParseMesh
-===============
-*/
-static void ParseMesh ( dsurface_t *ds, drawVert_t *verts, msurface_t *surf ) {
-	srfGridMesh_t	*grid;
+//Converts a patch mesh to a highest resolution SF_STATIC
+srfSurfaceStatic_t *SurfaceGrid_To_Static( srfGridMesh_t *cv ,shader_t *shader) 
+{
 	int				i, j;
-	int				width, height, numPoints;
-	drawVert_t points[MAX_PATCH_SIZE*MAX_PATCH_SIZE];
-	int				lightmapNum;
-	vec3_t			bounds[2];
-	vec3_t			tmpVec;
-	static surfaceType_t	skipData = SF_SKIP;
+	float	*xyz;
+	float	*texCoords;
+	float	*texCoordsLight;
+	float	*normal;
+	float   *color;
+	drawVert_t	*dv;
+	int		rows;
+	int		used;
+	int		widthTable[MAX_GRID_SIZE];
+	int		heightTable[MAX_GRID_SIZE];
+	int		lodWidth, lodHeight;
+	staticVert_t	*data;
+	unsigned int			*indexs;
+	int h,w;
+
+	int vertexcount=0;
+	int indexcount=0;
+
+	int totalverts=0;
+	int totalindexes=0;
+
+	int pos=0;
+
+	srfSurfaceStatic_t	*sv;	
+	int sfaceSize = sizeof(srfSurfaceStatic_t);
+
+	
+	// determine which rows and columns of the subdivision
+	// we are actually going to use
+	widthTable[0] = 0;
+	lodWidth = 1;
+	for ( i = 1 ; i < cv->width-1 ; i++ ) 
+	{
+		widthTable[lodWidth] = i;
+		lodWidth++;
+	}
+	widthTable[lodWidth] = cv->width-1;
+	lodWidth++;
+
+	heightTable[0] = 0;
+	lodHeight = 1;
+	for ( i = 1 ; i < cv->height-1 ; i++ ) 
+	{
+		heightTable[lodHeight] = i;
+		lodHeight++;
+	}
+	heightTable[lodHeight] = cv->height-1;
+	lodHeight++;
 
-	lightmapNum = LittleLong( ds->lightmapNum );
+	//Precount the verts/indexes used in tesselation by giving it a run through
+	used = 0;
+	rows = 0;
+	totalverts=0;
+	totalindexes=0;
 
-	// get fog volume
-	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
+	while ( used < lodHeight - 1 ) 
+	{
+		rows = lodHeight - used;
 
-	// get shader value
-	surf->shader = ShaderForShaderNum( ds->shaderNum, lightmapNum );
-	if ( r_singleShader->integer && !surf->shader->isSky ) {
-		surf->shader = tr.defaultShader;
-	}
 
-	// we may have a nodraw surface, because they might still need to
-	// be around for movement clipping
-	if ( s_worldData.shaders[ LittleLong( ds->shaderNum ) ].surfaceFlags & SURF_NODRAW ) {
-		surf->data = &skipData;
-		return;
+		for ( i = 0 ; i < rows ; i++ ) 
+		{
+			for ( j = 0 ; j < lodWidth ; j++ ) 
+			{
+				totalverts++;	
+			}
 	}
 
-	width = LittleLong( ds->patchWidth );
-	height = LittleLong( ds->patchHeight );
+		h = rows - 1;
+		w = lodWidth - 1;
 
-	verts += LittleLong( ds->firstVert );
-	numPoints = width * height;
-	for ( i = 0 ; i < numPoints ; i++ ) {
-		for ( j = 0 ; j < 3 ; j++ ) {
-			points[i].xyz[j] = LittleFloat( verts[i].xyz[j] );
-			points[i].normal[j] = LittleFloat( verts[i].normal[j] );
+		for (i = 0 ; i < h ; i++) 
+		{
+			for (j = 0 ; j < w ; j++) 
+			{
+				totalindexes+=6;
 		}
-		for ( j = 0 ; j < 2 ; j++ ) {
-			points[i].st[j] = LittleFloat( verts[i].st[j] );
-			points[i].lightmap[j] = LittleFloat( verts[i].lightmap[j] );
 		}
-		R_ColorShiftLightingBytes( verts[i].color, points[i].color );
+		used += rows - 1;
 	}
 
-	// pre-tesseleate
-	grid = R_SubdividePatchToGrid( width, height, points );
+	//Allocate and do it for real, now
+	used = 0;
+	rows = 0;
+	
+	sv = ri.Hunk_Alloc( sfaceSize, h_low );
+	sv->surfaceType=SF_STATIC;
+	sv->numVerts = totalverts;
+	sv->numIndices = totalindexes;
+		
+	R_BufferAllocTris(&sv->startIndex,&sv->startVertex,sv->numIndices,sv->numVerts);
+		
+	data=&tr.staticVertexData[sv->startVertex];
+	indexs=&tr.staticIndexData[sv->startIndex];
+
+
+	while ( used < lodHeight - 1 ) 
+	{
+		rows = lodHeight - used;
+		
+		pos = vertexcount;
+		for ( i = 0 ; i < rows ; i++ ) 
+		{
+			for ( j = 0 ; j < lodWidth ; j++ ) 
+			{
+				dv = cv->verts + heightTable[ used + i ] * cv->width + widthTable[ j ];
+
+				xyz = data[pos].position;
+				normal = data[pos].normal;
+				texCoordsLight =data[pos].light_uv;
+				texCoords =data[pos].uv;
+				color = data[pos].rgba;
+
+
+				xyz[0] = dv->xyz[0];
+				xyz[1] = dv->xyz[1];
+				xyz[2] = dv->xyz[2];
+				texCoords[0] = dv->st[0];
+				texCoords[1] = dv->st[1];
+				texCoordsLight[0] = dv->lightmap[0];
+				texCoordsLight[1] = dv->lightmap[1];
+				normal[0] = dv->normal[0];
+				normal[1] = dv->normal[1];
+				normal[2] = dv->normal[2];
+
+				color[0]=(float)dv->color[0] / 255.0f;
+				color[1]=(float)dv->color[1] / 255.0f;
+				color[2]=(float)dv->color[2] / 255.0f;
+				color[3]=(float)dv->color[3] / 255.0f;
+				//* ( unsigned int * ) color = 0xFFFF;//* ( unsigned int * ) dv->color;
+				
+				pos++;
+			}
+		}
+
+
+		// add the indexes
+		h = rows - 1;
+		w = lodWidth - 1;
+		
+		for (i = 0 ; i < h ; i++)
+		{
+			for (j = 0 ; j < w ; j++) 
+			{
+				int		v1, v2, v3, v4;
+		
+				// vertex order to be reckognized as tristrips
+				v1 = vertexcount + i*lodWidth + j + 1;
+				v2 = v1 - 1;
+				v3 = v2 + lodWidth;
+				v4 = v3 + 1;
+
+				indexs[indexcount] = v2+sv->startVertex;
+				indexs[indexcount+1] = v3+sv->startVertex;
+				indexs[indexcount+2] = v1+sv->startVertex;
+				
+				indexs[indexcount+3] = v1+sv->startVertex;
+				indexs[indexcount+4] = v3+sv->startVertex;
+				indexs[indexcount+5] = v4+sv->startVertex;
+				indexcount += 6;
+			}
+		}
+
+
+		vertexcount += rows * lodWidth;
+
+		used += rows - 1;
+	}
+
+	sv->shader=shader;
+
+	return sv;
+}
+
+
+/*
+===============
+ParseMesh
+===============
+*/
+static void ParseMesh ( dsurface_t *ds, drawVert_t *verts, msurface_t *surf ) {
+	srfGridMesh_t	*grid;
+	int				i, j;
+	int				width, height, numPoints;
+	drawVert_t points[MAX_PATCH_SIZE*MAX_PATCH_SIZE];
+	int				lightmapNum, realLightmapNum;
+	vec3_t			bounds[2];
+	vec3_t			tmpVec;
+	static surfaceType_t	skipData = SF_SKIP;
+
+	
+	realLightmapNum = LittleLong( ds->lightmapNum );
+	lightmapNum = 0;
+	
+	if (realLightmapNum<0) lightmapNum=realLightmapNum;
+	
+	// get fog volume
+	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
+
+	// get shader value
+	surf->shader = ShaderForShaderNum( ds->shaderNum, lightmapNum );
+	if ( r_singleShader->integer && !surf->shader->isSky ) {
+		surf->shader = tr.defaultShader;
+	}
+
+	// we may have a nodraw surface, because they might still need to
+	// be around for movement clipping
+	if ( s_worldData.shaders[ LittleLong( ds->shaderNum ) ].surfaceFlags & SURF_NODRAW ) {
+		surf->data = &skipData;
+		return;
+	}
+
+	width = LittleLong( ds->patchWidth );
+	height = LittleLong( ds->patchHeight );
+
+	verts += LittleLong( ds->firstVert );
+	numPoints = width * height;
+	for ( i = 0 ; i < numPoints ; i++ ) {
+		for ( j = 0 ; j < 3 ; j++ ) {
+			points[i].xyz[j] = LittleFloat( verts[i].xyz[j] );
+			points[i].normal[j] = LittleFloat( verts[i].normal[j] );
+		}
+		
+			points[i].st[0] = LittleFloat( verts[i].st[0] );
+			points[i].st[1] = LittleFloat( verts[i].st[1] );
+			
+			points[i].lightmap[0] = FatPackU( LittleFloat( verts[i].lightmap[0] ),realLightmapNum);
+			points[i].lightmap[1] = FatPackV( LittleFloat( verts[i].lightmap[1] ),realLightmapNum);
+		
+		R_ColorShiftLightingBytes( verts[i].color, points[i].color );
+	}
+
+	// pre-tesseleate
+	grid = R_SubdividePatchToGrid( width, height, points );
 	surf->data = (surfaceType_t *)grid;
 
 	// copy the level of detail origin, which is the center
@@ -435,8 +1037,25 @@
 	VectorScale( bounds[1], 0.5f, grid->lodOrigin );
 	VectorSubtract( bounds[0], grid->lodOrigin, tmpVec );
 	grid->lodRadius = VectorLength( tmpVec );
+
+	
+	if (surf->fogIndex==0)
+	{
+		surf->shader = GLSLOptimizeShader(surf->shader);
+	}
+
+	if (surf->shader->isGLSLStatic && r_ext_vertex_buffer_object->integer )
+	{
+		//turn us into a SF_STATIC if we need to be one
+		surf->data = (surfaceType_t *)SurfaceGrid_To_Static(grid,surf->shader);
+	}
+
+
 }
 
+
+
+
 /*
 ===============
 ParseTriSurf
@@ -446,6 +1065,10 @@
 	srfTriangles_t	*tri;
 	int				i, j;
 	int				numVerts, numIndexes;
+	int				sfaceSize;
+	staticVert_t	*data;
+	unsigned int			*indexs;
+	srfSurfaceStatic_t	*sv;
 
 	// get fog volume
 	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
@@ -456,6 +1079,66 @@
 		surf->shader = tr.defaultShader;
 	}
 
+	if ( surf->fogIndex==0)
+	{
+		surf->shader = GLSLOptimizeShader(surf->shader);
+	}
+
+	//27: Static mesh optimization 
+	if (r_ext_vertex_buffer_object->integer && surf->shader->isGLSLStatic )
+	{
+		//we're a lightmapped texture, so we don't build a regular surface
+		numVerts = LittleLong( ds->numVerts );
+		numIndexes = LittleLong( ds->numIndexes );
+		sfaceSize = sizeof(srfSurfaceStatic_t);
+		sv = ri.Hunk_Alloc( sfaceSize, h_low );
+		sv->surfaceType=SF_STATIC;
+		sv->numIndices = numIndexes;
+		sv->numVerts = numVerts;
+		
+		R_BufferAllocTris(&sv->startIndex,&sv->startVertex,sv->numIndices,sv->numVerts);
+		
+		data=&tr.staticVertexData[sv->startVertex];
+		indexs=&tr.staticIndexData[sv->startIndex];
+		
+		verts += LittleLong( ds->firstVert );
+		for ( i = 0 ; i < sv->numVerts ; i++ ) 
+		{
+			data[i].position[0] = LittleFloat( verts[i].xyz[0] );
+			data[i].position[1] = LittleFloat( verts[i].xyz[1] );
+			data[i].position[2] = LittleFloat( verts[i].xyz[2] );
+			
+			data[i].uv[0] = LittleFloat( verts[i].st[0] );
+			data[i].uv[1] = LittleFloat( verts[i].st[1] );
+			
+			//Todo: These surfaces dont use lightmaps at all.
+			data[i].light_uv[0] = FatPackU(LittleFloat( verts[i].lightmap[0] ),0);
+			data[i].light_uv[1] = FatPackV(LittleFloat( verts[i].lightmap[1] ),0);
+			
+			data[i].normal[0] = LittleFloat( verts[i].normal[0] );
+			data[i].normal[1] = LittleFloat( verts[i].normal[1] );
+			data[i].normal[2] = LittleFloat( verts[i].normal[2] );
+
+			data[i].rgba[0] = verts[i].color[0] / 255.0f;
+			data[i].rgba[1] = verts[i].color[1] / 255.0f;
+			data[i].rgba[2] = verts[i].color[2] / 255.0f;
+			data[i].rgba[3] = verts[i].color[3] / 255.0f;
+
+		}
+		
+		indexes += LittleLong( ds->firstIndex );
+		for ( i= 0 ; i < sv->numIndices; i++ )
+		{
+			indexs[i]= LittleLong( indexes[ i ])  +sv->startVertex ; // indexes are all 0 based..
+		}
+
+		sv->shader=surf->shader;
+		sv->surfnum=rand()% 2000;
+		surf->data = (surfaceType_t *)sv;
+		
+		return;
+	}
+
 	numVerts = LittleLong( ds->numVerts );
 	numIndexes = LittleLong( ds->numIndexes );
 
@@ -494,6 +1177,25 @@
 			ri.Error( ERR_DROP, "Bad index in triangle surface" );
 		}
 	}
+
+	
+	if (r_decals->integer)
+	{
+		//check to see if its insane to decal this surface
+		if (!(surf->shader->surfaceFlags & SURF_NOMARKS) &&
+			!(surf->shader->surfaceFlags & SURF_NONSOLID) &&
+			surf->shader->numDeforms==0 )
+		{
+			for ( i = 0 ; i < numIndexes ; i+=3 )
+			{
+				int Index0,Index1,Index2;
+				Index0 = LittleLong( indexes[i+0] );
+				Index1 = LittleLong( indexes[i+1] );
+				Index2 = LittleLong( indexes[i+2] );
+				R_StoreDecalSurf(tri->verts[Index0].xyz,tri->verts[Index1].xyz,tri->verts[Index2].xyz, surf);
+			}
+		}
+	}
 }
 
 /*
@@ -1187,7 +1890,7 @@
 		}
 	}
 	while (stitched);
-	ri.Printf( PRINT_ALL, "stitched %d LoD cracks\n", numstitches );
+	ri.Printf( PRINT_DEVELOPER, "stitched %d LoD cracks\n", numstitches );
 }
 
 /*
@@ -1292,7 +1995,7 @@
 	R_MovePatchSurfacesToHunk();
 #endif
 
-	ri.Printf( PRINT_ALL, "...loaded %d faces, %i meshes, %i trisurfs, %i flares\n", 
+	ri.Printf( PRINT_DEVELOPER, "...loaded %d faces, %i meshes, %i trisurfs, %i flares\n", 
 		numFaces, numMeshes, numTriSurfs, numFlares );
 }
 
@@ -1314,6 +2017,7 @@
 	count = l->filelen / sizeof(*in);
 
 	s_worldData.bmodels = out = ri.Hunk_Alloc( count * sizeof(*out), h_low );
+	s_worldData.numbmodels = count;
 
 	for ( i=0 ; i<count ; i++, in++, out++ ) {
 		model_t *model;
@@ -1321,6 +2025,9 @@
 		model = R_AllocModel();
 
 		assert( model != NULL );			// this should never happen
+		if ( model == NULL ) {
+			ri.Error(ERR_DROP, "R_LoadSubmodels: R_AllocModel() failed");
+		}
 
 		model->type = MOD_BRUSH;
 		model->bmodel = out;
@@ -1424,6 +2131,22 @@
 		out->firstmarksurface = s_worldData.marksurfaces +
 			LittleLong(inLeaf->firstLeafSurface);
 		out->nummarksurfaces = LittleLong(inLeaf->numLeafSurfaces);
+
+		
+		//allocate some room for the decals
+		if (r_decals->integer>0)
+		{
+			//out->decalTris=ri.Hunk_Alloc( sizeof(msurface_t)*out->nummarksurfaces, h_low );
+			//memset(out->decalsurfs,0,sizeof(msurface_t)*out->nummarksurfaces);
+			out->numDecalTris=0;
+			//backup
+			out->o_firstmarksurface = s_worldData.marksurfaces +
+				LittleLong(inLeaf->firstLeafSurface);
+			out->o_nummarksurfaces = LittleLong(inLeaf->numLeafSurfaces);
+		}
+		
+		//newvis
+		out->newVisCluster=-1;
 	}	
 
 	// chain decendants
@@ -1684,16 +2407,18 @@
 	}
 }
 
-/*
-================
-R_LoadEntities
-================
-*/
 void R_LoadEntities( lump_t *l ) {
 	char *p, *token, *s;
 	char keyname[MAX_TOKEN_CHARS];
 	char value[MAX_TOKEN_CHARS];
 	world_t	*w;
+	float red,green,blue,density;
+
+	density=0.0;
+	red=0.25;
+	green=0.25;
+	blue=0.25;
+
 
 	w = &s_worldData;
 	w->lightGridSize[0] = 64;
@@ -1761,7 +2486,29 @@
 			sscanf(value, "%f %f %f", &w->lightGridSize[0], &w->lightGridSize[1], &w->lightGridSize[2] );
 			continue;
 		}
+
+		//check for fog
+		if (!Q_stricmp(keyname, "globalfog")) {
+			sscanf(&value[0], " %f %f %f %f",&red,&green,&blue ,&density);
+			
+			
+			continue;
+		}
+
 	}
+
+	//set the fog
+	Cvar_SetValue(r_fog_r->name,red);
+	Cvar_SetValue(r_fog_g->name,green);
+	Cvar_SetValue(r_fog_b->name,blue);
+	Cvar_SetValue(r_fogdensity->name,density);
+
+	r_fog_r->resetString=CopyString(r_fog_r->string);
+	r_fog_g->resetString=CopyString(r_fog_g->string);
+	r_fog_b->resetString=CopyString(r_fog_b->string);
+	r_fogdensity->resetString=CopyString(r_fogdensity->string);
+
+
 }
 
 /*
@@ -1792,7 +2539,10 @@
 void RE_LoadWorldMap( const char *name ) {
 	int			i;
 	dheader_t	*header;
-	byte		*buffer;
+	union {
+		byte *b;
+		void *v;
+	} buffer;
 	byte		*startMarker;
 
 	if ( tr.worldMapLoaded ) {
@@ -1810,8 +2560,9 @@
 	tr.worldMapLoaded = qtrue;
 
 	// load it
-    ri.FS_ReadFile( name, (void **)&buffer );
-	if ( !buffer ) {
+	ri.FS_ReadFile( name, &buffer.v );
+
+	if ( !buffer.b ) {
 		ri.Error (ERR_DROP, "RE_LoadWorldMap: %s not found", name);
 	}
 
@@ -1828,7 +2579,7 @@
 	startMarker = ri.Hunk_Alloc(0, h_low);
 	c_gridVerts = 0;
 
-	header = (dheader_t *)buffer;
+	header = (dheader_t *)buffer.b;
 	fileBase = (byte *)header;
 
 	i = LittleLong (header->version);
@@ -1842,14 +2593,38 @@
 		((int *)header)[i] = LittleLong ( ((int *)header)[i]);
 	}
 
+	if ( r_ext_vertex_buffer_object->integer ) {
+		//VBo's, temporary allocate some vertex room
+		tr.staticVertexData =  ri.Hunk_AllocateTempMemory( sizeof(staticVert_t)* r_maxstaticverts->integer );
+		tr.staticIndexData =  ri.Hunk_AllocateTempMemory( sizeof(int)* r_maxstaticverts->integer );
+	} 
+
 	// load into heap
 	R_LoadShaders( &header->lumps[LUMP_SHADERS] );
-	R_LoadLightmaps( &header->lumps[LUMP_LIGHTMAPS] );
+	// R_LoadLightmaps( &header->lumps[LUMP_LIGHTMAPS] );
+	R_CheckForRadbumping( name ); //do this before loading lightmaps
+	R_LoadFatLightmaps( &header->lumps[LUMP_LIGHTMAPS] );
+	R_LoadRadFile( name,  &header->lumps[LUMP_LIGHTMAPS]  );
+
 	R_LoadPlanes (&header->lumps[LUMP_PLANES]);
 	R_LoadFogs( &header->lumps[LUMP_FOGS], &header->lumps[LUMP_BRUSHES], &header->lumps[LUMP_BRUSHSIDES] );
+
+	if ( r_decals->integer ) {
+		TempDecalStore=ri.Hunk_AllocateTempMemory( r_maxstaticverts->integer*sizeof( srfSurfaceDecal_t ) );
+		numTempDecalStore=0;
+	}
+
 	R_LoadSurfaces( &header->lumps[LUMP_SURFACES], &header->lumps[LUMP_DRAWVERTS], &header->lumps[LUMP_DRAWINDEXES] );
 	R_LoadMarksurfaces (&header->lumps[LUMP_LEAFSURFACES]);
 	R_LoadNodesAndLeafs (&header->lumps[LUMP_NODES], &header->lumps[LUMP_LEAFS]);
+	
+	if (r_decals->integer)
+	{
+		R_AddDecalSurfs();
+		//free the temp decal storage
+		ri.Hunk_FreeTempMemory( TempDecalStore );
+	}
+
 	R_LoadSubmodels (&header->lumps[LUMP_MODELS]);
 	R_LoadVisibility( &header->lumps[LUMP_VISIBILITY] );
 	R_LoadEntities( &header->lumps[LUMP_ENTITIES] );
@@ -1860,6 +2635,581 @@
 	// only set tr.world now that we know the entire level has loaded properly
 	tr.world = &s_worldData;
 
-    ri.FS_FreeFile( buffer );
+	///27: R_InitVBO's here
+	if ( r_ext_vertex_buffer_object->integer )
+	{
+		R_OptimizeSurfaces_bySurface();
+		
+		R_CalculateTangents();
+		R_InitVBO();
+
+		//Free VBo's temporary memory.  Note that you have to free in this order
+		ri.Hunk_FreeTempMemory(tr.staticIndexData);
+		ri.Hunk_FreeTempMemory(tr.staticVertexData);
+	}
+
+	ri.FS_FreeFile( buffer.v );
+
+	//Clear the texture binding on all TMU's now
+	//This stops the issue with only 1 lightmap being loaded - long standing q3 bug
+	//(white lightmaps issue on abbey)
+	Com_Memset( glState.currenttextures, 0, sizeof( glState.currenttextures ) );
+
+	// Build up the cubemaps now
+	R_BuildCubeMaps();
+}
+
+
+static void R_OptimizeSurfaces_bySurface()
+{
+	//Flip through the surfaces and try and collapse them
+	int j,r,q,i;
+
+	srfSurfaceStatic_t *sv;
+	srfSurfaceStatic_t *sc;
+
+	int			c;
+	msurface_t	*surf, **mark;
+	qboolean CanSee;
+
+
+	int leafCount=0;
+	mnode_t *Leafs[1024];
+
+
+	int vertcount=0;
+	int indexcount=0;
+
+	int surfcount=0;
+
+	unsigned int *IndexData;
+	staticVert_t* VertexData;
+	vec3_t mins;
+	vec3_t maxs;
+
+	VertexData =  ri.Hunk_AllocateTempMemory( sizeof(staticVert_t)*tr.numStaticVertex );
+	IndexData =  ri.Hunk_AllocateTempMemory( sizeof(int)*tr.numStaticIndex );
+
+
+	for (j=0;j<s_worldData.numsurfaces;j++)
+	{
+		sv =(void*)s_worldData.surfaces[j].data;
+		
+		if (sv->surfaceType!=SF_STATIC) continue; //otherwise makes no sense
+		sv->merged=-1;
+		sv->modelNum=-1;
+	}
+
+
+	//flip through all the bmodels and mark which surfaces they own
+	for (j=0;j<s_worldData.numbmodels;j++)
+	{
+		msurface_t *surf;
+		bmodel_t *model;
+		model=&s_worldData.bmodels[j];
+
+		for (r=0;r<model->numSurfaces;r++)
+		{
+			surf = model->firstSurface+r;
+			//sv=surf->data;
+			
+			if (*surf->data==SF_STATIC)
+			{
+				sv =(void*)surf->data;
+				sv->modelNum=j;
+			}
+		}
+	}
+
+
+ 	for (j=0;j<s_worldData.numsurfaces;j++)
+	{
+		sv =(void*)s_worldData.surfaces[j].data;
+		
+		if (sv->surfaceType!=SF_STATIC) continue; //otherwise makes no sense
+		if (sv->merged>-1) continue;
+
+		//start by copying this surfaces data 
+		for (q=0;q<sv->numIndices;q++)
+		{
+			IndexData[indexcount+q]= ( tr.staticIndexData[sv->startIndex+q]-sv->startVertex)+vertcount;
+		}
+		for (q=0;q<sv->numVerts;q++)
+		{
+			memcpy(&VertexData[vertcount+q], &tr.staticVertexData[sv->startVertex+q],sizeof(staticVert_t));
+		}
+		sv->startIndex=indexcount;
+		sv->startVertex=vertcount;
+		
+		indexcount+=sv->numIndices;
+		vertcount+=sv->numVerts;
+
+		leafCount=0;
+		
+		//Medium Settings - Leaf based merge- obeys vis a bit better, questionable benefit.
+		if ( r_ext_vertex_buffer_object->integer == 2 )
+		{
+			//record all the leafs that contain this surface		
+			for (i=0 ; i<tr.world->numnodes ; i++) 
+			{
+				if (tr.world->nodes[i].contents != CONTENTS_SOLID) 
+				{
+					mark = tr.world->nodes[i].firstmarksurface;
+					c =  tr.world->nodes[i].nummarksurfaces;
+					while (c--) 
+					{
+						surf = *mark;
+						if ((void*)surf->data==(void*)sv) 
+						{
+							Leafs[leafCount++]=	&tr.world->nodes[i];	
+							if (leafCount==1023) break;
+						}
+						mark++;
+					}
+				}
+			}
+		}
+		
+
+		//Add any compatible surfaces in as well
+		for (r=0;r<s_worldData.numsurfaces;r++)
+		{
+			
+			if (r==j) continue;
+			
+			if ( !r_ext_vertex_buffer_object->integer || r_ext_vertex_buffer_object->integer == 3 ) 
+				continue; //R_vbo 3 == no merging
+			
+			sc =(void*)s_worldData.surfaces[r].data;
+			if (sc->surfaceType!=SF_STATIC) continue; 
+			if (sc->merged>-1) continue;
+			
+			// model check so we don't gather doors etc
+
+			//if (sc->shader->specularscale!= sv->shader->specularscale) continue;
+			//if (sc->shader->specularpow!=sv->shader->specularpow ) continue;
+			if (sc->modelNum!=sv->modelNum) continue;  
+			
+			//if ( (sc->shader->lightmapIndex==sv->shader->lightmapIndex && sc->shader->stages[0]->bundle[0].image[0]->texnum==sv->shader->stages[0]->bundle[0].image[0]->texnum))
+			//if ( (sc->shader->lightmapIndex==sv->shader->lightmapIndex && sc->shader->stages[0]->bundle[0].image[0]->texnum==sv->shader->stages[0]->bundle[0].image[0]->texnum))
+		
+		//	if ( sc->shader->stages[0]->bundle[0].image[0]->texnum!=sv->shader->stages[0]->bundle[0].image[0]->texnum) continue;
+			
+			if (  sc->shader->nameHash!= sv->shader->nameHash) continue;
+			if ( sc->shader->lightmapIndex!=sv->shader->lightmapIndex ) continue;
+			
+			if (sc->shader->isFancyWater && sc->shader->isFancyWater) continue; //No water merge
+
+			{
+
+				//Do not merge surfaces unless they're shared by a leaf
+				//ie: close to each other
+				if ( r_ext_vertex_buffer_object->integer == 2 )
+				{
+					//if (sc->shader->isFancyWater && sc->shader->isFancyWater)
+					//{
+					//	goto merge;
+					//}
+
+					
+					CanSee=qfalse;
+					for (q=0;q<leafCount;q++)
+					{
+						mark = Leafs[q]->firstmarksurface;
+						c =  Leafs[q]->nummarksurfaces;
+						while (c--) 
+						{
+							surf = *mark;
+							
+							if ((void*)surf->data==(void*)sc ) 
+							{
+								CanSee=qtrue;
+							}
+							mark++;
+							if (CanSee) break;
+						}
+						if (CanSee) break;
+					}
+					
+					if (CanSee==qfalse) 
+						continue;
+				}
+	
+	//merge:
+				//Merge now
+				sv->merged++;
+				sc->merged++;
+				
+				//Add these two surfaces together
+				for (q=0;q<sc->numIndices;q++)
+				{
+					IndexData[indexcount+q]= ( tr.staticIndexData[sc->startIndex+q]-sc->startVertex)+vertcount;
+				}
+				for (q=0;q<sc->numVerts;q++)
+				{
+					memcpy(&VertexData[vertcount+q], &tr.staticVertexData[sc->startVertex+q],sizeof(staticVert_t));
+				}
+				sv->numIndices+=sc->numIndices;
+				sv->numVerts+=sc->numVerts;
+				
+				indexcount+=sc->numIndices;
+				vertcount+=sc->numVerts;
+
+				sc->numIndices=0;
+ 				sc->numVerts=0;
+				//Modify all leafs that pointed at SC to point to SV
+				
+			 	
+				for (i=0 ; i<tr.world->numnodes ; i++) 
+				{
+					if (tr.world->nodes[i].contents != CONTENTS_SOLID) 
+					{
+						mark = tr.world->nodes[i].firstmarksurface;
+						c =  tr.world->nodes[i].nummarksurfaces;
+						while (c--) 
+						{
+							surf = *mark;
+							if ((void*)surf->data==(void*)sc) 
+							{
+								//surf->data=sv;
+								*mark=&s_worldData.surfaces[j];
+							}
+
+							mark++;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	memcpy(tr.staticVertexData,VertexData,sizeof(staticVert_t)*tr.numStaticVertex);
+	memcpy(tr.staticIndexData,IndexData,sizeof(unsigned int)*tr.numStaticIndex);
+
+
+	ri.Hunk_FreeTempMemory(IndexData);
+	ri.Hunk_FreeTempMemory(VertexData);	
+
+
+	//Assign origins now
+ 	for (j=0;j<s_worldData.numsurfaces;j++)
+	{
+		sv =(void*)s_worldData.surfaces[j].data;
+		
+		if (sv->surfaceType!=SF_STATIC) continue; //
+
+		if (sv->numIndices==0 || sv->numVerts==0) continue;
+
+		mins[0]=mins[1]=mins[2]=999999;
+		maxs[0]=maxs[1]=maxs[2]=-999999;
+
+		for (q=0;q<sv->numVerts;q++)
+		{
+			for (i=0;i<3;i++)
+			{
+				if (tr.staticVertexData[sv->startVertex+q].position[i]<mins[i]) mins[i]=tr.staticVertexData[sv->startVertex+q].position[i];
+				if (tr.staticVertexData[sv->startVertex+q].position[i]>maxs[i]) maxs[i]=tr.staticVertexData[sv->startVertex+q].position[i];
+			}
+		}
+		sv->origin[0]=(mins[0]+maxs[0])/2;
+		sv->origin[1]=(mins[1]+maxs[1])/2;
+		sv->origin[2]=(mins[2]+maxs[2])/2;
+
+		surfcount++;
+	}
+	ri.Printf( PRINT_ALL, "R_VBO Surf Count: %d\n",surfcount );	
+}
+
+qboolean CalcTangentVectors(  staticVert_t *dv[3] )
+{
+	int		i;
+	vec3_t		norm;
+
+	vec3_t		face_bi_tangent;
+	vec3_t		face_tangent;
+	vec3_t		facenorm;
+	
+	//calculate face tangents
+	{
+		vec3_t d1;
+		vec3_t d2;
+		
+		float deltaU_0;
+		float deltaU_1;
+		float deltaV_0;
+		float deltaV_1;
+
+		int a,b,c;
+		a=0;
+		b=1;
+		c=2;
+
+		VectorSubtract( dv[b]->position,dv[a]->position,d1);
+		VectorSubtract( dv[c]->position,dv[a]->position,d2);
+
+		//calculate the face normal
+		CrossProduct(d1,d2,facenorm);
+		VectorNormalize(facenorm);
+		facenorm[0]=-facenorm[0];
+		facenorm[1]=-facenorm[1];
+		facenorm[2]=-facenorm[2];
+
+
+		deltaU_0 = dv[b]->uv[0] - dv[a]->uv[0];
+		deltaU_1 = dv[c]->uv[0] - dv[a]->uv[0];
+
+		deltaV_0 = dv[b]->uv[1] - dv[a]->uv[1];
+		deltaV_1 = dv[c]->uv[1] - dv[a]->uv[1];
+
+		//face_tangent =  normalize( delta_V_1 * side_0 - delta_V_0 * side_1 );
+		//face_bi_tangent =  normalize( delta_U_1 * side_0 - delta_U_0 * side_1 );
+		
+		face_tangent[0] =( deltaV_1 * d1[0] - deltaV_0 * d2[0]);
+        face_tangent[1] =( deltaV_1 * d1[1] - deltaV_0 * d2[1]);
+        face_tangent[2] =( deltaV_1 * d1[2] - deltaV_0 * d2[2]);
+
+        face_bi_tangent[0] =( deltaU_1 * d1[0] - deltaU_0 * d2[0]);
+        face_bi_tangent[1] =( deltaU_1 * d1[1] - deltaU_0 * d2[1]);
+        face_bi_tangent[2] =( deltaU_1 * d1[2] - deltaU_0 * d2[2]);
+
+
+		VectorNormalize(face_tangent);
+		VectorNormalize(face_bi_tangent);
+
+
+		//check for opposing tangents
+		CrossProduct(face_tangent,face_bi_tangent,norm);
+		if (DotProduct(norm,facenorm)<0 ) 
+		{
+			//flip
+			face_bi_tangent[0]=-face_bi_tangent[0];
+			face_bi_tangent[1]=-face_bi_tangent[1];
+			face_bi_tangent[2]=-face_bi_tangent[2];
+			face_tangent[0]=-face_tangent[0];
+			face_tangent[1]=-face_tangent[1];
+			face_tangent[2]=-face_tangent[2];
+
+		}
+
+
+	}
+	
+
+	/* do each vertex */
+	for( i = 0; i < 3; i++ )
+	{
+		VectorCopy(face_tangent,dv[i]->stv);
+		VectorCopy(face_bi_tangent,dv[i]->ttv);
+	//	VectorCopy(facenorm,dv[i]->normal);
+	}
+	
+	/* return to caller */
+	return qtrue;
+}
+
+
+static void R_CalculateTangents()
+{
+	staticVert_t* verts[3];
+
+
+	int j;
+	for (j=0;j<tr.numStaticIndex;j+=3)
+	{
+		verts[0]=&tr.staticVertexData[tr.staticIndexData[j+0]];
+		verts[1]=&tr.staticVertexData[tr.staticIndexData[j+1]];
+		verts[2]=&tr.staticVertexData[tr.staticIndexData[j+2]];
+		
+		CalcTangentVectors(verts);
+	} 
+}
+
+
+qboolean R_ParseEntitysForKey(char* classname, char* key, char *storage,int sizeofstore, int num)
+{
+	int stage=-1;
+	
+	char *p;
+	char *s;
+	char *token;
+	char keyname[MAX_TOKEN_CHARS];
+	char value[MAX_TOKEN_CHARS];
+	
+	int brackets;
+	int classtype;
+
+	p=s_worldData.entityString;
+	brackets=0;
+	classtype=0;
+	while ( 1 ) 
+	{	
+		if (brackets==0)
+		{
+			//not inside a class
+			classtype=0;
+		}
+			
+		// parse key
+		token = COM_ParseExt( &p, qtrue );
+		if ( !*token ) break;
+		if (*token == '}') { brackets--; continue; }
+		if (*token == '{') { brackets++; continue; }
+		Q_strncpyz(keyname, token, sizeof(keyname));
+		
+		token = COM_ParseExt( &p, qtrue );
+		if ( !*token ) break;
+		if (*token == '}') { brackets--; continue; }
+		if (*token == '{') { brackets++; continue; }
+		Q_strncpyz(value, token, sizeof(value));
+
+		// check for remapping of shaders for vertex lighting
+		
+		s="classname";
+		if (!Q_strncmp(keyname,s, strlen(s)) ) 
+		{
+			if (!Q_strncmp(value,classname, strlen(classname)) ) 
+			{
+				classtype++;	
+			}
+		}
+		if (!Q_strncmp(keyname, key, strlen(key)) ) 
+		{
+			classtype++;
+			Q_strncpyz(storage, value, sizeofstore);
+		}
+
+		if (classtype==2)
+		{
+			stage++;
+			if (stage<num)
+			{
+				continue;
+			}
+			else
+			{
+				break;
+			}
+
+		}
+	}
+	
+	if (stage<num) 
+	{
+		return qfalse;
+	}
+	return qtrue;
+}
+
+void R_StoreDecalSurf(vec3_t v0,vec3_t v1,vec3_t v2, msurface_t* data)
+{
+	//Store the surface data of a decal surface and the surf it was from for later
+	//We can't just add this directly because the worldnode struct isn't loaded yet
+	vec4_t plane;
+	TempDecalStore[numTempDecalStore].surf=data;
+	TempDecalStore[numTempDecalStore].surfType=SF_DECALSURF;
+	TempDecalStore[numTempDecalStore].viewCount=0;
+	
+	VectorCopy(v0,TempDecalStore[numTempDecalStore].v[0]);
+	VectorCopy(v1,TempDecalStore[numTempDecalStore].v[1]);
+	VectorCopy(v2,TempDecalStore[numTempDecalStore].v[2]);
+
+	PlaneFromPoints(plane,v0,v1,v2);
+	VectorCopy(plane,TempDecalStore[numTempDecalStore].plane.normal);
+	TempDecalStore[numTempDecalStore].plane.dist=plane[3];
+	TempDecalStore[numTempDecalStore].plane.type=3;
+	SetPlaneSignbits(&TempDecalStore[numTempDecalStore].plane);
+	
+	numTempDecalStore++;
+}
+
+
+//Adds a decal surface to a leaf, if the leaf had a reference to the original surface
+//this is incredibly slow.. Ive sped it up as much as I can without prestoring anything.
+//The malloc juggling is designed to keep working scratchpad ram low. Final allocations waste nothing.
+//Todo: This only adds the r_ext_vertex_buffer_object generated surfaces, but really it could accept any tris that need decalling
+//      like tri soups with complex shaders.
+void R_AddDecalSurfs()
+{
+	int i,c;
+	int j;
+	msurface_t **mark;
+	msurface_t *comp;
+
+	mnode_t *leafs[1024];
+	int leafCount = 0;
+	
+	//Copy the temporary list to a final home
+	s_worldData.decalTris = ri.Hunk_Alloc( numTempDecalStore * sizeof(srfSurfaceDecal_t), h_low );
+	s_worldData.numdecalTris = numTempDecalStore;
+	memcpy( s_worldData.decalTris, &TempDecalStore[0], numTempDecalStore * sizeof(srfSurfaceDecal_t) );
+
+	for( i = 0; i < s_worldData.numnodes; i++) 
+	{
+		if( s_worldData.nodes[i].contents != CONTENTS_SOLID ) 
+			s_worldData.nodes[i].numDecalTris = 0;
+	}
+
+	for( j = 0, comp = 0; j < numTempDecalStore; j++ )
+	{
+		// see if we need to calculate a new list of leafs
+		if( comp != TempDecalStore[j].surf )
+		{
+			comp = TempDecalStore[j].surf;
+			for( i = 0, leafCount = 0; i < s_worldData.numnodes; i++) 
+			{
+				if( s_worldData.nodes[i].contents != CONTENTS_SOLID ) 
+				{
+					mark = s_worldData.nodes[i].o_firstmarksurface;
+					c = s_worldData.nodes[i].o_nummarksurfaces;
+		
+					for( ; leafCount < 1024 && c ; c--, mark++ ) 
+						if ( *mark == comp )
+							leafs[leafCount++] = &s_worldData.nodes[i];	
+				}
+			}
+		}
+
+		for( i = 0; i < leafCount; i++)
+			leafs[i]->numDecalTris++;
+		
+	}
+
+	for( i = 0; i < s_worldData.numnodes; i++) 
+	{
+		if( s_worldData.nodes[i].contents != CONTENTS_SOLID ) 
+		{
+			s_worldData.nodes[i].decalTris = (srfSurfaceDecal_t**)
+				ri.Hunk_Alloc( s_worldData.nodes[i].numDecalTris * 
+						sizeof(srfSurfaceDecal_t*), h_low );
+			s_worldData.nodes[i].numDecalTris = 0;
+		}
+	}
+
+	for( j = 0, comp = 0; j < numTempDecalStore; j++ )
+	{
+		// see if we need to calculate a new list of leafs
+		if( comp != TempDecalStore[j].surf )
+		{
+			comp = TempDecalStore[j].surf;
+			for( i = 0, leafCount = 0; i < s_worldData.numnodes; i++) 
+			{
+				if( s_worldData.nodes[i].contents != CONTENTS_SOLID ) 
+				{
+					mark = s_worldData.nodes[i].o_firstmarksurface;
+					c = s_worldData.nodes[i].o_nummarksurfaces;
+					for( ; leafCount < 1024 && c; c--, mark++ ) 
+						if ( *mark == comp )
+							leafs[leafCount++] = &s_worldData.nodes[i];	
+				}
+			}
+		}
+
+		// add this face to every leaf in the list
+		for( i = 0; i < leafCount; i++)
+			leafs[i]->decalTris[leafs[i]->numDecalTris++] = 
+				&s_worldData.decalTris[j];
+	}
+	
+	//ri.Printf( PRINT_WARNING, "r_decal 1 added %dms to loading.\n",time );									
 }
 
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_cmds.c bumpy-code/code/renderer/tr_cmds.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_cmds.c	2014-06-09 22:09:45.527844455 -0400
+++ bumpy-code/code/renderer/tr_cmds.c	2014-06-09 22:14:52.595548728 -0400
@@ -293,6 +293,38 @@
 	cmd->t2 = t2;
 }
 
+#define MODE_RED_CYAN	1
+#define MODE_RED_BLUE	2
+#define MODE_RED_GREEN	3
+#define MODE_MAX	MODE_RED_GREEN
+
+void R_SetColorMode(GLboolean *rgba, stereoFrame_t stereoFrame, int colormode)
+{
+	rgba[0] = rgba[1] = rgba[2] = rgba[3] = GL_TRUE;
+	
+	if(colormode > MODE_MAX)
+	{
+		if(stereoFrame == STEREO_LEFT)
+			stereoFrame = STEREO_RIGHT;
+		else if(stereoFrame == STEREO_RIGHT)
+			stereoFrame = STEREO_LEFT;
+		
+		colormode -= MODE_MAX;
+	}
+	
+	if(stereoFrame == STEREO_LEFT)
+		rgba[1] = rgba[2] = GL_FALSE;
+	else if(stereoFrame == STEREO_RIGHT)
+	{
+		rgba[0] = GL_FALSE;
+		
+		if(colormode == MODE_RED_BLUE)
+			rgba[1] = GL_FALSE;
+		else if(colormode == MODE_RED_GREEN)
+			rgba[2] = GL_FALSE;
+	}
+}
+
 
 /*
 ====================
@@ -303,7 +335,8 @@
 ====================
 */
 void RE_BeginFrame( stereoFrame_t stereoFrame ) {
-	drawBufferCommand_t	*cmd;
+	drawBufferCommand_t	*cmd = NULL;
+	colorMaskCommand_t *colcmd = NULL;
 
 	if ( !tr.registered ) {
 		return;
@@ -371,25 +404,21 @@
 	}
 
     // check for errors
-    if ( !r_ignoreGLErrors->integer ) {
+	if ( !r_ignoreGLErrors->integer )
+	{
         int	err;
 
 		R_SyncRenderThread();
-        if ( ( err = qglGetError() ) != GL_NO_ERROR ) {
+		if ((err = qglGetError()) != GL_NO_ERROR)
             ri.Error( ERR_FATAL, "RE_BeginFrame() - glGetError() failed (0x%x)!\n", err );
         }
-    }
 
-	//
-	// draw buffer stuff
-	//
-	cmd = R_GetCommandBuffer( sizeof( *cmd ) );
-	if ( !cmd ) {
+	if (glConfig.stereoEnabled) {
+		if( !(cmd = R_GetCommandBuffer(sizeof(*cmd))) )
 		return;
-	}
+			
 	cmd->commandId = RC_DRAW_BUFFER;
 
-	if ( glConfig.stereoEnabled ) {
 		if ( stereoFrame == STEREO_LEFT ) {
 			cmd->buffer = (int)GL_BACK_LEFT;
 		} else if ( stereoFrame == STEREO_RIGHT ) {
@@ -397,16 +426,78 @@
 		} else {
 			ri.Error( ERR_FATAL, "RE_BeginFrame: Stereo is enabled, but stereoFrame was %i", stereoFrame );
 		}
-	} else {
-		if ( stereoFrame != STEREO_CENTER ) {
+	}
+	else
+	{
+		if(r_anaglyphMode->integer)
+		{
+			if(r_anaglyphMode->modified)
+			{
+				// clear both, front and backbuffer.
+				qglColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+				qglClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+				
+				qglDrawBuffer(GL_FRONT);
+				qglClear(GL_COLOR_BUFFER_BIT);
+				qglDrawBuffer(GL_BACK);
+				qglClear(GL_COLOR_BUFFER_BIT);
+				
+				r_anaglyphMode->modified = qfalse;
+			}
+			
+			if(stereoFrame == STEREO_LEFT)
+			{
+				if( !(cmd = R_GetCommandBuffer(sizeof(*cmd))) )
+					return;
+				
+				if( !(colcmd = R_GetCommandBuffer(sizeof(*colcmd))) )
+					return;
+			}
+			else if(stereoFrame == STEREO_RIGHT)
+			{
+				clearDepthCommand_t *cldcmd;
+				
+				if( !(cldcmd = R_GetCommandBuffer(sizeof(*cldcmd))) )
+					return;
+
+				cldcmd->commandId = RC_CLEARDEPTH;
+
+				if( !(colcmd = R_GetCommandBuffer(sizeof(*colcmd))) )
+					return;
+			}
+			else
+				ri.Error( ERR_FATAL, "RE_BeginFrame: Stereo is enabled, but stereoFrame was %i", stereoFrame );
+
+			R_SetColorMode(colcmd->rgba, stereoFrame, r_anaglyphMode->integer);
+			colcmd->commandId = RC_COLORMASK;
+		}
+		else
+		{
+			if(stereoFrame != STEREO_CENTER)
 			ri.Error( ERR_FATAL, "RE_BeginFrame: Stereo is disabled, but stereoFrame was %i", stereoFrame );
+
+			if( !(cmd = R_GetCommandBuffer(sizeof(*cmd))) )
+				return;
+		}
+
+		if(cmd)
+		{
+			cmd->commandId = RC_DRAW_BUFFER;
+
+			if(r_anaglyphMode->modified)
+			{
+				qglColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+				r_anaglyphMode->modified = qfalse;
 		}
-		if ( !Q_stricmp( r_drawBuffer->string, "GL_FRONT" ) ) {
+
+			if (!Q_stricmp(r_drawBuffer->string, "GL_FRONT"))
 			cmd->buffer = (int)GL_FRONT;
-		} else {
+			else
 			cmd->buffer = (int)GL_BACK;
 		}
 	}
+	
+	tr.refdef.stereoFrame = stereoFrame;
 }
 
 
@@ -423,11 +514,14 @@
 	if ( !tr.registered ) {
 		return;
 	}
+
+	if ( !(tr.refdef.rdflags & RDF_NODISPLAY) && !tr.viewParms.isWater ) {
 	cmd = R_GetCommandBuffer( sizeof( *cmd ) );
 	if ( !cmd ) {
 		return;
 	}
 	cmd->commandId = RC_SWAP_BUFFERS;
+	}
 
 	R_IssueRenderCommands( qtrue );
 
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_flares.c bumpy-code/code/renderer/tr_flares.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_flares.c	2014-06-09 22:09:45.527844455 -0400
+++ bumpy-code/code/renderer/tr_flares.c	2014-06-09 22:14:52.595548728 -0400
@@ -505,6 +505,10 @@
 		qglDisable (GL_CLIP_PLANE0);
 	}
 
+	if ( backEnd.viewParms.isWater ) {
+		qglDisable (GL_CLIP_PLANE1);
+	}
+
 	qglPushMatrix();
     qglLoadIdentity();
 	qglMatrixMode( GL_PROJECTION );
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_font.c bumpy-code/code/renderer/tr_font.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_font.c	2014-06-09 22:09:45.527844455 -0400
+++ bumpy-code/code/renderer/tr_font.c	2014-06-09 22:14:52.595548728 -0400
@@ -88,7 +88,7 @@
 FT_Library ftLibrary = NULL;  
 #endif
 
-#define MAX_FONTS 6
+#define MAX_FONTS 12
 static int registeredFontCount = 0;
 static fontInfo_t registeredFont[MAX_FONTS];
 
@@ -168,6 +170,25 @@
 		buffer[i+3] = data[i-18+3];		// alpha
 	}
 
+	// Tr3B: flip upside down
+	{
+		int             row;
+		unsigned char  *flip;
+		unsigned char  *src, *dst;
+
+		flip = (unsigned char *)malloc(width * 4);
+		for(row = 0; row < height / 2; row++)
+		{
+			src = buffer + 18 + (row * 4 * width);
+			dst = buffer + 18 + ((height - row - 1) * 4 * width);
+
+			memcpy(flip, src, width * 4);
+			memcpy(src, dst, width * 4);
+			memcpy(dst, flip, width * 4);
+		}
+		free(flip);
+	}
+
 	ri.FS_WriteFile(filename, buffer, c);
 
 	//f = fopen (filename, "wb");
@@ -339,7 +360,8 @@
 #endif
   void *faceData;
 	int i, len;
-  char name[1024];
+	char  name[MAX_QPATH];
+	char  strippedName[MAX_QPATH];
 	float dpi = 72;											//
 	float glyphScale =  72.0f / dpi; 		// change the scale to be relative to 1 based on 72 dpi ( so dpi of 144 means a scale of .5 )
 
@@ -363,7 +385,17 @@
     return;
   }
 
+	COM_StripExtension(fontName, strippedName, sizeof(strippedName));
+    //Compatibility: If there is no extension, assume this is loading one of the legacy fonts
+    if(!Q_stricmp(strippedName, fontName))
+    {
 	Com_sprintf(name, sizeof(name), "fonts/fontImage_%i.dat",pointSize);
+    }
+    else
+    {
+        Com_sprintf(name, sizeof(name), "%s_%i.dat", strippedName, pointSize);
+    }
+
 	for (i = 0; i < registeredFontCount; i++) {
 		if (Q_stricmp(name, registeredFont[i].name) == 0) {
 			Com_Memcpy(font, &registeredFont[i], sizeof(fontInfo_t));
@@ -412,9 +444,11 @@
     return;
   }
 
+  Com_sprintf(name, sizeof(name), "%s", fontName);
+
   len = ri.FS_ReadFile(fontName, &faceData);
   if (len <= 0) {
-    ri.Printf(PRINT_ALL, "RE_RegisterFont: Unable to read font file\n");
+    ri.Printf(PRINT_ALL, "RE_RegisterFont: Unable to read font file %s\n", name);
     return;
   }
 
@@ -454,32 +489,40 @@
   lastStart = i;
   imageNumber = 0;
 
-  while ( i <= GLYPH_END ) {
-
+	while(i <= GLYPH_END)
+	{
     glyph = RE_ConstructGlyphInfo(out, &xOut, &yOut, &maxHeight, face, (unsigned char)i, qfalse);
 
-    if (xOut == -1 || yOut == -1 || i == GLYPH_END)  {
+		if(xOut == -1 || yOut == -1 || i == GLYPH_END)
+		{
+			if(xOut == -1 || yOut == -1)
+			{
+				//ri.Printf(PRINT_WARNING, "RE_RegisterFont: character %c does not fit image number %i\n", (unsigned char) i, imageNumber);
+			}
+
       // ran out of room
       // we need to create an image from the bitmap, set all the handles in the glyphs to this point
-      // 
-
       scaledSize = 256*256;
       newSize = scaledSize * 4;
       imageBuff = Z_Malloc(newSize);
       left = 0;
       max = 0;
       satLevels = 255;
-      for ( k = 0; k < (scaledSize) ; k++ ) {
-        if (max < out[k]) {
+			for(k = 0; k < (scaledSize); k++)
+			{
+				if(max < out[k])
+				{
           max = out[k];
         }
       }
 
-			if (max > 0) {
+			if(max > 0)
+			{
 				max = 255/max;
 			}
 
-      for ( k = 0; k < (scaledSize) ; k++ ) {
+			for(k = 0; k < (scaledSize); k++)
+			{
         imageBuff[left++] = 255;
         imageBuff[left++] = 255;
         imageBuff[left++] = 255;
@@ -487,25 +530,43 @@
         imageBuff[left++] = ((float)out[k] * max);
       }
 
-			Com_sprintf (name, sizeof(name), "fonts/fontImage_%i_%i.tga", imageNumber++, pointSize);
-			if (r_saveFontData->integer) { 
+			Com_sprintf(name, sizeof(name), "%s_%i_%i.tga", strippedName, imageNumber++, pointSize);
+			if(!ri.FS_FileExists(name) && r_saveFontData->integer)  
+			{
 			  WriteTGA(name, imageBuff, 256, 256);
 			}
 
-    	//Com_sprintf (name, sizeof(name), "fonts/fontImage_%i_%i", imageNumber++, pointSize);
-      image = R_CreateImage(name, imageBuff, 256, 256, qfalse, qfalse, GL_CLAMP);
+            /*`image = R_CreateImage(name, imageBuff, 256, 256, IF_NOPICMIP, FT_LINEAR, WT_CLAMP);`*/
+      image = R_CreateImage(name, imageBuff, 256, 256, qfalse, qfalse, GL_CLAMP_TO_EDGE);
+            /*`h = RE_RegisterShaderFromImage(name, image, qfalse);`*/
       h = RE_RegisterShaderFromImage(name, LIGHTMAP_2D, image, qfalse);
-      for (j = lastStart; j < i; j++) {
-        font->glyphs[j].glyph = h;
-				Q_strncpyz(font->glyphs[j].shaderName, name, sizeof(font->glyphs[j].shaderName));
-      }
-      lastStart = i;
+			
 		  Com_Memset(out, 0, 1024*1024);
       xOut = 0;
       yOut = 0;
       Z_Free(imageBuff);
-			i++;
-    } else {
+
+			if(i == GLYPH_END)
+			{
+				for(j = lastStart; j <= GLYPH_END; j++)
+				{
+					font->glyphs[j].glyph = h;
+					Q_strncpyz(font->glyphs[j].shaderName, name, sizeof(font->glyphs[j].shaderName));
+				}
+				break;
+			}
+			else
+			{
+				for(j = lastStart; j < i; j++)
+				{
+					font->glyphs[j].glyph = h;
+					Q_strncpyz(font->glyphs[j].shaderName, name, sizeof(font->glyphs[j].shaderName));
+				}
+				lastStart = i;
+			}
+		}
+		else
+		{
       Com_Memcpy(&font->glyphs[i], glyph, sizeof(glyphInfo_t));
       i++;
     }
@@ -513,10 +574,14 @@
 
 	registeredFont[registeredFontCount].glyphScale = glyphScale;
 	font->glyphScale = glyphScale;
+
+	Com_sprintf(name, sizeof(name), "%s_%i.dat", strippedName, pointSize);
+	Q_strncpyz(font->name, name, sizeof(font->name));
   Com_Memcpy(&registeredFont[registeredFontCount++], font, sizeof(fontInfo_t));
 
-	if (r_saveFontData->integer) { 
-		ri.FS_WriteFile(va("fonts/fontImage_%i.dat", pointSize), font, sizeof(fontInfo_t));
+	if(!ri.FS_FileExists(name) && r_saveFontData->integer) 
+	{
+        ri.FS_WriteFile(name, font, sizeof(fontInfo_t));
 	}
 
   Z_Free(out);
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_image.c bumpy-code/code/renderer/tr_image.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_image.c	2014-06-09 22:09:45.528844448 -0400
+++ bumpy-code/code/renderer/tr_image.c	2014-06-09 22:14:52.599548698 -0400
@@ -129,6 +110,20 @@
 	gl_filter_min = modes[i].minimize;
 	gl_filter_max = modes[i].maximize;
 
+    // bound texture anisotropy
+    
+    if ( textureFilterAnisotropic )
+    {
+        if ( r_ext_texture_filter_anisotropic->value > maxAnisotropy )
+        {
+            ri.Cvar_Set( "r_ext_texture_filter_anisotropic", va( "%d", maxAnisotropy ) );
+        }
+        else if ( r_ext_texture_filter_anisotropic->value < 1.0 )
+        {
+             ri.Cvar_Set ( "r_ext_texture_filter_anisotropic", "1.0" );
+        }
+    }
+    
 	// change all the existing mipmap texture objects
 	for ( i = 0 ; i < tr.numImages ; i++ ) {
 		glt = tr.images[ i ];
@@ -136,6 +131,10 @@
 			GL_Bind (glt);
 			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
 			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
+            
+            // set texture anisotropy
+            if ( textureFilterAnisotropic )
+                qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, r_ext_texture_filter_anisotropic->value );
 		}
 	}
 }
@@ -201,6 +200,7 @@
 			ri.Printf( PRINT_ALL, "RGB8" );
 			break;
 		case GL_RGB4_S3TC:
+		case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
 			ri.Printf( PRINT_ALL, "S3TC " );
 			break;
 		case GL_RGBA4:
@@ -217,7 +217,7 @@
 		case GL_REPEAT:
 			ri.Printf( PRINT_ALL, "rept " );
 			break;
-		case GL_CLAMP:
+		case GL_CLAMP_TO_EDGE:
 			ri.Printf( PRINT_ALL, "clmp " );
 			break;
 		default:
@@ -403,6 +403,40 @@
 	ri.Hunk_FreeTempMemory( temp );
 }
 
+
+/*
+================
+R_NMipMap
+
+Operates in place, quartering the size of the texture
+================
+*/
+static void R_Renormalize (byte *in, int width, int height)
+{
+	int		i, j;
+	int index;
+	vec3_t vec;
+	if (width<2||height<2) return;
+	
+	for (i=0 ; i<height ; i++) 
+	{
+		for (j=0 ; j<width ; j++) 
+		{
+			index=j+(i*width)*4;
+
+			vec[0]=(((float)in[index+0])-127)/127.0f;
+			vec[1]=(((float)in[index+1])-127)/127.0f;
+			vec[2]=(((float)in[index+2])-127)/127.0f;
+			VectorNormalize(vec);
+			
+			in[index+0]=(byte)((vec[0])*127.0)+127;
+			in[index+1]=(byte)((vec[1])*127.0)+127;
+			in[index+2]=(byte)((vec[2])*127.0)+127;
+		}
+	}
+}
+
+
 /*
 ================
 R_MipMap
@@ -410,13 +444,16 @@
 Operates in place, quartering the size of the texture
 ================
 */
-static void R_MipMap (byte *in, int width, int height) {
+static void R_MipMap (byte *in, int width, int height,qboolean normals)
+{
 	int		i, j;
 	byte	*out;
 	int		row;
 
-	if ( !r_simpleMipMaps->integer ) {
+	if ( !r_simpleMipMaps->integer && !normals )
+	{
 		R_MipMap2( (unsigned *)in, width, height );
+		
 		return;
 	}
 
@@ -448,6 +485,12 @@
 			out[3] = (in[3] + in[7] + in[row+3] + in[row+7])>>2;
 		}
 	}
+
+	if (normals==qtrue)
+	{
+		R_Renormalize( out, width, height);
+	}
+
 }
 
 
@@ -508,7 +551,12 @@
 						  qboolean picmip, 
 							qboolean lightMap,
 						  int *format, 
-						  int *pUploadWidth, int *pUploadHeight )
+						  int *pUploadWidth, int *pUploadHeight,
+						  qboolean *hasAlpha,
+						  GLenum texface,
+						  GLenum texformat,
+						  qboolean normals,
+						  qboolean forcealpha)
 {
 	int			samples;
 	unsigned	*scaledBuffer = NULL;
@@ -518,7 +566,7 @@
 	byte		*scan;
 	GLenum		internalFormat = GL_RGB;
 	float		rMax = 0, gMax = 0, bMax = 0;
-
+	int			cappedPicmip=r_picmip->integer;
 	//
 	// convert to exact power of 2 sizes
 	//
@@ -542,9 +590,10 @@
 	//
 	// perform optional picmip operation
 	//
+	if (cappedPicmip>1) cappedPicmip=1;
 	if ( picmip ) {
-		scaled_width >>= r_picmip->integer;
-		scaled_height >>= r_picmip->integer;
+		scaled_width >>= cappedPicmip;
+		scaled_height >>= cappedPicmip;
 	}
 
 	//
@@ -577,7 +626,16 @@
 	c = width*height;
 	scan = ((byte *)data);
 	samples = 3;
-	if (!lightMap) {
+	
+	if(lightMap)
+	{
+		if(r_greyscale->integer)
+			internalFormat = GL_LUMINANCE;
+		else
+			internalFormat = GL_RGB;
+	}
+	else
+	{
 		for ( i = 0; i < c; i++ )
 		{
 			if ( scan[i*4+0] > rMax )
@@ -598,10 +656,34 @@
 				break;
 			}
 		}
+	
+		//If alpha is being used as a data channel it might be all 0's.. so we want to be able to force this
+		if (forcealpha )
+		{
+			samples=4;
+		}
+		
+		
 		// select proper internal format
 		if ( samples == 3 )
 		{
-			if ( glConfig.textureCompression == TC_S3TC )
+			*hasAlpha = qfalse;
+			if(r_greyscale->integer)
+			{
+				if(r_texturebits->integer == 16)
+					internalFormat = GL_LUMINANCE8;
+				else if(r_texturebits->integer == 32)
+					internalFormat = GL_LUMINANCE16;
+				else
+					internalFormat = GL_LUMINANCE;
+			}
+			else
+			{
+				if ( glConfig.textureCompression == TC_S3TC_ARB )
+				{
+					internalFormat = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
+				}
+				else if ( glConfig.textureCompression == TC_S3TC )
 			{
 				internalFormat = GL_RGB4_S3TC;
 			}
@@ -615,11 +697,24 @@
 			}
 			else
 			{
-				internalFormat = 3;
+					internalFormat = GL_RGB;
+				}
 			}
 		}
 		else if ( samples == 4 )
 		{
+			*hasAlpha = qtrue;
+			if(r_greyscale->integer)
+			{
+				if(r_texturebits->integer == 16)
+					internalFormat = GL_LUMINANCE8_ALPHA8;
+				else if(r_texturebits->integer == 32)
+					internalFormat = GL_LUMINANCE16_ALPHA16;
+				else
+					internalFormat = GL_LUMINANCE_ALPHA;
+			}
+			else
+			{
 			if ( r_texturebits->integer == 16 )
 			{
 				internalFormat = GL_RGBA4;
@@ -630,12 +725,12 @@
 			}
 			else
 			{
-				internalFormat = 4;
+					internalFormat = GL_RGBA;
+				}
 			}
 		}
-	} else {
-		internalFormat = 3;
 	}
+
 	// copy or resample data as appropriate for first MIP level
 	if ( ( scaled_width == width ) && 
 		( scaled_height == height ) ) {
@@ -641,7 +736,7 @@
 		( scaled_height == height ) ) {
 		if (!mipmap)
 		{
-			qglTexImage2D (GL_TEXTURE_2D, 0, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
+			qglTexImage2D (texface, 0, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
 			*pUploadWidth = scaled_width;
 			*pUploadHeight = scaled_height;
 			*format = internalFormat;
@@ -654,7 +749,7 @@
 	{
 		// use the normal mip-mapping function to go down from here
 		while ( width > scaled_width || height > scaled_height ) {
-			R_MipMap( (byte *)data, width, height );
+			R_MipMap( (byte *)data, width, height ,normals);
 			width >>= 1;
 			height >>= 1;
 			if ( width < 1 ) {
@@ -667,13 +762,14 @@
 		Com_Memcpy( scaledBuffer, data, width * height * 4 );
 	}
 
-	R_LightScaleTexture (scaledBuffer, scaled_width, scaled_height, !mipmap );
+	//Geeze don't do this.  Hardware should be getting the texture we sent it unmodified. Its 2010 now!
+	//R_LightScaleTexture (scaledBuffer, scaled_width, scaled_height, !mipmap );
 
 	*pUploadWidth = scaled_width;
 	*pUploadHeight = scaled_height;
 	*format = internalFormat;
 
-	qglTexImage2D (GL_TEXTURE_2D, 0, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
+	qglTexImage2D (texface, 0, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
 
 	if (mipmap)
 	{
@@ -682,7 +778,7 @@
 		miplevel = 0;
 		while (scaled_width > 1 || scaled_height > 1)
 		{
-			R_MipMap( (byte *)scaledBuffer, scaled_width, scaled_height );
+			R_MipMap( (byte *)scaledBuffer, scaled_width, scaled_height,normals );
 			scaled_width >>= 1;
 			scaled_height >>= 1;
 			if (scaled_width < 1)
@@ -695,7 +791,7 @@
 				R_BlendOverTexture( (byte *)scaledBuffer, scaled_width * scaled_height, mipBlendColors[miplevel] );
 			}
 
-			qglTexImage2D (GL_TEXTURE_2D, miplevel, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
+			qglTexImage2D (texface, miplevel, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
 		}
 	}
 done:
@@ -703,19 +799,19 @@
 	if (mipmap)
 	{
 		if ( textureFilterAnisotropic )
-			qglTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT,
+			qglTexParameteri( texformat, GL_TEXTURE_MAX_ANISOTROPY_EXT,
 					(GLint)Com_Clamp( 1, maxAnisotropy, r_ext_max_anisotropy->integer ) );
 
-		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
-		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
+		qglTexParameterf(texformat, GL_TEXTURE_MIN_FILTER, gl_filter_min);
+		qglTexParameterf(texformat, GL_TEXTURE_MAG_FILTER, gl_filter_max);
 	}
 	else
 	{
 		if ( textureFilterAnisotropic )
-			qglTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 1 );
+			qglTexParameteri( texformat, GL_TEXTURE_MAX_ANISOTROPY_EXT, 1 );
 
-		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
-		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
+		qglTexParameterf(texformat, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
+		qglTexParameterf(texformat, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
 	}
 
 	GL_CheckErrors();
@@ -735,25 +831,35 @@
 ================
 */
 image_t *R_CreateImage( const char *name, const byte *pic, int width, int height, 
-					   qboolean mipmap, qboolean allowPicmip, int glWrapClampMode ) {
+					   qboolean mipmap, qboolean allowPicmip, int glWrapClampMode,qboolean normals, qboolean forcealpha ) {
 	image_t		*image;
 	qboolean	isLightmap = qfalse;
 	long		hash;
 
-	if (strlen(name) >= MAX_QPATH ) {
+	if (strlen(name) >= MAX_QPATH ) 
+	{
+			
 		ri.Error (ERR_DROP, "R_CreateImage: \"%s\" is too long\n", name);
 	}
 	if ( !strncmp( name, "*lightmap", 9 ) ) {
 		isLightmap = qtrue;
 	}
+	if ( !strncmp( name, "*fatmap", 7 ) ) {
+		isLightmap = qtrue;
+	}
+	if ( !strncmp( name, "*radmap", 7 ) ) {
+		isLightmap = qtrue;
+	}
 
 	if ( tr.numImages == MAX_DRAWIMAGES ) {
 		ri.Error( ERR_DROP, "R_CreateImage: MAX_DRAWIMAGES hit\n");
 	}
 
 	image = tr.images[tr.numImages] = ri.Hunk_Alloc( sizeof( image_t ), h_low );
-	image->texnum = 1024 + tr.numImages;
+	
+	image->texnum = tr.imagesIndex;
 	tr.numImages++;
+	tr.imagesIndex++;
 
 	image->mipmap = mipmap;
 	image->allowPicmip = allowPicmip;
@@ -777,13 +883,21 @@
 
 	GL_Bind(image);
 
+	GL_CheckErrors();
+
 	Upload32( (unsigned *)pic, image->width, image->height, 
 								image->mipmap,
 								allowPicmip,
 								isLightmap,
 								&image->internalFormat,
 								&image->uploadWidth,
-								&image->uploadHeight );
+								&image->uploadHeight,
+								&image->hasAlpha,
+								GL_TEXTURE_2D,
+								GL_TEXTURE_2D,
+								normals,
+								forcealpha
+								);
 
 	qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, glWrapClampMode );
 	qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, glWrapClampMode );
@@ -801,3577 +915,514 @@
 	return image;
 }
 
+//Except of course, for this
 
-/*
-=========================================================
+image_t *R_CreateCubeImage( const char *name, const byte *pic, int width, int height, 
+					   qboolean mipmap, qboolean allowPicmip, int glWrapClampMode,int CubemapFace, image_t *cubemapParent ) {
+	image_t		*image;
+	qboolean	isLightmap = qfalse;
+	long		hash;
+	GLenum		texformat;
+	GLenum		texface;
+	int			cubemapnum = 0;
+	int		i;
 
-BMP LOADING
 
-=========================================================
-*/
-typedef struct
-{
-	char id[2];
-	unsigned long fileSize;
-	unsigned long reserved0;
-	unsigned long bitmapDataOffset;
-	unsigned long bitmapHeaderSize;
-	unsigned long width;
-	unsigned long height;
-	unsigned short planes;
-	unsigned short bitsPerPixel;
-	unsigned long compression;
-	unsigned long bitmapDataSize;
-	unsigned long hRes;
-	unsigned long vRes;
-	unsigned long colors;
-	unsigned long importantColors;
-	unsigned char palette[256][4];
-} BMPHeader_t;
 
-static void LoadBMP( const char *name, byte **pic, int *width, int *height )
+	//first face, no image created yet
+	if (CubemapFace>0)
 {
-	int		columns, rows;
-	unsigned	numPixels;
-	byte	*pixbuf;
-	int		row, column;
-	byte	*buf_p;
-	byte	*buffer;
-	int		length;
-	BMPHeader_t bmpHeader;
-	byte		*bmpRGBA;
+		if (!cubemapParent) { cubemapnum=0; }  else { cubemapnum=CubemapFace;	}
+		texformat=GL_TEXTURE_CUBE_MAP;							//name for other texture functions
+		texface  =GL_TEXTURE_CUBE_MAP_POSITIVE_X +cubemapnum;   //name for glteximage2d
+	}
+	else
+	{
+		texformat=GL_TEXTURE_2D; //texturemode
+		texface  =GL_TEXTURE_2D; //cubemap face
 
-	*pic = NULL;
+	}
 
-	//
-	// load the file
-	//
-	length = ri.FS_ReadFile( ( char * ) name, (void **)&buffer);
-	if (!buffer) {
-		return;
+	if (strlen(name) >= MAX_QPATH ) {
+		ri.Error (ERR_DROP, "R_CreateImage: \"%s\" is too long\n", name);
+	}
+	if ( !strncmp( name, "*lightmap", 9 ) ) {
+		isLightmap = qtrue;
 	}
 
-	buf_p = buffer;
+	if ( tr.numImages == MAX_DRAWIMAGES ) {
+		ri.Error( ERR_DROP, "R_CreateImage: MAX_DRAWIMAGES hit\n");
+	}
+
+	
+	if (!cubemapParent)
+	{
+		image = tr.images[tr.numImages] = ri.Hunk_Alloc( sizeof( image_t ), h_low );
+		image->texnum = tr.imagesIndex;
+		tr.numImages++;
+		tr.imagesIndex++;
 
-	bmpHeader.id[0] = *buf_p++;
-	bmpHeader.id[1] = *buf_p++;
-	bmpHeader.fileSize = LittleLong( * ( long * ) buf_p );
-	buf_p += 4;
-	bmpHeader.reserved0 = LittleLong( * ( long * ) buf_p );
-	buf_p += 4;
-	bmpHeader.bitmapDataOffset = LittleLong( * ( long * ) buf_p );
-	buf_p += 4;
-	bmpHeader.bitmapHeaderSize = LittleLong( * ( long * ) buf_p );
-	buf_p += 4;
-	bmpHeader.width = LittleLong( * ( long * ) buf_p );
-	buf_p += 4;
-	bmpHeader.height = LittleLong( * ( long * ) buf_p );
-	buf_p += 4;
-	bmpHeader.planes = LittleShort( * ( short * ) buf_p );
-	buf_p += 2;
-	bmpHeader.bitsPerPixel = LittleShort( * ( short * ) buf_p );
-	buf_p += 2;
-	bmpHeader.compression = LittleLong( * ( long * ) buf_p );
-	buf_p += 4;
-	bmpHeader.bitmapDataSize = LittleLong( * ( long * ) buf_p );
-	buf_p += 4;
-	bmpHeader.hRes = LittleLong( * ( long * ) buf_p );
-	buf_p += 4;
-	bmpHeader.vRes = LittleLong( * ( long * ) buf_p );
-	buf_p += 4;
-	bmpHeader.colors = LittleLong( * ( long * ) buf_p );
-	buf_p += 4;
-	bmpHeader.importantColors = LittleLong( * ( long * ) buf_p );
-	buf_p += 4;
+		image->mipmap = mipmap;
+		image->allowPicmip = allowPicmip;
 
-	Com_Memcpy( bmpHeader.palette, buf_p, sizeof( bmpHeader.palette ) );
+		strcpy (image->imgName, name);
 
-	if ( bmpHeader.bitsPerPixel == 8 )
-		buf_p += 1024;
+		image->width = width;
+		image->height = height;
+		image->wrapClampMode = glWrapClampMode;
 
-	if ( bmpHeader.id[0] != 'B' && bmpHeader.id[1] != 'M' ) 
-	{
-		ri.Error( ERR_DROP, "LoadBMP: only Windows-style BMP files supported (%s)\n", name );
+		// lightmaps are always allocated on TMU 1
+		if ( qglActiveTextureARB && isLightmap ) {
+			image->TMU = 1;
+		} else {
+			image->TMU = 0;
 	}
-	if ( bmpHeader.fileSize != length )
+		
+
+		if (CubemapFace>0)
 	{
-		ri.Error( ERR_DROP, "LoadBMP: header size does not match file size (%d vs. %d) (%s)\n", bmpHeader.fileSize, length, name );
+			qglBindTexture (texformat, image->texnum ); //cubemap 0
+			i=qglGetError();
 	}
-	if ( bmpHeader.compression != 0 )
+		else
 	{
-		ri.Error( ERR_DROP, "LoadBMP: only uncompressed BMP files supported (%s)\n", name );
-	}
-	if ( bmpHeader.bitsPerPixel < 8 )
+			if ( qglActiveTextureARB ) 
 	{
-		ri.Error( ERR_DROP, "LoadBMP: monochrome and 4-bit BMP files not supported (%s)\n", name );
+				GL_SelectTexture( image->TMU );
 	}
 
-	columns = bmpHeader.width;
-	rows = bmpHeader.height;
-	if ( rows < 0 )
-		rows = -rows;
-	numPixels = columns * rows;
-
-	if(columns <= 0 || !rows || numPixels > 0x1FFFFFFF // 4*1FFFFFFF == 0x7FFFFFFC < 0x7FFFFFFF
-	    || ((numPixels * 4) / columns) / 4 != rows)
+			GL_Bind(image);
+		}
+	}
+	else
 	{
-	  ri.Error (ERR_DROP, "LoadBMP: %s has an invalid image size\n", name);
+		image=cubemapParent;
+		image->cubemap=qtrue;
+		image->cubemap_faces[cubemapnum-1]=tr.imagesIndex;
+		tr.imagesIndex++;
+		//qglBindTexture (texformat,image->texnum );  //cubemap 1-5
 	}
 
-	if ( width ) 
-		*width = columns;
-	if ( height )
-		*height = rows;
 
-	bmpRGBA = ri.Malloc( numPixels * 4 );
-	*pic = bmpRGBA;
+
+	Upload32( (unsigned *)pic, image->width, image->height, 
+								image->mipmap,
+								allowPicmip,
+								isLightmap,
+								&image->internalFormat,
+								&image->uploadWidth,
+								&image->uploadHeight,
+								&image->hasAlpha,
+								texface, texformat,qfalse,qtrue );
+
+	qglTexParameterf( texformat, GL_TEXTURE_WRAP_S, glWrapClampMode );
+	qglTexParameterf( texformat, GL_TEXTURE_WRAP_T, glWrapClampMode );
 
 
-	for ( row = rows-1; row >= 0; row-- )
-	{
-		pixbuf = bmpRGBA + row*columns*4;
 
-		for ( column = 0; column < columns; column++ )
+	if (CubemapFace==0 || CubemapFace==5 ) //final cleanup
 		{
-			unsigned char red, green, blue, alpha;
-			int palIndex;
-			unsigned short shortPixel;
-
-			switch ( bmpHeader.bitsPerPixel )
-			{
-			case 8:
-				palIndex = *buf_p++;
-				*pixbuf++ = bmpHeader.palette[palIndex][2];
-				*pixbuf++ = bmpHeader.palette[palIndex][1];
-				*pixbuf++ = bmpHeader.palette[palIndex][0];
-				*pixbuf++ = 0xff;
-				break;
-			case 16:
-				shortPixel = * ( unsigned short * ) pixbuf;
-				pixbuf += 2;
-				*pixbuf++ = ( shortPixel & ( 31 << 10 ) ) >> 7;
-				*pixbuf++ = ( shortPixel & ( 31 << 5 ) ) >> 2;
-				*pixbuf++ = ( shortPixel & ( 31 ) ) << 3;
-				*pixbuf++ = 0xff;
-				break;
-
-			case 24:
-				blue = *buf_p++;
-				green = *buf_p++;
-				red = *buf_p++;
-				*pixbuf++ = red;
-				*pixbuf++ = green;
-				*pixbuf++ = blue;
-				*pixbuf++ = 255;
-				break;
-			case 32:
-				blue = *buf_p++;
-				green = *buf_p++;
-				red = *buf_p++;
-				alpha = *buf_p++;
-				*pixbuf++ = red;
-				*pixbuf++ = green;
-				*pixbuf++ = blue;
-				*pixbuf++ = alpha;
-				break;
-			default:
-				ri.Error( ERR_DROP, "LoadBMP: illegal pixel_size '%d' in file '%s'\n", bmpHeader.bitsPerPixel, name );
-				break;
+		qglBindTexture( texformat, 0 );
+		if ( image->TMU == 1 ) 
+		{
+			GL_SelectTexture( 0 );
 			}
 		}
+	
+	if (!cubemapParent)
+	{
+		hash = generateHashValue(name);
+		image->next = hashTable[hash];
+		hashTable[hash] = image;
 	}
 
-	ri.FS_FreeFile( buffer );
 
-}
+	return image;
 
+}
 
-/*
-=================================================================
+/****************************
+RGB GET/SET
+****************************/
 
-PCX LOADING
+//RED
+static byte getImageR(byte *targa_rgba, int x, int y, int columns, int rows)
+{
+	byte	*pixbuf;
 
-=================================================================
-*/
+	x*=((x<0)?-1:1);
+	y*=((y<0)?-1:1);
+  if(rows<=y)
+		y=y%rows;
+  if(columns<=x)
+		x=x%columns;
+	x*=((x<0)?-1:1);
+	y*=((y<0)?-1:1);
 
 
-/*
-==============
-LoadPCX
-==============
-*/
-static void LoadPCX ( const char *filename, byte **pic, byte **palette, int *width, int *height)
-{
-	byte	*raw;
-	pcx_t	*pcx;
-	int		x, y;
-	int		len;
-	int		dataByte, runLength;
-	byte	*out, *pix;
-	unsigned		xmax, ymax;
+	pixbuf = targa_rgba + y*columns*4;
 
-	*pic = NULL;
-	*palette = NULL;
+	pixbuf+=(x*4);
 
-	//
-	// load the file
-	//
-	len = ri.FS_ReadFile( ( char * ) filename, (void **)&raw);
-	if (!raw) {
-		return;
+	return *pixbuf;
 	}
 
-	//
-	// parse the PCX file
-	//
-	pcx = (pcx_t *)raw;
-	raw = &pcx->data;
+static void setImageR(byte *targa_rgba, int x, int y, int columns, int rows, byte value)
+{
+	byte	*pixbuf;
 
-  	xmax = LittleShort(pcx->xmax);
-    ymax = LittleShort(pcx->ymax);
+	x*=((x<0)?-1:1);
+	y*=((y<0)?-1:1);
 
-	if (pcx->manufacturer != 0x0a
-		|| pcx->version != 5
-		|| pcx->encoding != 1
-		|| pcx->bits_per_pixel != 8
-		|| xmax >= 1024
-		|| ymax >= 1024)
-	{
-		ri.Printf (PRINT_ALL, "Bad pcx file %s (%i x %i) (%i x %i)\n", filename, xmax+1, ymax+1, pcx->xmax, pcx->ymax);
-		return;
+	pixbuf = targa_rgba + y*columns*4;
+	
+	pixbuf+=(x*4);
+	
+	*pixbuf=value;
 	}
+//GREEN
+static byte getImageG(byte *targa_rgba, int x, int y, int columns, int rows)
+{
+	byte	*pixbuf;
 
-	out = ri.Malloc ( (ymax+1) * (xmax+1) );
+	x*=((x<0)?-1:1);
+	y*=((y<0)?-1:1);
+  if(rows<=y)
+		y=y%rows;
+  if(columns<=x)
+		x=x%columns;
+	x*=((x<0)?-1:1);
+	y*=((y<0)?-1:1);
 
-	*pic = out;
+	pixbuf = targa_rgba + y*columns*4;
 
-	pix = out;
+	pixbuf+=(x*4);
 
-	if (palette)
-	{
-		*palette = ri.Malloc(768);
-		Com_Memcpy (*palette, (byte *)pcx + len - 768, 768);
+	pixbuf++;
+	return *pixbuf;
 	}
 
-	if (width)
-		*width = xmax+1;
-	if (height)
-		*height = ymax+1;
-// FIXME: use bytes_per_line here?
-
-	for (y=0 ; y<=ymax ; y++, pix += xmax+1)
+static void setImageG(byte *targa_rgba, int x, int y, int columns, int rows, byte value)
 	{
-		for (x=0 ; x<=xmax ; )
-		{
-			dataByte = *raw++;
+	byte	*pixbuf;
 
-			if((dataByte & 0xC0) == 0xC0)
-			{
-				runLength = dataByte & 0x3F;
-				dataByte = *raw++;
-			}
-			else
-				runLength = 1;
+	x*=((x<0)?-1:1);
+	y*=((y<0)?-1:1);
 
-			while(runLength-- > 0)
-				pix[x++] = dataByte;
-		}
+	pixbuf = targa_rgba + y*columns*4;
 
+	pixbuf+=(x*4);
+	pixbuf++;
+	*pixbuf=value;
 	}
-
-	if ( raw - (byte *)pcx > len)
+//BLUE
+static byte getImageB(byte *targa_rgba, int x, int y, int columns, int rows)
 	{
-		ri.Printf (PRINT_DEVELOPER, "PCX file %s was malformed", filename);
-		ri.Free (*pic);
-		*pic = NULL;
-	}
+	byte	*pixbuf;
+	
+	x*=((x<0)?-1:1);
+	y*=((y<0)?-1:1);
+  if(rows<=y)
+		y=y%rows;
+  if(columns<=x)
+		x=x%columns;
+	x*=((x<0)?-1:1);
+	y*=((y<0)?-1:1);
+	
+	pixbuf = targa_rgba + y*columns*4;
 
-	ri.FS_FreeFile (pcx);
+	pixbuf+=(x*4);
+	pixbuf+=2;
+	return *pixbuf;
 }
 
+static void setImageB(byte *targa_rgba, int x, int y, int columns, int rows, byte value)
+{
+	byte	*pixbuf;
 
-/*
-==============
-LoadPCX32
-==============
-*/
-static void LoadPCX32 ( const char *filename, byte **pic, int *width, int *height) {
-	byte	*palette;
-	byte	*pic8;
-	int		i, c, p;
-	byte	*pic32;
+	x*=((x<0)?-1:1);
+	y*=((y<0)?-1:1);
 
-	LoadPCX (filename, &pic8, &palette, width, height);
-	if (!pic8) {
-		*pic = NULL;
-		return;
-	}
+	pixbuf = targa_rgba + y*columns*4;
 
-	// LoadPCX32 ensures width, height < 1024
-	c = (*width) * (*height);
-	pic32 = *pic = ri.Malloc(4 * c );
-	for (i = 0 ; i < c ; i++) {
-		p = pic8[i];
-		pic32[0] = palette[p*3];
-		pic32[1] = palette[p*3 + 1];
-		pic32[2] = palette[p*3 + 2];
-		pic32[3] = 255;
-		pic32 += 4;
+	pixbuf+=(x*4);
+	pixbuf+=2;
+	*pixbuf=value;
 	}
 
-	ri.Free (pic8);
-	ri.Free (palette);
+//RGB
+static void getImageRGB(byte *targa_rgba, int x, int y, int columns, int rows, vec3_t rgb)
+{
+	byte	*pixbuf;
+	
+	x*=((x<0)?-1:1);
+	y*=((y<0)?-1:1);
+  //if(rows<=y)
+	y=y%rows;
+  //if(columns<=x)
+	x=x%columns;
+	//x*=((x<0)?-1:1);
+	//y*=((y<0)?-1:1);
+	
+	pixbuf = targa_rgba + y*columns*4 + x*4;
+	
+	rgb[0]=*pixbuf;
+	rgb[1]=*(pixbuf+1);
+	rgb[2]=*(pixbuf+2);
 }
 
-/*
-=========================================================
+static void setImageRGB(byte *targa_rgba, int x, int y, int columns, int rows, vec3_t rgb)
+{
+	byte	*pixbuf;
 
-TARGA LOADING
+	//x*=((x<0)?-1:1);
+	//y*=((y<0)?-1:1);
 
-=========================================================
-*/
+	pixbuf = targa_rgba + y*columns*4 + (x*4);
 
-/*
-=============
-LoadTGA
-=============
-*/
-static void LoadTGA ( const char *name, byte **pic, int *width, int *height)
+	*pixbuf=(byte)(rgb[0]);
+	*(pixbuf+1)=(byte)(rgb[1]);
+	*(pixbuf+2)=(byte)(rgb[2]);
+}
+
+/****************************
+NO BRAINER'S BLUR
+****************************/
+static void blur(int columns, int rows, byte *targa_rgba)
 {
-	unsigned	columns, rows, numPixels;
-	byte	*pixbuf;
 	int		row, column;
-	byte	*buf_p;
-	byte	*buffer;
-	TargaHeader	targa_header;
-	byte		*targa_rgba;
+	float sum;
 
-	*pic = NULL;
 
-	//
-	// load the file
-	//
-	ri.FS_ReadFile ( ( char * ) name, (void **)&buffer);
-	if (!buffer) {
-		return;
-	}
+		for(row=0; row<rows; row++) 
+		{
+			//pixbuf = targa_rgba + row*columns*4;
+			for(column=0; column<columns; column++) 
+			{
+				sum=0;
+				sum+=getImageR(targa_rgba,column-1,row-1,columns,rows);
+				sum+=getImageR(targa_rgba,column,row-1,columns,rows);
+				sum+=getImageR(targa_rgba,column+1,row-1,columns,rows);
+				sum+=getImageR(targa_rgba,column-1,row,columns,rows);
+				sum+=getImageR(targa_rgba,column,row,columns,rows);
+				sum+=getImageR(targa_rgba,column+1,row,columns,rows);
+				sum+=getImageR(targa_rgba,column-1,row+1,columns,rows);
+				sum+=getImageR(targa_rgba,column,row+1,columns,rows);
+				sum+=getImageR(targa_rgba,column+1,row+1,columns,rows);
+				
+				sum/=9.0f;
 
-	buf_p = buffer;
+				setImageR(targa_rgba, column, row, columns, rows, (byte)sum);
+				////////////////////
+				sum=0;
+				sum+=getImageG(targa_rgba,column-1,row-1,columns,rows);
+				sum+=getImageG(targa_rgba,column,row-1,columns,rows);
+				sum+=getImageG(targa_rgba,column+1,row-1,columns,rows);
+				sum+=getImageG(targa_rgba,column-1,row,columns,rows);
+				sum+=getImageG(targa_rgba,column,row,columns,rows);
+				sum+=getImageG(targa_rgba,column+1,row,columns,rows);
+				sum+=getImageG(targa_rgba,column-1,row+1,columns,rows);
+				sum+=getImageG(targa_rgba,column,row+1,columns,rows);
+				sum+=getImageG(targa_rgba,column+1,row+1,columns,rows);
 
-	targa_header.id_length = buf_p[0];
-	targa_header.colormap_type = buf_p[1];
-	targa_header.image_type = buf_p[2];
+				sum/=9.0f;
 	
-	memcpy(&targa_header.colormap_index, &buf_p[3], 2);
-	memcpy(&targa_header.colormap_length, &buf_p[5], 2);
-	targa_header.colormap_size = buf_p[7];
-	memcpy(&targa_header.x_origin, &buf_p[8], 2);
-	memcpy(&targa_header.y_origin, &buf_p[10], 2);
-	memcpy(&targa_header.width, &buf_p[12], 2);
-	memcpy(&targa_header.height, &buf_p[14], 2);
-	targa_header.pixel_size = buf_p[16];
-	targa_header.attributes = buf_p[17];
+				setImageG(targa_rgba, column, row, columns, rows, (byte)sum);
+				////////////////////////
+				sum=0;
+				sum+=getImageB(targa_rgba,column-1,row-1,columns,rows);
+				sum+=getImageB(targa_rgba,column,row-1,columns,rows);
+				sum+=getImageB(targa_rgba,column+1,row-1,columns,rows);
+				sum+=getImageB(targa_rgba,column-1,row,columns,rows);
+				sum+=getImageB(targa_rgba,column,row,columns,rows);
+				sum+=getImageB(targa_rgba,column+1,row,columns,rows);
+				sum+=getImageB(targa_rgba,column-1,row+1,columns,rows);
+				sum+=getImageB(targa_rgba,column,row+1,columns,rows);
+				sum+=getImageB(targa_rgba,column+1,row+1,columns,rows);
 
-	targa_header.colormap_index = LittleShort(targa_header.colormap_index);
-	targa_header.colormap_length = LittleShort(targa_header.colormap_length);
-	targa_header.x_origin = LittleShort(targa_header.x_origin);
-	targa_header.y_origin = LittleShort(targa_header.y_origin);
-	targa_header.width = LittleShort(targa_header.width);
-	targa_header.height = LittleShort(targa_header.height);
+				sum/=9.0f;
 
-	buf_p += 18;
+				setImageB(targa_rgba, column, row, columns, rows, (byte)sum);
 
-	if (targa_header.image_type!=2 
-		&& targa_header.image_type!=10
-		&& targa_header.image_type != 3 ) 
+				// "halftoning"
+				/*if((row%5==0)&&(column%5==1))
 	{
-		ri.Error (ERR_DROP, "LoadTGA: Only type 2 (RGB), 3 (gray), and 10 (RGB) TGA images supported\n");
+					gris=0;
+					gris+=red;
+					gris+=green;
+					gris+=blue;
+					gris/=3;
+					
+					gris=255-gris;
+					if(gris<0)
+						gris=0;
+						
+						setImageR(targa_rgba, column, row, columns, rows, (byte)gris);
+						setImageG(targa_rgba, column, row, columns, rows, (byte)gris);
+						setImageB(targa_rgba, column, row, columns, rows, (byte)gris);
+					
+				}*/
+			
+			}
 	}
 
-	if ( targa_header.colormap_type != 0 )
-	{
-		ri.Error( ERR_DROP, "LoadTGA: colormaps not supported\n" );
 	}
 
-	if ( ( targa_header.pixel_size != 32 && targa_header.pixel_size != 24 ) && targa_header.image_type != 3 )
-	{
-		ri.Error (ERR_DROP, "LoadTGA: Only 32 or 24 bit images supported (no colormaps)\n");
+int diffSquare(int mean, int val){
+	float variance = (val-mean)/255.0f;
+	float radius = mean<128?mean:255-mean;
+	return mean+(radius*variance);
 	}
 
-	columns = targa_header.width;
-	rows = targa_header.height;
-	numPixels = columns * rows * 4;
+/****************************
+KUWAHARA ,FAILS SOMEWHERE
+****************************/
+#define KWH_RADIUS 2
+static void mean_variance(int x0, int y0, int x1, int y1, int columns, int rows, byte *targa_rgba, vec4_t mv )
+{
+	short min=255*3, max=0;
+	unsigned short count= 0;
+	short row, column;
+	unsigned short value;
+	vec3_t rgb;
 
-	if (width)
-		*width = columns;
-	if (height)
-		*height = rows;
+	mv[0]=mv[1]=mv[2]=mv[3]=0;
 
-	if(!columns || !rows || numPixels > 0x7FFFFFFF || numPixels / columns / 4 != rows)
+	for(row=y0;row<=y1;row++)
 	{
-		ri.Error (ERR_DROP, "LoadTGA: %s has an invalid image size\n", name);
+		for(column=x0;column<=x1;column++)
+		{
+			getImageRGB(targa_rgba,column,row,columns,rows,rgb);
+			
+			VectorAdd(mv,rgb,mv);
+			
+			count++;
+			value=rgb[0]+rgb[1]+rgb[2];
+			if(value<min) min=value;
+			if(value>max) max=value;
+		}
 	}
 
-	targa_rgba = ri.Malloc (numPixels);
-	*pic = targa_rgba;
+	mv[0]/=count;
+	mv[1]/=count;
+	mv[2]/=count;
+	mv[3]= (max-min)/3.0f;
+}
 
-	if (targa_header.id_length != 0)
-		buf_p += targa_header.id_length;  // skip TARGA image comment
 	
-	if ( targa_header.image_type==2 || targa_header.image_type == 3 )
-	{ 
-		// Uncompressed RGB or gray scale image
-		for(row=rows-1; row>=0; row--) 
+static void rgb_kuwahara(int x, int y, int columns, int rows, byte *targa_rgba, vec4_t bmv)
 		{
-			pixbuf = targa_rgba + row*columns*4;
-			for(column=0; column<columns; column++) 
+  vec4_t mv;
+	bmv[0]=bmv[1]=bmv[2]=bmv[3]=255;
+	
+	mean_variance(x-KWH_RADIUS, y-KWH_RADIUS, x, y, columns, rows, targa_rgba, mv);
+	if( mv[3] < bmv[3] )
 			{
-				unsigned char red,green,blue,alphabyte;
-				switch (targa_header.pixel_size) 
-				{
-					
-				case 8:
-					blue = *buf_p++;
-					green = blue;
-					red = blue;
-					*pixbuf++ = red;
-					*pixbuf++ = green;
-					*pixbuf++ = blue;
-					*pixbuf++ = 255;
-					break;
-
-				case 24:
-					blue = *buf_p++;
-					green = *buf_p++;
-					red = *buf_p++;
-					*pixbuf++ = red;
-					*pixbuf++ = green;
-					*pixbuf++ = blue;
-					*pixbuf++ = 255;
-					break;
-				case 32:
-					blue = *buf_p++;
-					green = *buf_p++;
-					red = *buf_p++;
-					alphabyte = *buf_p++;
-					*pixbuf++ = red;
-					*pixbuf++ = green;
-					*pixbuf++ = blue;
-					*pixbuf++ = alphabyte;
-					break;
-				default:
-					ri.Error( ERR_DROP, "LoadTGA: illegal pixel_size '%d' in file '%s'\n", targa_header.pixel_size, name );
-					break;
-				}
-			}
-		}
-	}
-	else if (targa_header.image_type==10) {   // Runlength encoded RGB images
-		unsigned char red,green,blue,alphabyte,packetHeader,packetSize,j;
-
-		red = 0;
-		green = 0;
-		blue = 0;
-		alphabyte = 0xff;
-
-		for(row=rows-1; row>=0; row--) {
-			pixbuf = targa_rgba + row*columns*4;
-			for(column=0; column<columns; ) {
-				packetHeader= *buf_p++;
-				packetSize = 1 + (packetHeader & 0x7f);
-				if (packetHeader & 0x80) {        // run-length packet
-					switch (targa_header.pixel_size) {
-						case 24:
-								blue = *buf_p++;
-								green = *buf_p++;
-								red = *buf_p++;
-								alphabyte = 255;
-								break;
-						case 32:
-								blue = *buf_p++;
-								green = *buf_p++;
-								red = *buf_p++;
-								alphabyte = *buf_p++;
-								break;
-						default:
-							ri.Error( ERR_DROP, "LoadTGA: illegal pixel_size '%d' in file '%s'\n", targa_header.pixel_size, name );
-							break;
-					}
-	
-					for(j=0;j<packetSize;j++) {
-						*pixbuf++=red;
-						*pixbuf++=green;
-						*pixbuf++=blue;
-						*pixbuf++=alphabyte;
-						column++;
-						if (column==columns) { // run spans across rows
-							column=0;
-							if (row>0)
-								row--;
-							else
-								goto breakOut;
-							pixbuf = targa_rgba + row*columns*4;
-						}
-					}
-				}
-				else {                            // non run-length packet
-					for(j=0;j<packetSize;j++) {
-						switch (targa_header.pixel_size) {
-							case 24:
-									blue = *buf_p++;
-									green = *buf_p++;
-									red = *buf_p++;
-									*pixbuf++ = red;
-									*pixbuf++ = green;
-									*pixbuf++ = blue;
-									*pixbuf++ = 255;
-									break;
-							case 32:
-									blue = *buf_p++;
-									green = *buf_p++;
-									red = *buf_p++;
-									alphabyte = *buf_p++;
-									*pixbuf++ = red;
-									*pixbuf++ = green;
-									*pixbuf++ = blue;
-									*pixbuf++ = alphabyte;
-									break;
-							default:
-								ri.Error( ERR_DROP, "LoadTGA: illegal pixel_size '%d' in file '%s'\n", targa_header.pixel_size, name );
-								break;
-						}
-						column++;
-						if (column==columns) { // pixel packet run spans across rows
-							column=0;
-							if (row>0)
-								row--;
-							else
-								goto breakOut;
-							pixbuf = targa_rgba + row*columns*4;
-						}						
-					}
-				}
-			}
-			breakOut:;
-		}
-	}
-
-#if 0 
-  // TTimo: this is the chunk of code to ensure a behavior that meets TGA specs 
-  // bk0101024 - fix from Leonardo
-  // bit 5 set => top-down
-  if (targa_header.attributes & 0x20) {
-    unsigned char *flip = (unsigned char*)malloc (columns*4);
-    unsigned char *src, *dst;
-
-    for (row = 0; row < rows/2; row++) {
-      src = targa_rgba + row * 4 * columns;
-      dst = targa_rgba + (rows - row - 1) * 4 * columns;
-
-      memcpy (flip, src, columns*4);
-      memcpy (src, dst, columns*4);
-      memcpy (dst, flip, columns*4);
-    }
-    free (flip);
-  }
-#endif
-  // instead we just print a warning
-  if (targa_header.attributes & 0x20) {
-    ri.Printf( PRINT_WARNING, "WARNING: '%s' TGA file header declares top-down image, ignoring\n", name);
-  }
-
-  ri.FS_FreeFile (buffer);
-}
-
-static void LoadJPG( const char *filename, unsigned char **pic, int *width, int *height ) {
-  /* This struct contains the JPEG decompression parameters and pointers to
-   * working space (which is allocated as needed by the JPEG library).
-   */
-  struct jpeg_decompress_struct cinfo = {NULL};
-  /* We use our private extension JPEG error handler.
-   * Note that this struct must live as long as the main JPEG parameter
-   * struct, to avoid dangling-pointer problems.
-   */
-  /* This struct represents a JPEG error handler.  It is declared separately
-   * because applications often want to supply a specialized error handler
-   * (see the second half of this file for an example).  But here we just
-   * take the easy way out and use the standard error handler, which will
-   * print a message on stderr and call exit() if compression fails.
-   * Note that this struct must live as long as the main JPEG parameter
-   * struct, to avoid dangling-pointer problems.
-   */
-  struct jpeg_error_mgr jerr;
-  /* More stuff */
-  JSAMPARRAY buffer;		/* Output row buffer */
-  unsigned row_stride;		/* physical row width in output buffer */
-  unsigned pixelcount, memcount;
-  unsigned char *out;
-  byte	*fbuffer;
-  byte  *buf;
-
-  /* In this example we want to open the input file before doing anything else,
-   * so that the setjmp() error recovery below can assume the file is open.
-   * VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
-   * requires it in order to read binary files.
-   */
-
-  ri.FS_ReadFile ( ( char * ) filename, (void **)&fbuffer);
-  if (!fbuffer) {
-	return;
-  }
-
-  /* Step 1: allocate and initialize JPEG decompression object */
-
-  /* We have to set up the error handler first, in case the initialization
-   * step fails.  (Unlikely, but it could happen if you are out of memory.)
-   * This routine fills in the contents of struct jerr, and returns jerr's
-   * address which we place into the link field in cinfo.
-   */
-  cinfo.err = jpeg_std_error(&jerr);
-
-  /* Now we can initialize the JPEG decompression object. */
-  jpeg_create_decompress(&cinfo);
-
-  /* Step 2: specify data source (eg, a file) */
-
-  jpeg_stdio_src(&cinfo, fbuffer);
-
-  /* Step 3: read file parameters with jpeg_read_header() */
-
-  (void) jpeg_read_header(&cinfo, TRUE);
-  /* We can ignore the return value from jpeg_read_header since
-   *   (a) suspension is not possible with the stdio data source, and
-   *   (b) we passed TRUE to reject a tables-only JPEG file as an error.
-   * See libjpeg.doc for more info.
-   */
-
-  /* Step 4: set parameters for decompression */
-
-  /* In this example, we don't need to change any of the defaults set by
-   * jpeg_read_header(), so we do nothing here.
-   */
-
-  /* Step 5: Start decompressor */
-
-  (void) jpeg_start_decompress(&cinfo);
-  /* We can ignore the return value since suspension is not possible
-   * with the stdio data source.
-   */
-
-  /* We may need to do some setup of our own at this point before reading
-   * the data.  After jpeg_start_decompress() we have the correct scaled
-   * output image dimensions available, as well as the output colormap
-   * if we asked for color quantization.
-   * In this example, we need to make an output work buffer of the right size.
-   */ 
-  /* JSAMPLEs per row in output buffer */
-
-  pixelcount = cinfo.output_width * cinfo.output_height;
-
-  if(!cinfo.output_width || !cinfo.output_height
-      || ((pixelcount * 4) / cinfo.output_width) / 4 != cinfo.output_height
-      || pixelcount > 0x1FFFFFFF || cinfo.output_components > 4) // 4*1FFFFFFF == 0x7FFFFFFC < 0x7FFFFFFF
-  {
-    ri.Error (ERR_DROP, "LoadJPG: %s has an invalid image size: %dx%d*4=%d, components: %d\n", filename,
-		    cinfo.output_width, cinfo.output_height, pixelcount * 4, cinfo.output_components);
-  }
-
-  memcount = pixelcount * 4;
-  row_stride = cinfo.output_width * cinfo.output_components;
-
-  out = ri.Malloc(memcount);
-
-  *width = cinfo.output_width;
-  *height = cinfo.output_height;
-
-  /* Step 6: while (scan lines remain to be read) */
-  /*           jpeg_read_scanlines(...); */
-
-  /* Here we use the library's state variable cinfo.output_scanline as the
-   * loop counter, so that we don't have to keep track ourselves.
-   */
-  while (cinfo.output_scanline < cinfo.output_height) {
-    /* jpeg_read_scanlines expects an array of pointers to scanlines.
-     * Here the array is only one element long, but you could ask for
-     * more than one scanline at a time if that's more convenient.
-     */
-	buf = ((out+(row_stride*cinfo.output_scanline)));
-	buffer = &buf;
-    (void) jpeg_read_scanlines(&cinfo, buffer, 1);
-  }
-  
-  buf = out;
-
-  // If we are processing an 8-bit JPEG (greyscale), we'll have to convert
-  // the greyscale values to RGBA.
-  if(cinfo.output_components == 1)
-  {
-  	int sindex = pixelcount, dindex = memcount;
-	unsigned char greyshade;
-
-	// Only pixelcount number of bytes have been written.
-	// Expand the color values over the rest of the buffer, starting
-	// from the end.
-	do
-	{
-		greyshade = buf[--sindex];
-
-		buf[--dindex] = 255;
-		buf[--dindex] = greyshade;
-		buf[--dindex] = greyshade;
-		buf[--dindex] = greyshade;
-	} while(sindex);
-  }
-  else
-  {
-	// clear all the alphas to 255
-	int	i;
-
-	for ( i = 3 ; i < memcount ; i+=4 )
-	{
-		buf[i] = 255;
-	}
-  }
-
-  *pic = out;
-
-  /* Step 7: Finish decompression */
-
-  (void) jpeg_finish_decompress(&cinfo);
-  /* We can ignore the return value since suspension is not possible
-   * with the stdio data source.
-   */
-
-  /* Step 8: Release JPEG decompression object */
-
-  /* This is an important step since it will release a good deal of memory. */
-  jpeg_destroy_decompress(&cinfo);
-
-  /* After finish_decompress, we can close the input file.
-   * Here we postpone it until after no more JPEG errors are possible,
-   * so as to simplify the setjmp error logic above.  (Actually, I don't
-   * think that jpeg_destroy can do an error exit, but why assume anything...)
-   */
-  ri.FS_FreeFile (fbuffer);
-
-  /* At this point you may want to check to see whether any corrupt-data
-   * warnings occurred (test whether jerr.pub.num_warnings is nonzero).
-   */
-
-  /* And we're done! */
-}
-
-
-/* Expanded data destination object for stdio output */
-
-typedef struct {
-  struct jpeg_destination_mgr pub; /* public fields */
-
-  byte* outfile;		/* target stream */
-  int	size;
-} my_destination_mgr;
-
-typedef my_destination_mgr * my_dest_ptr;
-
-
-/*
- * Initialize destination --- called by jpeg_start_compress
- * before any data is actually written.
- */
-
-void init_destination (j_compress_ptr cinfo)
-{
-  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
-
-  dest->pub.next_output_byte = dest->outfile;
-  dest->pub.free_in_buffer = dest->size;
-}
-
-
-/*
- * Empty the output buffer --- called whenever buffer fills up.
- *
- * In typical applications, this should write the entire output buffer
- * (ignoring the current state of next_output_byte & free_in_buffer),
- * reset the pointer & count to the start of the buffer, and return TRUE
- * indicating that the buffer has been dumped.
- *
- * In applications that need to be able to suspend compression due to output
- * overrun, a FALSE return indicates that the buffer cannot be emptied now.
- * In this situation, the compressor will return to its caller (possibly with
- * an indication that it has not accepted all the supplied scanlines).  The
- * application should resume compression after it has made more room in the
- * output buffer.  Note that there are substantial restrictions on the use of
- * suspension --- see the documentation.
- *
- * When suspending, the compressor will back up to a convenient restart point
- * (typically the start of the current MCU). next_output_byte & free_in_buffer
- * indicate where the restart point will be if the current call returns FALSE.
- * Data beyond this point will be regenerated after resumption, so do not
- * write it out when emptying the buffer externally.
- */
-
-boolean empty_output_buffer (j_compress_ptr cinfo)
-{
-  return TRUE;
-}
-
-
-/*
- * Compression initialization.
- * Before calling this, all parameters and a data destination must be set up.
- *
- * We require a write_all_tables parameter as a failsafe check when writing
- * multiple datastreams from the same compression object.  Since prior runs
- * will have left all the tables marked sent_table=TRUE, a subsequent run
- * would emit an abbreviated stream (no tables) by default.  This may be what
- * is wanted, but for safety's sake it should not be the default behavior:
- * programmers should have to make a deliberate choice to emit abbreviated
- * images.  Therefore the documentation and examples should encourage people
- * to pass write_all_tables=TRUE; then it will take active thought to do the
- * wrong thing.
- */
-
-GLOBAL void
-jpeg_start_compress (j_compress_ptr cinfo, boolean write_all_tables)
-{
-  if (cinfo->global_state != CSTATE_START)
-    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
-
-  if (write_all_tables)
-    jpeg_suppress_tables(cinfo, FALSE);	/* mark all tables to be written */
-
-  /* (Re)initialize error mgr and destination modules */
-  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
-  (*cinfo->dest->init_destination) (cinfo);
-  /* Perform master selection of active modules */
-  jinit_compress_master(cinfo);
-  /* Set up for the first pass */
-  (*cinfo->master->prepare_for_pass) (cinfo);
-  /* Ready for application to drive first pass through jpeg_write_scanlines
-   * or jpeg_write_raw_data.
-   */
-  cinfo->next_scanline = 0;
-  cinfo->global_state = (cinfo->raw_data_in ? CSTATE_RAW_OK : CSTATE_SCANNING);
-}
-
-
-/*
- * Write some scanlines of data to the JPEG compressor.
- *
- * The return value will be the number of lines actually written.
- * This should be less than the supplied num_lines only in case that
- * the data destination module has requested suspension of the compressor,
- * or if more than image_height scanlines are passed in.
- *
- * Note: we warn about excess calls to jpeg_write_scanlines() since
- * this likely signals an application programmer error.  However,
- * excess scanlines passed in the last valid call are *silently* ignored,
- * so that the application need not adjust num_lines for end-of-image
- * when using a multiple-scanline buffer.
- */
-
-GLOBAL JDIMENSION
-jpeg_write_scanlines (j_compress_ptr cinfo, JSAMPARRAY scanlines,
-		      JDIMENSION num_lines)
-{
-  JDIMENSION row_ctr, rows_left;
-
-  if (cinfo->global_state != CSTATE_SCANNING)
-    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
-  if (cinfo->next_scanline >= cinfo->image_height)
-    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
-
-  /* Call progress monitor hook if present */
-  if (cinfo->progress != NULL) {
-    cinfo->progress->pass_counter = (long) cinfo->next_scanline;
-    cinfo->progress->pass_limit = (long) cinfo->image_height;
-    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
-  }
-
-  /* Give master control module another chance if this is first call to
-   * jpeg_write_scanlines.  This lets output of the frame/scan headers be
-   * delayed so that application can write COM, etc, markers between
-   * jpeg_start_compress and jpeg_write_scanlines.
-   */
-  if (cinfo->master->call_pass_startup)
-    (*cinfo->master->pass_startup) (cinfo);
-
-  /* Ignore any extra scanlines at bottom of image. */
-  rows_left = cinfo->image_height - cinfo->next_scanline;
-  if (num_lines > rows_left)
-    num_lines = rows_left;
-
-  row_ctr = 0;
-  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, num_lines);
-  cinfo->next_scanline += row_ctr;
-  return row_ctr;
-}
-
-/*
- * Terminate destination --- called by jpeg_finish_compress
- * after all data has been written.  Usually needs to flush buffer.
- *
- * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
- * application must deal with any cleanup that should happen even
- * for error exit.
- */
-
-static int hackSize;
-
-void term_destination (j_compress_ptr cinfo)
-{
-  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
-  size_t datacount = dest->size - dest->pub.free_in_buffer;
-  hackSize = datacount;
-}
-
-
-/*
- * Prepare for output to a stdio stream.
- * The caller must have already opened the stream, and is responsible
- * for closing it after finishing compression.
- */
-
-void jpegDest (j_compress_ptr cinfo, byte* outfile, int size)
-{
-  my_dest_ptr dest;
-
-  /* The destination object is made permanent so that multiple JPEG images
-   * can be written to the same file without re-executing jpeg_stdio_dest.
-   * This makes it dangerous to use this manager and a different destination
-   * manager serially with the same JPEG object, because their private object
-   * sizes may be different.  Caveat programmer.
-   */
-  if (cinfo->dest == NULL) {	/* first time for this JPEG object? */
-    cinfo->dest = (struct jpeg_destination_mgr *)
-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
-				  sizeof(my_destination_mgr));
-  }
-
-  dest = (my_dest_ptr) cinfo->dest;
-  dest->pub.init_destination = init_destination;
-  dest->pub.empty_output_buffer = empty_output_buffer;
-  dest->pub.term_destination = term_destination;
-  dest->outfile = outfile;
-  dest->size = size;
-}
-
-void SaveJPG(char * filename, int quality, int image_width, int image_height, unsigned char *image_buffer) {
-  /* This struct contains the JPEG compression parameters and pointers to
-   * working space (which is allocated as needed by the JPEG library).
-   * It is possible to have several such structures, representing multiple
-   * compression/decompression processes, in existence at once.  We refer
-   * to any one struct (and its associated working data) as a "JPEG object".
-   */
-  struct jpeg_compress_struct cinfo;
-  /* This struct represents a JPEG error handler.  It is declared separately
-   * because applications often want to supply a specialized error handler
-   * (see the second half of this file for an example).  But here we just
-   * take the easy way out and use the standard error handler, which will
-   * print a message on stderr and call exit() if compression fails.
-   * Note that this struct must live as long as the main JPEG parameter
-   * struct, to avoid dangling-pointer problems.
-   */
-  struct jpeg_error_mgr jerr;
-  /* More stuff */
-  JSAMPROW row_pointer[1];	/* pointer to JSAMPLE row[s] */
-  int row_stride;		/* physical row width in image buffer */
-  unsigned char *out;
-
-  /* Step 1: allocate and initialize JPEG compression object */
-
-  /* We have to set up the error handler first, in case the initialization
-   * step fails.  (Unlikely, but it could happen if you are out of memory.)
-   * This routine fills in the contents of struct jerr, and returns jerr's
-   * address which we place into the link field in cinfo.
-   */
-  cinfo.err = jpeg_std_error(&jerr);
-  /* Now we can initialize the JPEG compression object. */
-  jpeg_create_compress(&cinfo);
-
-  /* Step 2: specify data destination (eg, a file) */
-  /* Note: steps 2 and 3 can be done in either order. */
-
-  /* Here we use the library-supplied code to send compressed data to a
-   * stdio stream.  You can also write your own code to do something else.
-   * VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
-   * requires it in order to write binary files.
-   */
-  out = ri.Hunk_AllocateTempMemory(image_width*image_height*4);
-  jpegDest(&cinfo, out, image_width*image_height*4);
-
-  /* Step 3: set parameters for compression */
-
-  /* First we supply a description of the input image.
-   * Four fields of the cinfo struct must be filled in:
-   */
-  cinfo.image_width = image_width; 	/* image width and height, in pixels */
-  cinfo.image_height = image_height;
-  cinfo.input_components = 4;		/* # of color components per pixel */
-  cinfo.in_color_space = JCS_RGB; 	/* colorspace of input image */
-  /* Now use the library's routine to set default compression parameters.
-   * (You must set at least cinfo.in_color_space before calling this,
-   * since the defaults depend on the source color space.)
-   */
-  jpeg_set_defaults(&cinfo);
-  /* Now you can set any non-default parameters you wish to.
-   * Here we just illustrate the use of quality (quantization table) scaling:
-   */
-  jpeg_set_quality(&cinfo, quality, TRUE /* limit to baseline-JPEG values */);
-  /* If quality is set high, disable chroma subsampling */
-  if (quality >= 85) {
-    cinfo.comp_info[0].h_samp_factor = 1;
-    cinfo.comp_info[0].v_samp_factor = 1;
-  }
-
-  /* Step 4: Start compressor */
-
-  /* TRUE ensures that we will write a complete interchange-JPEG file.
-   * Pass TRUE unless you are very sure of what you're doing.
-   */
-  jpeg_start_compress(&cinfo, TRUE);
-
-  /* Step 5: while (scan lines remain to be written) */
-  /*           jpeg_write_scanlines(...); */
-
-  /* Here we use the library's state variable cinfo.next_scanline as the
-   * loop counter, so that we don't have to keep track ourselves.
-   * To keep things simple, we pass one scanline per call; you can pass
-   * more if you wish, though.
-   */
-  row_stride = image_width * 4;	/* JSAMPLEs per row in image_buffer */
-
-  while (cinfo.next_scanline < cinfo.image_height) {
-    /* jpeg_write_scanlines expects an array of pointers to scanlines.
-     * Here the array is only one element long, but you could pass
-     * more than one scanline at a time if that's more convenient.
-     */
-    row_pointer[0] = & image_buffer[((cinfo.image_height-1)*row_stride)-cinfo.next_scanline * row_stride];
-    (void) jpeg_write_scanlines(&cinfo, row_pointer, 1);
-  }
-
-  /* Step 6: Finish compression */
-
-  jpeg_finish_compress(&cinfo);
-  /* After finish_compress, we can close the output file. */
-  ri.FS_WriteFile( filename, out, hackSize );
-
-  ri.Hunk_FreeTempMemory(out);
-
-  /* Step 7: release JPEG compression object */
-
-  /* This is an important step since it will release a good deal of memory. */
-  jpeg_destroy_compress(&cinfo);
-
-  /* And we're done! */
-}
-
-/*
-=================
-SaveJPGToBuffer
-=================
-*/
-int SaveJPGToBuffer( byte *buffer, int quality,
-    int image_width, int image_height,
-    byte *image_buffer )
-{
-  struct jpeg_compress_struct cinfo;
-  struct jpeg_error_mgr jerr;
-  JSAMPROW row_pointer[1];	/* pointer to JSAMPLE row[s] */
-  int row_stride;		/* physical row width in image buffer */
-
-  /* Step 1: allocate and initialize JPEG compression object */
-  cinfo.err = jpeg_std_error(&jerr);
-  /* Now we can initialize the JPEG compression object. */
-  jpeg_create_compress(&cinfo);
-
-  /* Step 2: specify data destination (eg, a file) */
-  /* Note: steps 2 and 3 can be done in either order. */
-  jpegDest(&cinfo, buffer, image_width*image_height*4);
-
-  /* Step 3: set parameters for compression */
-  cinfo.image_width = image_width; 	/* image width and height, in pixels */
-  cinfo.image_height = image_height;
-  cinfo.input_components = 4;		/* # of color components per pixel */
-  cinfo.in_color_space = JCS_RGB; 	/* colorspace of input image */
-
-  jpeg_set_defaults(&cinfo);
-  jpeg_set_quality(&cinfo, quality, TRUE /* limit to baseline-JPEG values */);
-  /* If quality is set high, disable chroma subsampling */
-  if (quality >= 85) {
-    cinfo.comp_info[0].h_samp_factor = 1;
-    cinfo.comp_info[0].v_samp_factor = 1;
-  }
-
-  /* Step 4: Start compressor */
-  jpeg_start_compress(&cinfo, TRUE);
-
-  /* Step 5: while (scan lines remain to be written) */
-  /*           jpeg_write_scanlines(...); */
-  row_stride = image_width * 4;	/* JSAMPLEs per row in image_buffer */
-
-  while (cinfo.next_scanline < cinfo.image_height) {
-    /* jpeg_write_scanlines expects an array of pointers to scanlines.
-     * Here the array is only one element long, but you could pass
-     * more than one scanline at a time if that's more convenient.
-     */
-    row_pointer[0] = & image_buffer[((cinfo.image_height-1)*row_stride)-cinfo.next_scanline * row_stride];
-    (void) jpeg_write_scanlines(&cinfo, row_pointer, 1);
-  }
-
-  /* Step 6: Finish compression */
-  jpeg_finish_compress(&cinfo);
-
-  /* Step 7: release JPEG compression object */
-  jpeg_destroy_compress(&cinfo);
-
-  /* And we're done! */
-  return hackSize;
-}
-
-//===================================================================
-
-/*
-=================
-PNG LOADING
-=================
-*/
-
-/*
- *  Quake 3 image format : RGBA
- */
-
-#define Q3IMAGE_BYTESPERPIXEL (4)
-
-/*
- *  PNG specifications
- */
-
-/*
- *  The first 8 Bytes of every PNG-File are a fixed signature
- *  to identify the file as a PNG.
- */
-
-#define PNG_Signature "\x89\x50\x4E\x47\xD\xA\x1A\xA"
-#define PNG_Signature_Size (8)
-
-/*
- *  After the signature diverse chunks follow.
- *  A chunk consists of a header and if Length
- *  is bigger than 0 a body and a CRC of the body follow.
- */
-
-struct PNG_ChunkHeader
-{
-    uint32_t Length;
-    uint32_t Type;
-};
-
-#define PNG_ChunkHeader_Size (8)
-
-typedef uint32_t PNG_ChunkCRC;
-
-#define PNG_ChunkCRC_Size (4)
-
-/*
- *  We use the following ChunkTypes.
- *  All others are ignored.
- */
-
-#define MAKE_CHUNKTYPE(a,b,c,d) (((a) << 24) | ((b) << 16) | ((c) << 8) | ((d)))
-
-#define PNG_ChunkType_IHDR MAKE_CHUNKTYPE('I', 'H', 'D', 'R')
-#define PNG_ChunkType_PLTE MAKE_CHUNKTYPE('P', 'L', 'T', 'E')
-#define PNG_ChunkType_IDAT MAKE_CHUNKTYPE('I', 'D', 'A', 'T')
-#define PNG_ChunkType_IEND MAKE_CHUNKTYPE('I', 'E', 'N', 'D')
-#define PNG_ChunkType_tRNS MAKE_CHUNKTYPE('t', 'R', 'N', 'S')
-
-/*
- *  Per specification the first chunk after the signature SHALL be IHDR.
- */
-
-struct PNG_Chunk_IHDR
-{
-    uint32_t Width;
-    uint32_t Height;
-    uint8_t  BitDepth;
-    uint8_t  ColourType;
-    uint8_t  CompressionMethod;
-    uint8_t  FilterMethod;
-    uint8_t  InterlaceMethod;
-};
-
-#define PNG_Chunk_IHDR_Size (13)
-
-/*
- *  ColourTypes
- */
-
-#define PNG_ColourType_Grey      (0)
-#define PNG_ColourType_True      (2)
-#define PNG_ColourType_Indexed   (3)
-#define PNG_ColourType_GreyAlpha (4)
-#define PNG_ColourType_TrueAlpha (6)
-
-/*
- *  number of colour components
- *
- *  Grey      : 1 grey
- *  True      : 1 R, 1 G, 1 B
- *  Indexed   : 1 index
- *  GreyAlpha : 1 grey, 1 alpha
- *  TrueAlpha : 1 R, 1 G, 1 B, 1 alpha
- */
-
-#define PNG_NumColourComponents_Grey      (1)
-#define PNG_NumColourComponents_True      (3)
-#define PNG_NumColourComponents_Indexed   (1)
-#define PNG_NumColourComponents_GreyAlpha (2)
-#define PNG_NumColourComponents_TrueAlpha (4)
-
-/*
- *  For the different ColourTypes
- *  different BitDepths are specified.
- */
-
-#define PNG_BitDepth_1  ( 1)
-#define PNG_BitDepth_2  ( 2)
-#define PNG_BitDepth_4  ( 4)
-#define PNG_BitDepth_8  ( 8)
-#define PNG_BitDepth_16 (16)
-
-/*
- *  Only one valid CompressionMethod is standardized.
- */
-
-#define PNG_CompressionMethod_0 (0)
-
-/*
- *  Only one valid FilterMethod is currently standardized.
- */
-
-#define PNG_FilterMethod_0 (0)
-
-/*
- *  This FilterMethod defines 5 FilterTypes
- */
-
-#define PNG_FilterType_None    (0)
-#define PNG_FilterType_Sub     (1)
-#define PNG_FilterType_Up      (2)
-#define PNG_FilterType_Average (3)
-#define PNG_FilterType_Paeth   (4)
-
-/*
- *  Two InterlaceMethods are standardized :
- *  0 - NonInterlaced
- *  1 - Interlaced
- */
-
-#define PNG_InterlaceMethod_NonInterlaced (0)
-#define PNG_InterlaceMethod_Interlaced    (1)
-
-/*
- *  The Adam7 interlace method uses 7 passes.
- */
-
-#define PNG_Adam7_NumPasses (7)
-
-/*
- *  The compressed data starts with a header ...
- */
-
-struct PNG_ZlibHeader
-{
-    uint8_t CompressionMethod;
-    uint8_t Flags;
-};
-
-#define PNG_ZlibHeader_Size (2)
-
-/*
- *  ... and is followed by a check value
- */
-
-#define PNG_ZlibCheckValue_Size (4)
-
-/*
- *  Some support functions for buffered files follow.
- */
-
-/*
- *  buffered file representation
- */
-
-struct BufferedFile
-{
-    byte *Buffer;
-    int   Length;
-    byte *Ptr;
-    int   BytesLeft;
-};
-
-/*
- *  Read a file into a buffer.
- */
-
-static struct BufferedFile *ReadBufferedFile(const char *name)
-{
-    struct BufferedFile *BF;
-
-    /*
-     *  input verification
-     */
-
-    if(!name)
-    {
-        return(NULL);
-    }
-
-    /*
-     *  Allocate control struct.
-     */
-
-    BF = ri.Malloc(sizeof(struct BufferedFile));
-    if(!BF)
-    {
-        return(NULL);
-    }
-
-    /*
-     *  Initialize the structs components.
-     */
-
-    BF->Length    = 0;
-    BF->Buffer    = NULL;
-    BF->Ptr       = NULL;
-    BF->BytesLeft = 0;
-
-    /*
-     *  Read the file.
-     */
-
-    BF->Length = ri.FS_ReadFile((char *) name, (void **) &BF->Buffer);
-
-    /*
-     *  Did we get it? Is it big enough?
-     */
-
-    if(!(BF->Buffer && (BF->Length > 0)))
-    {
-        ri.Free(BF);
-
-        return(NULL);
-    }
-
-    /*
-     *  Set the pointers and counters.
-     */
-
-    BF->Ptr       = BF->Buffer;
-    BF->BytesLeft = BF->Length;
-
-    return(BF);
-}
-
-/*
- *  Close a buffered file.
- */
-
-static void CloseBufferedFile(struct BufferedFile *BF)
-{
-    if(BF)
-    {
-        if(BF->Buffer)
-        {
-            ri.FS_FreeFile(BF->Buffer);
-        }
- 
-        ri.Free(BF);
-    }
-}
-
-/*
- *  Get a pointer to the requested bytes.
- */
-
-static void *BufferedFileRead(struct BufferedFile *BF, int Length)
-{
-    void *RetVal;
-
-    /*
-     *  input verification
-     */
-
-    if(!(BF && Length))
-    {
-        return(NULL);
-    }
- 
-    /*
-     *  not enough bytes left
-     */
-
-    if(Length > BF->BytesLeft)
-    {
-        return(NULL);
-    }
-
-    /*
-     *  the pointer to the requested data
-     */
-
-    RetVal = BF->Ptr;
- 
-    /*
-     *  Raise the pointer and counter.
-     */
-
-    BF->Ptr       += Length;
-    BF->BytesLeft -= Length;
-
-    return(RetVal);
-}
-
-/*
- *  Rewind the buffer.
- */
-
-static qboolean BufferedFileRewind(struct BufferedFile *BF, int Offset)
-{
-    int BytesRead; 
-
-    /*
-     *  input verification
-     */
-
-    if(!BF)
-    {
-        return(qfalse);
-    }
-
-    /*
-     *  special trick to rewind to the beginning of the buffer
-     */
-
-    if(Offset == -1)
-    {
-        BF->Ptr       = BF->Buffer;
-        BF->BytesLeft = BF->Length;
-  
-        return(qtrue);
-    }
-
-    /*
-     *  How many bytes do we have already read?
-     */
-
-    BytesRead = BF->Ptr - BF->Buffer;
-
-    /*
-     *  We can only rewind to the beginning of the BufferedFile.
-     */
-
-    if(Offset > BytesRead)
-    {
-        return(qfalse);
-    }
-
-    /*
-     *  lower the pointer and counter.
-     */
-
-    BF->Ptr       -= Offset;
-    BF->BytesLeft += Offset;
-
-    return(qtrue);
-}
-
-/*
- *  Skip some bytes.
- */
-
-static qboolean BufferedFileSkip(struct BufferedFile *BF, int Offset)
-{
-    /*
-     *  input verification
-     */
-
-    if(!BF)
-    {
-        return(qfalse);
-    }
- 
-    /*
-     *  We can only skip to the end of the BufferedFile.
-     */
-
-    if(Offset > BF->BytesLeft)
-    {
-        return(qfalse);
-    }
-
-    /*
-     *  lower the pointer and counter.
-     */
-
-    BF->Ptr       += Offset;
-    BF->BytesLeft -= Offset;
-
-    return(qtrue);
-}
-
-/*
- *  Find a chunk
- */
-
-static qboolean FindChunk(struct BufferedFile *BF, uint32_t ChunkType)
-{
-    struct PNG_ChunkHeader *CH;
-
-    uint32_t Length;
-    uint32_t Type;
-
-    /*
-     *  input verification
-     */
-
-    if(!BF)
-    {
-        return(qfalse);
-    }
-
-    /*
-     *  cycle trough the chunks
-     */
-
-    while(qtrue)
-    {
-        /*
-         *  Read the chunk-header.
-         */
-
-        CH = BufferedFileRead(BF, PNG_ChunkHeader_Size);
-        if(!CH)
-        {
-            return(qfalse);
-        }
-
-        /*
-         *  Do not swap the original types
-         *  they might be needed later.
-         */
-
-        Length = BigLong(CH->Length);
-        Type   = BigLong(CH->Type);
-  
-        /*
-         *  We found it!
-         */
-
-        if(Type == ChunkType)
-        {
-            /*
-             *  Rewind to the start of the chunk.
-             */
-	     
-            BufferedFileRewind(BF, PNG_ChunkHeader_Size);
-  
-            break;
-        }
-        else
-        {
-            /*
-             *  Skip the rest of the chunk.
-             */
-
-            if(Length)
-            {
-                if(!BufferedFileSkip(BF, Length + PNG_ChunkCRC_Size))
-                {
-                    return(qfalse);
-                }  
-            }
-        }
-    }
-
-    return(qtrue);
-}
-
-/*
- *  Decompress all IDATs
- */
-
-static uint32_t DecompressIDATs(struct BufferedFile *BF, uint8_t **Buffer)
-{
-    uint8_t  *DecompressedData;
-    uint32_t  DecompressedDataLength;
-
-    uint8_t  *CompressedData;
-    uint8_t  *CompressedDataPtr;
-    uint32_t  CompressedDataLength;
-
-    struct PNG_ChunkHeader *CH;
-
-    uint32_t Length;
-    uint32_t Type;
-
-    int BytesToRewind;
-
-    int32_t   puffResult;
-    uint8_t  *puffDest;
-    uint32_t  puffDestLen;
-    uint8_t  *puffSrc;
-    uint32_t  puffSrcLen;
-
-    /*
-     *  input verification
-     */
-
-    if(!(BF && Buffer))
-    {
-        return(-1);
-    }
-
-    /*
-     *  some zeroing
-     */
-
-    DecompressedData = NULL;
-    DecompressedDataLength = 0;
-    *Buffer = DecompressedData;
-
-    CompressedData = NULL;
-    CompressedDataLength = 0;
-
-    BytesToRewind = 0;
-
-    /*
-     *  Find the first IDAT chunk.
-     */
-
-    if(!FindChunk(BF, PNG_ChunkType_IDAT))
-    {
-        return(-1);
-    }
-
-    /*
-     *  Count the size of the uncompressed data
-     */
-
-    while(qtrue)
-    {
-        /*
-         *  Read chunk header
-         */
-
-        CH = BufferedFileRead(BF, PNG_ChunkHeader_Size);
-        if(!CH)
-        {
-            /*
-             *  Rewind to the start of this adventure
-             *  and return unsuccessfull
-             */
-
-            BufferedFileRewind(BF, BytesToRewind);
-
-            return(-1);
-        }
-
-        /*
-         *  Length and Type of chunk
-         */
-
-        Length = BigLong(CH->Length);
-        Type   = BigLong(CH->Type);
-
-        /*
-         *  We have reached the end of the IDAT chunks
-         */
-
-        if(!(Type == PNG_ChunkType_IDAT))
-        {
-            BufferedFileRewind(BF, PNG_ChunkHeader_Size); 
-  
-            break;
-        }
-
-        /*
-         *  Add chunk header to count.
-         */
-
-        BytesToRewind += PNG_ChunkHeader_Size;
-
-        /*
-         *  Skip to next chunk
-         */
-
-        if(Length)
-        {
-            if(!BufferedFileSkip(BF, Length + PNG_ChunkCRC_Size))
-            {
-                BufferedFileRewind(BF, BytesToRewind);
-
-                return(-1);
-            }
-
-            BytesToRewind += Length + PNG_ChunkCRC_Size;
-            CompressedDataLength += Length;
-        } 
-    }
-
-    BufferedFileRewind(BF, BytesToRewind);
-
-    CompressedData = ri.Malloc(CompressedDataLength);
-    if(!CompressedData)
-    {
-        return(-1);
-    }
- 
-    CompressedDataPtr = CompressedData;
-
-    /*
-     *  Collect the compressed Data
-     */
-
-    while(qtrue)
-    {
-        /*
-         *  Read chunk header
-         */
-
-        CH = BufferedFileRead(BF, PNG_ChunkHeader_Size);
-        if(!CH)
-        {
-            ri.Free(CompressedData); 
-  
-            return(-1);
-        }
-
-        /*
-         *  Length and Type of chunk
-         */
-
-        Length = BigLong(CH->Length);
-        Type   = BigLong(CH->Type);
-
-        /*
-         *  We have reached the end of the IDAT chunks
-         */
-
-        if(!(Type == PNG_ChunkType_IDAT))
-        {
-            BufferedFileRewind(BF, PNG_ChunkHeader_Size); 
-  
-            break;
-        }
-
-        /*
-         *  Copy the Data
-         */
-
-        if(Length)
-        {
-            uint8_t *OrigCompressedData;
-   
-            OrigCompressedData = BufferedFileRead(BF, Length);
-            if(!OrigCompressedData)
-            {
-                ri.Free(CompressedData); 
-  
-                return(-1);
-            }
-
-            if(!BufferedFileSkip(BF, PNG_ChunkCRC_Size))
-            {
-                ri.Free(CompressedData); 
-
-                return(-1);
-            }
-  
-            memcpy(CompressedDataPtr, OrigCompressedData, Length);
-            CompressedDataPtr += Length;
-        } 
-    }
-
-    /*
-     *  Let puff() calculate the decompressed data length.
-     */
-
-    puffDest    = NULL;
-    puffDestLen = 0;
- 
-    /*
-     *  The zlib header and checkvalue don't belong to the compressed data.
-     */
-
-    puffSrc    = CompressedData + PNG_ZlibHeader_Size;
-    puffSrcLen = CompressedDataLength - PNG_ZlibHeader_Size - PNG_ZlibCheckValue_Size;
-
-    /*
-     *  first puff() to calculate the size of the uncompressed data
-     */
-
-    puffResult = puff(puffDest, &puffDestLen, puffSrc, &puffSrcLen);
-    if(!((puffResult == 0) && (puffDestLen > 0)))
-    {
-        ri.Free(CompressedData);
- 
-        return(-1);
-    }
-
-    /*
-     *  Allocate the buffer for the uncompressed data.
-     */
-
-    DecompressedData = ri.Malloc(puffDestLen);
-    if(!DecompressedData)
-    {
-        ri.Free(CompressedData);
- 
-        return(-1);
-    }
-
-    /*
-     *  Set the input again in case something was changed by the last puff() .
-     */
-
-    puffDest   = DecompressedData;
-    puffSrc    = CompressedData + PNG_ZlibHeader_Size;
-    puffSrcLen = CompressedDataLength - PNG_ZlibHeader_Size - PNG_ZlibCheckValue_Size;
- 
-    /*
-     *  decompression puff()
-     */
-
-    puffResult = puff(puffDest, &puffDestLen, puffSrc, &puffSrcLen);
-
-    /*
-     *  The compressed data is not needed anymore.
-     */
-
-    ri.Free(CompressedData);
-
-    /*
-     *  Check if the last puff() was successfull.
-     */
-
-    if(!((puffResult == 0) && (puffDestLen > 0)))
-    {
-        ri.Free(DecompressedData);
- 
-        return(-1);
-    }
-
-    /*
-     *  Set the output of this function.
-     */
-
-    DecompressedDataLength = puffDestLen;
-    *Buffer = DecompressedData;
-
-    return(DecompressedDataLength);
-}
-
-/*
- *  the Paeth predictor
- */
-
-static uint8_t PredictPaeth(uint8_t a, uint8_t b, uint8_t c)
-{
-    /*
-     *  a == Left
-     *  b == Up
-     *  c == UpLeft
-     */
-
-    uint8_t Pr;
-    int p;
-    int pa, pb, pc;
-
-    Pr = 0;
-
-    p  = ((int) a) + ((int) b) - ((int) c);
-    pa = abs(p - ((int) a));
-    pb = abs(p - ((int) b));
-    pc = abs(p - ((int) c));
-
-    if((pa <= pb) && (pa <= pc))
-    {
-        Pr = a;
-    }
-    else if(pb <= pc)
-    {
-        Pr = b;
-    }
-    else
-    {
-        Pr = c;
-    }
-
-    return(Pr);
-
-}
-
-/*
- *  Reverse the filters.
- */
-
-static qboolean UnfilterImage(uint8_t  *DecompressedData, 
-                              uint32_t  ImageHeight,
-		              uint32_t  BytesPerScanline, 
-		              uint32_t  BytesPerPixel)
-{
-    uint8_t   *DecompPtr;
-    uint8_t   FilterType;
-    uint8_t  *PixelLeft, *PixelUp, *PixelUpLeft;
-    uint32_t  w, h, p;
-
-    /*
-     *  some zeros for the filters
-     */
-
-    uint8_t Zeros[8] = {0, 0, 0, 0, 0, 0, 0, 0};
-
-    /*
-     *  input verification
-     *
-     *  ImageHeight and BytesPerScanline are not checked,
-     *  because these can be zero in some interlace passes.
-     */
-
-    if(!(DecompressedData && BytesPerPixel))
-    {
-	return(qfalse);
-    }
-
-
-    /*
-     *  Set the pointer to the start of the decompressed Data.
-     */
-
-    DecompPtr = DecompressedData;
-
-    /*
-     *  Un-filtering is done in place.
-     */
-
-    /*
-     *  Go trough all scanlines.
-     */
-
-    for(h = 0; h < ImageHeight; h++)
-    {
-        /*
-         *  Every scanline starts with a FilterType byte.
-         */
-
-        FilterType = *DecompPtr;
-        DecompPtr++;
-
-        /*
-         *  Left pixel of the first byte in a scanline is zero.
-         */
-
-        PixelLeft = Zeros;
-
-        /*
-         *  Set PixelUp to previous line only if we are on the second line or above.
-         *
-         *  Plus one byte for the FilterType
-         */
-
-        if(h > 0)
-        {
-            PixelUp = DecompPtr - (BytesPerScanline + 1);
-        }
-        else
-        {
-            PixelUp = Zeros;
-        }
-
-        /*
-         * The pixel left to the first pixel of the previous scanline is zero too.
-         */
-
-        PixelUpLeft = Zeros;
-
-        /*
-         *  Cycle trough all pixels of the scanline.
-         */
-
-        for(w = 0; w < (BytesPerScanline / BytesPerPixel); w++)
-        {
-            /*
-             *  Cycle trough the bytes of the pixel.
-             */
-
-            for(p = 0; p < BytesPerPixel; p++)
-            {
-                switch(FilterType)
-                { 
-                    case PNG_FilterType_None :
-                    {
-                        /*
-                         *  The byte is unfiltered.
-                         */
-
-                        break;
-                    }
-
-                    case PNG_FilterType_Sub :
-                    {
-                        DecompPtr[p] += PixelLeft[p];
-
-                        break;
-                    }
-
-		    case PNG_FilterType_Up :
-                    {
-                        DecompPtr[p] += PixelUp[p];
-
-                        break;
-                    }
-
-                    case PNG_FilterType_Average :
-                    {
-                        DecompPtr[p] += ((uint8_t) ((((uint16_t) PixelLeft[p]) + ((uint16_t) PixelUp[p])) / 2));
-
-                        break;
-                    }
-
-                    case PNG_FilterType_Paeth :
-                    {
-                        DecompPtr[p] += PredictPaeth(PixelLeft[p], PixelUp[p], PixelUpLeft[p]);
-
-                        break;
-                    }
-
-                    default :
-                    {
-                        return(qfalse);
-                    }
-                }
-            }
-   
-            PixelLeft = DecompPtr;
-
-            /*
-             *  We only have a upleft pixel if we are on the second line or above.
-             */
-
-            if(h > 0)
-            {
-                PixelUpLeft = DecompPtr - (BytesPerScanline + 1);
-            }
-
-	    /*
-             *  Skip to the next pixel.
-             */
-
-            DecompPtr += BytesPerPixel;
-	 
-            /*
-             *  We only have a previous line if we are on the second line and above.
-             */
-
-            if(h > 0)
-            {
-                PixelUp = DecompPtr - (BytesPerScanline + 1);
-            }
-        }
-    }
-
- return(qtrue);
-}
-
-/*
- *  Convert a raw input pixel to Quake 3 RGA format.
- */
-
-static qboolean ConvertPixel(struct PNG_Chunk_IHDR *IHDR,
-			     byte                  *OutPtr,
-			     uint8_t               *DecompPtr,
-                             qboolean               HasTransparentColour,
-                             uint8_t               *TransparentColour,
-                             uint8_t               *OutPal)
-{
-    /*
-     *  input verification
-     */
-    
-    if(!(IHDR && OutPtr && DecompPtr && TransparentColour && OutPal))
-    {
-     return(qfalse);
-    }
-
-    switch(IHDR->ColourType)
-    {
-        case PNG_ColourType_Grey :
-        {
-            switch(IHDR->BitDepth)
-            {
-                case PNG_BitDepth_1 :
-                case PNG_BitDepth_2 :
-                case PNG_BitDepth_4 :
-                {
-    		    uint8_t Step;
-                    uint8_t GreyValue;
-
-                    Step = 0xFF / ((1 << IHDR->BitDepth) - 1);
-
-                    GreyValue = DecompPtr[0] * Step;
-  
-                    OutPtr[0] = GreyValue;
-                    OutPtr[1] = GreyValue;
-                    OutPtr[2] = GreyValue;
-                    OutPtr[3] = 0xFF;
-
-                    /*
-                     *  Grey supports full transparency for one specified colour
-                     */
-
-                    if(HasTransparentColour)
-                    {
-                        if(TransparentColour[1] == DecompPtr[0])
-                        {
-                            OutPtr[3] = 0x00;
-                        }
-                    }
-	
-
-                    break;
-                }
-      
-                case PNG_BitDepth_8 :
-                case PNG_BitDepth_16 :
-                {
-                    OutPtr[0] = DecompPtr[0];
-                    OutPtr[1] = DecompPtr[0];
-                    OutPtr[2] = DecompPtr[0];
-                    OutPtr[3] = 0xFF;
-      
-                    /*
-                     *  Grey supports full transparency for one specified colour
-                     */
-
-                    if(HasTransparentColour)
-                    {
-                        if(IHDR->BitDepth == PNG_BitDepth_8)
-                        {
-                            if(TransparentColour[1] == DecompPtr[0])
-                            {
-                                OutPtr[3] = 0x00;
-                            }
-                        }
-                        else
-                        {
-                            if((TransparentColour[0] == DecompPtr[0]) && (TransparentColour[1] == DecompPtr[1]))
-                            {
-                                OutPtr[3] = 0x00;
-                            }
-                        }
-                    }
-
-                    break;
-                }
-      
-                default :
-                {
-                    return(qfalse);
-                }
-            }
-    
-            break;
-        }
-
-        case PNG_ColourType_True :
-        {
-            switch(IHDR->BitDepth)
-            {
-                case PNG_BitDepth_8 :
-                {
-                    OutPtr[0] = DecompPtr[0];
-                    OutPtr[1] = DecompPtr[1];
-                    OutPtr[2] = DecompPtr[2];
-                    OutPtr[3] = 0xFF;
-      
-                    /*
-                     *  True supports full transparency for one specified colour
-                     */
-
-                    if(HasTransparentColour)
-                    {
-                        if((TransparentColour[1] == DecompPtr[0]) &&
-                           (TransparentColour[3] == DecompPtr[1]) &&
-                           (TransparentColour[5] == DecompPtr[3]))
-                        {
-                            OutPtr[3] = 0x00;
-                        }
-                    }
-
-                    break;
-                }
-      
-                case PNG_BitDepth_16 :
-                {
-                    /*
-                     *  We use only the upper byte.
-                     */
-
-                    OutPtr[0] = DecompPtr[0];
-                    OutPtr[1] = DecompPtr[2];
-                    OutPtr[2] = DecompPtr[4];
-                    OutPtr[3] = 0xFF;
-      
-                    /*
-                     *  True supports full transparency for one specified colour
-                     */
-
-                    if(HasTransparentColour)
-                    {
-                        if((TransparentColour[0] == DecompPtr[0]) && (TransparentColour[1] == DecompPtr[1]) &&
-                           (TransparentColour[2] == DecompPtr[2]) && (TransparentColour[3] == DecompPtr[3]) &&
-                           (TransparentColour[4] == DecompPtr[4]) && (TransparentColour[5] == DecompPtr[5]))
-                        {
-                            OutPtr[3] = 0x00;
-                        }
-                    }
-
-                    break;
-                }
-
-                default :
-                {
-                    return(qfalse);
-                }
-            }
-
-            break;
-        }
-
-        case PNG_ColourType_Indexed :
-        {
-            OutPtr[0] = OutPal[DecompPtr[0] * Q3IMAGE_BYTESPERPIXEL + 0];
-            OutPtr[1] = OutPal[DecompPtr[0] * Q3IMAGE_BYTESPERPIXEL + 1];
-            OutPtr[2] = OutPal[DecompPtr[0] * Q3IMAGE_BYTESPERPIXEL + 2];
-            OutPtr[3] = OutPal[DecompPtr[0] * Q3IMAGE_BYTESPERPIXEL + 3];
-	
-            break;
-        }
-
-        case PNG_ColourType_GreyAlpha :
-        {
-            switch(IHDR->BitDepth)
-            {
-                case PNG_BitDepth_8 :
-                {
-                    OutPtr[0] = DecompPtr[0];
-                    OutPtr[1] = DecompPtr[0];
-                    OutPtr[2] = DecompPtr[0];
-                    OutPtr[3] = DecompPtr[1];
-      
-                    break;
-                }
-  
-                case PNG_BitDepth_16 :
-                {
-                    /*
-                     *  We use only the upper byte.
-                     */
-
-                    OutPtr[0] = DecompPtr[0];
-                    OutPtr[1] = DecompPtr[0];
-                    OutPtr[2] = DecompPtr[0];
-                    OutPtr[3] = DecompPtr[2];
-      
-                    break;
-                }
-
-                default :
-                {
-                    return(qfalse);
-                }
-            }
-
-            break;
-        }
-
-        case PNG_ColourType_TrueAlpha :
-        {
-            switch(IHDR->BitDepth)
-            {
-                case PNG_BitDepth_8 :
-                {
-                    OutPtr[0] = DecompPtr[0];
-                    OutPtr[1] = DecompPtr[1];
-                    OutPtr[2] = DecompPtr[2];
-                    OutPtr[3] = DecompPtr[3];
-      
-                    break;
-                }
-      
-                case PNG_BitDepth_16 :
-                {
-                    /*
-                     *  We use only the upper byte.
-                     */
-
-                    OutPtr[0] = DecompPtr[0];
-                    OutPtr[1] = DecompPtr[2];
-                    OutPtr[2] = DecompPtr[4];
-                    OutPtr[3] = DecompPtr[6];
-      
-                    break;
-                }
-
-                default :
-                {
-                    return(qfalse);
-                }
-            }
-
-            break;
-        }
-
-        default :
-        {
-            return(qfalse);
-        }
-    }
-
-    return(qtrue);
-}
-
-
-/*
- *  Decode a non-interlaced image.
- */
-
-static qboolean DecodeImageNonInterlaced(struct PNG_Chunk_IHDR *IHDR,
-                                         byte                  *OutBuffer, 
-                                         uint8_t               *DecompressedData,
-                                         uint32_t               DecompressedDataLength,
-                                         qboolean               HasTransparentColour,
-                                         uint8_t               *TransparentColour,
-                                         uint8_t               *OutPal)
-{
-    uint32_t IHDR_Width;
-    uint32_t IHDR_Height;
-    uint32_t BytesPerScanline, BytesPerPixel, PixelsPerByte;
-    uint32_t  w, h, p;
-    byte *OutPtr;
-    uint8_t *DecompPtr;
-
-    /*
-     *  input verification
-     */
-
-    if(!(IHDR && OutBuffer && DecompressedData && DecompressedDataLength && TransparentColour && OutPal))
-    {
-	return(qfalse);
-    }
-
-    /*
-     *  byte swapping
-     */
-     
-    IHDR_Width  = BigLong(IHDR->Width);
-    IHDR_Height = BigLong(IHDR->Height);
-
-    /*
-     *  information for un-filtering
-     */
-
-    switch(IHDR->ColourType)
-    {
-        case PNG_ColourType_Grey :
-        {
-            switch(IHDR->BitDepth)
-            {
-                case PNG_BitDepth_1 :
-                case PNG_BitDepth_2 :
-                case PNG_BitDepth_4 :
-                {
-                    BytesPerPixel    = 1;
-                    PixelsPerByte    = 8 / IHDR->BitDepth;
-
-                    break;
-                }
-
-                case PNG_BitDepth_8  :
-                case PNG_BitDepth_16 :
-                {
-                    BytesPerPixel    = (IHDR->BitDepth / 8) * PNG_NumColourComponents_Grey;
-                    PixelsPerByte    = 1;
-
-                    break;
-                }
-
-                default :
-                {
-                    return(qfalse);
-                }
-            }
-  
-            break;
-        }
-  
-        case PNG_ColourType_True :
-        {
-            switch(IHDR->BitDepth)
-            {
-                case PNG_BitDepth_8  :
-                case PNG_BitDepth_16 :
-                {
-                    BytesPerPixel    = (IHDR->BitDepth / 8) * PNG_NumColourComponents_True;
-                    PixelsPerByte    = 1;
-
-                    break;
-                }
-     
-                default :
-                {
-                    return(qfalse);
-                }
-            }
-  
-            break;
-        }
-
-        case PNG_ColourType_Indexed :
-        {
-            switch(IHDR->BitDepth)
-            {
-                case PNG_BitDepth_1 :
-                case PNG_BitDepth_2 :
-                case PNG_BitDepth_4 :
-                {
-                    BytesPerPixel    = 1;
-                    PixelsPerByte    = 8 / IHDR->BitDepth;
-
-                    break;
-                }
-
-                case PNG_BitDepth_8 :
-                {
-                    BytesPerPixel    = PNG_NumColourComponents_Indexed;
-                    PixelsPerByte    = 1;
-
-                    break;
-                }
-         
-                default :
-                {
-                    return(qfalse);
-                }
-            }
-  
-            break;
-        }
-
-        case PNG_ColourType_GreyAlpha :
-        {
-            switch(IHDR->BitDepth)
-            {
-                case PNG_BitDepth_8 :
-                case PNG_BitDepth_16 :
-                {
-                    BytesPerPixel    = (IHDR->BitDepth / 8) * PNG_NumColourComponents_GreyAlpha;
-                    PixelsPerByte    = 1;
-
-                    break;
-                }
-     
-                default :
-                {
-                    return(qfalse);
-                }
-            }
-  
-            break;
-        }
-
-        case PNG_ColourType_TrueAlpha :
-        {
-            switch(IHDR->BitDepth)
-            {
-                case PNG_BitDepth_8 :
-                case PNG_BitDepth_16 :
-                {
-                    BytesPerPixel    = (IHDR->BitDepth / 8) * PNG_NumColourComponents_TrueAlpha;
-                    PixelsPerByte    = 1;
-
-                    break;
-                }
-    
-                default :
-                {
-                    return(qfalse);
-                }
-            }
-
-            break;
-        }
-
-        default :
-        {
-            return(qfalse);
-        }
-    }
-
-    /*
-     *  Calculate the size of one scanline
-     */
-
-    BytesPerScanline = (IHDR_Width * BytesPerPixel + (PixelsPerByte - 1)) / PixelsPerByte;
-
-    /*
-     *  Check if we have enough data for the whole image.
-     */
-
-    if(!(DecompressedDataLength == ((BytesPerScanline + 1) * IHDR_Height)))
-    {
-        return(qfalse);
-    }
-
-    /*
-     *  Unfilter the image.
-     */
-
-    if(!UnfilterImage(DecompressedData, IHDR_Height, BytesPerScanline, BytesPerPixel))
-    {
-        return(qfalse);
-    }
-
-    /*
-     *  Set the working pointers to the beginning of the buffers.
-     */
-
-    OutPtr = OutBuffer;
-    DecompPtr = DecompressedData;
-
-    /*
-     *  Create the output image.
-     */
-
-    for(h = 0; h < IHDR_Height; h++)
-    {
-        /*
-         *  Count the pixels on the scanline for those multipixel bytes
-         */
-
-        uint32_t CurrPixel;
-  
-        /*
-         *  skip FilterType
-         */
-
-        DecompPtr++;
-
-        /*
-         *  Reset the pixel count.
-         */
-
-        CurrPixel = 0;
-
-        for(w = 0; w < (BytesPerScanline / BytesPerPixel); w++)
-        {
-	    if(PixelsPerByte > 1)
-	    {
-                uint8_t  Mask;
-                uint32_t Shift;
-		uint8_t  SinglePixel;
-
-                for(p = 0; p < PixelsPerByte; p++)
-                {
-                    if(CurrPixel < IHDR_Width)
-                    {
-                        Mask  = (1 << IHDR->BitDepth) - 1;
-                        Shift = (PixelsPerByte - 1 - p) * IHDR->BitDepth;
-
-                        SinglePixel = ((DecompPtr[0] & (Mask << Shift)) >> Shift);
-
-			if(!ConvertPixel(IHDR, OutPtr, &SinglePixel, HasTransparentColour, TransparentColour, OutPal))
-			{
-			    return(qfalse);
-			}
-
-                        OutPtr += Q3IMAGE_BYTESPERPIXEL;
-                        CurrPixel++;
-                    }
-                }
-	    
-	    }
-	    else
-	    {
-		if(!ConvertPixel(IHDR, OutPtr, DecompPtr, HasTransparentColour, TransparentColour, OutPal))
-		{
-		    return(qfalse);
-		}
-  
-
-                OutPtr += Q3IMAGE_BYTESPERPIXEL;
-	    }
-
-            DecompPtr += BytesPerPixel;
-        }
-    }
-
-    return(qtrue);
-}
-
-/*
- *  Decode an interlaced image.
- */
-
-static qboolean DecodeImageInterlaced(struct PNG_Chunk_IHDR *IHDR,
-                                      byte                  *OutBuffer, 
-                                      uint8_t               *DecompressedData,
-                                      uint32_t               DecompressedDataLength,
-                                      qboolean               HasTransparentColour,
-                                      uint8_t               *TransparentColour,
-                                      uint8_t               *OutPal)
-{
-    uint32_t IHDR_Width;
-    uint32_t IHDR_Height;
-    uint32_t BytesPerScanline[PNG_Adam7_NumPasses], BytesPerPixel, PixelsPerByte;
-    uint32_t PassWidth[PNG_Adam7_NumPasses], PassHeight[PNG_Adam7_NumPasses];
-    uint32_t WSkip[PNG_Adam7_NumPasses], WOffset[PNG_Adam7_NumPasses], HSkip[PNG_Adam7_NumPasses], HOffset[PNG_Adam7_NumPasses];
-    uint32_t w, h, p, a;
-    byte *OutPtr;
-    uint8_t *DecompPtr;
-    uint32_t TargetLength;
-
-    /*
-     *  input verification
-     */
-
-    if(!(IHDR && OutBuffer && DecompressedData && DecompressedDataLength && TransparentColour && OutPal))
-    {
-	return(qfalse);
-    }
-
-    /*
-     *  byte swapping
-     */
-
-    IHDR_Width  = BigLong(IHDR->Width);
-    IHDR_Height = BigLong(IHDR->Height);
-
-    /*
-     *  Skip and Offset for the passes.
-     */
-
-    WSkip[0]   = 8;
-    WOffset[0] = 0;
-    HSkip[0]   = 8;
-    HOffset[0] = 0;
-
-    WSkip[1]   = 8;
-    WOffset[1] = 4;
-    HSkip[1]   = 8;
-    HOffset[1] = 0;
-
-    WSkip[2]   = 4;
-    WOffset[2] = 0;
-    HSkip[2]   = 8;
-    HOffset[2] = 4;
-
-    WSkip[3]   = 4;
-    WOffset[3] = 2;
-    HSkip[3]   = 4;
-    HOffset[3] = 0;
-
-    WSkip[4]   = 2;
-    WOffset[4] = 0;
-    HSkip[4]   = 4;
-    HOffset[4] = 2;
-
-    WSkip[5]   = 2;
-    WOffset[5] = 1;
-    HSkip[5]   = 2;
-    HOffset[5] = 0;
-
-    WSkip[6]   = 1;
-    WOffset[6] = 0;
-    HSkip[6]   = 2;
-    HOffset[6] = 1;
-
-    /*
-     *  Calculate the sizes of the passes.
-     */
-
-    PassWidth[0]  = (IHDR_Width  + 7) / 8;
-    PassHeight[0] = (IHDR_Height + 7) / 8;
-
-    PassWidth[1]  = (IHDR_Width  + 3) / 8;
-    PassHeight[1] = (IHDR_Height + 7) / 8;
-
-    PassWidth[2]  = (IHDR_Width  + 3) / 4;
-    PassHeight[2] = (IHDR_Height + 3) / 8;
-
-    PassWidth[3]  = (IHDR_Width  + 1) / 4;
-    PassHeight[3] = (IHDR_Height + 3) / 4;
-
-    PassWidth[4]  = (IHDR_Width  + 1) / 2;
-    PassHeight[4] = (IHDR_Height + 1) / 4;
-
-    PassWidth[5]  = (IHDR_Width  + 0) / 2;
-    PassHeight[5] = (IHDR_Height + 1) / 2;
-
-    PassWidth[6]  = (IHDR_Width  + 0) / 1;
-    PassHeight[6] = (IHDR_Height + 0) / 2;
-
-    /*
-     *  information for un-filtering
-     */
-
-    switch(IHDR->ColourType)
-    {
-        case PNG_ColourType_Grey :
-        {
-            switch(IHDR->BitDepth)
-            {
-                case PNG_BitDepth_1 :
-                case PNG_BitDepth_2 :
-                case PNG_BitDepth_4 :
-                {
-                    BytesPerPixel    = 1;
-                    PixelsPerByte    = 8 / IHDR->BitDepth;
-
-                    break;
-                }
-
-                case PNG_BitDepth_8  :
-                case PNG_BitDepth_16 :
-                {
-                    BytesPerPixel    = (IHDR->BitDepth / 8) * PNG_NumColourComponents_Grey;
-                    PixelsPerByte    = 1;
-
-                    break;
-                }
-
-                default :
-                {
-                    return(qfalse);
-                }
-            }
-  
-            break;
-        }
-  
-        case PNG_ColourType_True :
-        {
-            switch(IHDR->BitDepth)
-            {
-                case PNG_BitDepth_8  :
-                case PNG_BitDepth_16 :
-                {
-                    BytesPerPixel    = (IHDR->BitDepth / 8) * PNG_NumColourComponents_True;
-                    PixelsPerByte    = 1;
-
-                    break;
-                }
-     
-                default :
-                {
-                    return(qfalse);
-                }
-            }
-  
-            break;
-        }
-
-        case PNG_ColourType_Indexed :
-        {
-            switch(IHDR->BitDepth)
-            {
-                case PNG_BitDepth_1 :
-                case PNG_BitDepth_2 :
-                case PNG_BitDepth_4 :
-                {
-                    BytesPerPixel    = 1;
-                    PixelsPerByte    = 8 / IHDR->BitDepth;
-
-                    break;
-                }
-
-                case PNG_BitDepth_8 :
-                {
-                    BytesPerPixel    = PNG_NumColourComponents_Indexed;
-                    PixelsPerByte    = 1;
-
-                    break;
-                }
-         
-                default :
-                {
-                    return(qfalse);
-                }
-            }
-  
-            break;
-        }
-
-        case PNG_ColourType_GreyAlpha :
-        {
-            switch(IHDR->BitDepth)
-            {
-                case PNG_BitDepth_8 :
-                case PNG_BitDepth_16 :
-                {
-                    BytesPerPixel    = (IHDR->BitDepth / 8) * PNG_NumColourComponents_GreyAlpha;
-                    PixelsPerByte    = 1;
-
-                    break;
-                }
-     
-                default :
-                {
-                    return(qfalse);
-                }
-            }
-  
-            break;
-        }
-
-        case PNG_ColourType_TrueAlpha :
-        {
-            switch(IHDR->BitDepth)
-            {
-                case PNG_BitDepth_8 :
-                case PNG_BitDepth_16 :
-                {
-                    BytesPerPixel    = (IHDR->BitDepth / 8) * PNG_NumColourComponents_TrueAlpha;
-                    PixelsPerByte    = 1;
-
-                    break;
-                }
-    
-                default :
-                {
-                    return(qfalse);
-                }
-            }
-
-            break;
-        }
-
-        default :
-        {
-            return(qfalse);
-        }
-    }
-
-    /*
-     *  Calculate the size of the scanlines per pass
-     */
-
-    for(a = 0; a < PNG_Adam7_NumPasses; a++)
-    {
-	BytesPerScanline[a] = (PassWidth[a] * BytesPerPixel + (PixelsPerByte - 1)) / PixelsPerByte;
-    }
-
-    /*
-     *  Calculate the size of all passes
-     */
-
-    TargetLength = 0;
-
-    for(a = 0; a < PNG_Adam7_NumPasses; a++)
-    {
-	TargetLength += ((BytesPerScanline[a] + (BytesPerScanline[a] ? 1 : 0)) * PassHeight[a]);
-    }
-
-    /*
-     *  Check if we have enough data for the whole image.
-     */
-
-    if(!(DecompressedDataLength == TargetLength))
-    {
-        return(qfalse);
-    }
-
-    /*
-     *  Unfilter the image.
-     */
-
-    DecompPtr = DecompressedData;
-
-    for(a = 0; a < PNG_Adam7_NumPasses; a++)
-    {
-        if(!UnfilterImage(DecompPtr, PassHeight[a], BytesPerScanline[a], BytesPerPixel))
-        {
-            return(qfalse);
-        }
-	
-	DecompPtr += ((BytesPerScanline[a] + (BytesPerScanline[a] ? 1 : 0)) * PassHeight[a]);
-    }
-
-    /*
-     *  Set the working pointers to the beginning of the buffers.
-     */
-
-    DecompPtr = DecompressedData;
-
-    /*
-     *  Create the output image.
-     */
-
-    for(a = 0; a < PNG_Adam7_NumPasses; a++)
-    {
-        for(h = 0; h < PassHeight[a]; h++)
-        {
-            /*
-             *  Count the pixels on the scanline for those multipixel bytes
-             */
-
-            uint32_t CurrPixel;
-
-            /*
-             *  skip FilterType
-             */
-
-            DecompPtr++;
-
-            /*
-             *  Reset the pixel count.
-             */
-
-            CurrPixel = 0;
-
-            for(w = 0; w < (BytesPerScanline[a] / BytesPerPixel); w++)
-            {
-        	if(PixelsPerByte > 1)
-	        {
-                    uint8_t  Mask;
-                    uint32_t Shift;
-		    uint8_t  SinglePixel;
-
-                    for(p = 0; p < PixelsPerByte; p++)
-                    {
-                        if(CurrPixel < PassWidth[a])
-                        {
-                            Mask  = (1 << IHDR->BitDepth) - 1;
-                            Shift = (PixelsPerByte - 1 - p) * IHDR->BitDepth;
-
-                            SinglePixel = ((DecompPtr[0] & (Mask << Shift)) >> Shift);
-
-    			    OutPtr = OutBuffer + (((((h * HSkip[a]) + HOffset[a]) * IHDR_Width) + ((CurrPixel * WSkip[a]) + WOffset[a])) * Q3IMAGE_BYTESPERPIXEL);
-
-    			    if(!ConvertPixel(IHDR, OutPtr, &SinglePixel, HasTransparentColour, TransparentColour, OutPal))
-			    {
-			        return(qfalse);
-			    }
-
-                            CurrPixel++;
-                        }
-                    }
-	    
-	        }
-    	        else
-	        {
-	    	    OutPtr = OutBuffer + (((((h * HSkip[a]) + HOffset[a]) * IHDR_Width) + ((w * WSkip[a]) + WOffset[a])) * Q3IMAGE_BYTESPERPIXEL);
-
-		    if(!ConvertPixel(IHDR, OutPtr, DecompPtr, HasTransparentColour, TransparentColour, OutPal))
-		    {
-		        return(qfalse);
-		    }
-	        }
-
-                DecompPtr += BytesPerPixel;
-            }
-        }
-    }
-
-    return(qtrue);
-}
-
-/*
- *  The PNG loader
- */
-
-static void LoadPNG(const char *name, byte **pic, int *width, int *height)
-{
-    struct BufferedFile *ThePNG;
-    byte *OutBuffer;
-    uint8_t *Signature;
-    struct PNG_ChunkHeader *CH;
-    uint32_t ChunkHeaderLength;
-    uint32_t ChunkHeaderType;
-    struct PNG_Chunk_IHDR *IHDR;
-    uint32_t IHDR_Width;
-    uint32_t IHDR_Height;
-    PNG_ChunkCRC *CRC;
-    uint8_t *InPal;
-    uint8_t *DecompressedData;
-    uint32_t DecompressedDataLength;
-    uint32_t i;
-
-    /*
-     *  palette with 256 RGBA entries
-     */
-
-    uint8_t OutPal[1024];
-
-    /*
-     *  transparent colour from the tRNS chunk
-     */
-
-    qboolean HasTransparentColour = qfalse;
-    uint8_t TransparentColour[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
-
-    /*
-     *  input verification
-     */
-
-    if(!(name && pic))
-    {
-        return;
-    }
-
-    /*
-     *  Zero out return values.
-     */
-
-    *pic = NULL;
-
-    if(width)
-    {
-        *width = 0;
-    }
-
-    if(height)
-    {
-        *height = 0;
-    }
-
-    /*
-     *  Read the file.
-     */
-
-    ThePNG = ReadBufferedFile(name);
-    if(!ThePNG)
-    {
-        return;
-    }           
-
-    /*
-     *  Read the siganture of the file.
-     */
-
-    Signature = BufferedFileRead(ThePNG, PNG_Signature_Size);
-    if(!Signature)
-    {
-        CloseBufferedFile(ThePNG);
- 
-        return;
-    }
- 
-    /*
-     *  Is it a PNG?
-     */
-
-    if(memcmp(Signature, PNG_Signature, PNG_Signature_Size))
-    {
-        CloseBufferedFile(ThePNG);
- 
-        return; 
-    }
-
-    /*
-     *  Read the first chunk-header.
-     */
-
-    CH = BufferedFileRead(ThePNG, PNG_ChunkHeader_Size);
-    if(!CH)
-    {
-        CloseBufferedFile(ThePNG);
- 
-        return; 
-    }
-
-    /*
-     *  PNG multi-byte types are in Big Endian
-     */
-
-    ChunkHeaderLength = BigLong(CH->Length);
-    ChunkHeaderType   = BigLong(CH->Type);
-
-    /*
-     *  Check if the first chunk is an IHDR.
-     */
-
-    if(!((ChunkHeaderType == PNG_ChunkType_IHDR) && (ChunkHeaderLength == PNG_Chunk_IHDR_Size)))
-    {
-        CloseBufferedFile(ThePNG);
- 
-        return; 
-    }
-
-    /*
-     *  Read the IHDR.
-     */ 
-
-    IHDR = BufferedFileRead(ThePNG, PNG_Chunk_IHDR_Size);
-    if(!IHDR)
-    {
-        CloseBufferedFile(ThePNG);
- 
-        return; 
-    }
-
-    /*
-     *  Read the CRC for IHDR
-     */
-
-    CRC = BufferedFileRead(ThePNG, PNG_ChunkCRC_Size);
-    if(!CRC)
-    {
-        CloseBufferedFile(ThePNG);
- 
-        return; 
-    }
- 
-    /*
-     *  Here we could check the CRC if we wanted to.
-     */
- 
-    /*
-     *  multi-byte type swapping
-     */
-
-    IHDR_Width  = BigLong(IHDR->Width);
-    IHDR_Height = BigLong(IHDR->Height);
- 
-    /*
-     *  Check if Width and Height are valid.
-     */
-
-    if(!((IHDR_Width > 0) && (IHDR_Height > 0)))
-    {
-        CloseBufferedFile(ThePNG);
- 
-        return; 
-    }
-
-    /*
-     *  Do we need to check if the dimensions of the image are valid for Quake3?
-     */
-
-    /*
-     *  Check if CompressionMethod and FilterMethod are valid.
-     */
-
-    if(!((IHDR->CompressionMethod == PNG_CompressionMethod_0) && (IHDR->FilterMethod == PNG_FilterMethod_0)))
-    {
-        CloseBufferedFile(ThePNG);
- 
-        return; 
-    }
-
-    /*
-     *  Check if InterlaceMethod is valid.
-     */
-
-    if(!((IHDR->InterlaceMethod == PNG_InterlaceMethod_NonInterlaced)  || (IHDR->InterlaceMethod == PNG_InterlaceMethod_Interlaced)))
-    {
-        CloseBufferedFile(ThePNG);
- 
-        return;
-    }
-
-    /*
-     *  Read palette for an indexed image.
-     */
-
-    if(IHDR->ColourType == PNG_ColourType_Indexed)
-    {
-        /*
-         *  We need the palette first.
-         */
-
-        if(!FindChunk(ThePNG, PNG_ChunkType_PLTE))
-        {
-            CloseBufferedFile(ThePNG);
-  
-            return;
-        }
-
-        /*
-         *  Read the chunk-header.
-         */
-
-        CH = BufferedFileRead(ThePNG, PNG_ChunkHeader_Size);
-        if(!CH)
-        {
-            CloseBufferedFile(ThePNG);
-   
-            return; 
-        }
-
-        /*
-         *  PNG multi-byte types are in Big Endian
-         */
-
-        ChunkHeaderLength = BigLong(CH->Length);
-        ChunkHeaderType   = BigLong(CH->Type);
-  
-        /*
-         *  Check if the chunk is an PLTE.
-         */
-
-        if(!(ChunkHeaderType == PNG_ChunkType_PLTE))
-        {
-            CloseBufferedFile(ThePNG);
-   
-            return; 
-        }
-
-        /*
-         *  Check if Length is divisible by 3
-         */
-
-        if(ChunkHeaderLength % 3)
-        {
-            CloseBufferedFile(ThePNG);
-   
-            return;   
-        }
-
-        /*
-         *  Read the raw palette data
-         */
-
-        InPal = BufferedFileRead(ThePNG, ChunkHeaderLength);
-        if(!InPal)
-        {
-            CloseBufferedFile(ThePNG);
-   
-            return; 
-        }
-   
-        /*
-         *  Read the CRC for the palette
-         */
-
-        CRC = BufferedFileRead(ThePNG, PNG_ChunkCRC_Size);
-        if(!CRC)
-        {
-            CloseBufferedFile(ThePNG);
- 
-            return; 
-        }
-
-        /*
-         *  Set some default values.
-         */
-
-        for(i = 0; i < 256; i++)
-        {
-            OutPal[i * Q3IMAGE_BYTESPERPIXEL + 0] = 0x00;
-            OutPal[i * Q3IMAGE_BYTESPERPIXEL + 1] = 0x00;
-            OutPal[i * Q3IMAGE_BYTESPERPIXEL + 2] = 0x00;
-            OutPal[i * Q3IMAGE_BYTESPERPIXEL + 3] = 0xFF;  
-        }
-
-        /*
-         *  Convert to the Quake3 RGBA-format.
-         */
-
-        for(i = 0; i < (ChunkHeaderLength / 3); i++)
-        {
-            OutPal[i * Q3IMAGE_BYTESPERPIXEL + 0] = InPal[i*3+0];
-            OutPal[i * Q3IMAGE_BYTESPERPIXEL + 1] = InPal[i*3+1];
-            OutPal[i * Q3IMAGE_BYTESPERPIXEL + 2] = InPal[i*3+2];
-            OutPal[i * Q3IMAGE_BYTESPERPIXEL + 3] = 0xFF;
-        }
-    }
-
-    /*
-     *  transparency information is sometimes stored in an tRNS chunk
-     */
-
-    /*
-     *  Let's see if there is a tRNS chunk
-     */
-
-    if(FindChunk(ThePNG, PNG_ChunkType_tRNS))
-    {
-        uint8_t *Trans;
-
-        /*
-         *  Read the chunk-header.
-         */
-
-        CH = BufferedFileRead(ThePNG, PNG_ChunkHeader_Size);
-        if(!CH)
-        {
-            CloseBufferedFile(ThePNG);
- 
-            return; 
-        }
-
-        /*
-         *  PNG multi-byte types are in Big Endian
-         */
-
-        ChunkHeaderLength = BigLong(CH->Length);
-        ChunkHeaderType   = BigLong(CH->Type);
-
-        /*
-         *  Check if the chunk is an tRNS.
-         */
-
-        if(!(ChunkHeaderType == PNG_ChunkType_tRNS))
-        {
-            CloseBufferedFile(ThePNG);
- 
-            return; 
-        }
-
-        /*
-         *  Read the transparency information.
-         */
-
-        Trans = BufferedFileRead(ThePNG, ChunkHeaderLength);
-        if(!Trans)
-        {
-            CloseBufferedFile(ThePNG);
- 
-            return;  
-        }
-
-        /*
-         *  Read the CRC.
-         */
-
-        CRC = BufferedFileRead(ThePNG, PNG_ChunkCRC_Size);
-        if(!CRC)
-        {
-            CloseBufferedFile(ThePNG);
-  
-            return; 
-        }
- 
-        /*
-         *  Only for Grey, True and Indexed ColourType should tRNS exist.
-         */
-
-        switch(IHDR->ColourType)
-        {
-            case PNG_ColourType_Grey :
-            {
-                if(!ChunkHeaderLength == 2)
-                {
-                    CloseBufferedFile(ThePNG);
-  
-                    return;    
-                }
-   
-                HasTransparentColour = qtrue;
-   
-		/*
-		 *  Grey can have one colour which is completely transparent.
-		 *  This colour is always stored in 16 bits.
-		 */
-
-                TransparentColour[0] = Trans[0];
-                TransparentColour[1] = Trans[1];
-   
-                break;
-            }
-   
-            case PNG_ColourType_True :
-            {
-                if(!ChunkHeaderLength == 6)
-                {
-                    CloseBufferedFile(ThePNG);
-  
-                    return;    
-                }
-   
-                HasTransparentColour = qtrue;
-
-		/*
-		 *  True can have one colour which is completely transparent.
-		 *  This colour is always stored in 16 bits.
-		 */
-
-                TransparentColour[0] = Trans[0];
-                TransparentColour[1] = Trans[1];
-                TransparentColour[2] = Trans[2];
-                TransparentColour[3] = Trans[3];
-                TransparentColour[4] = Trans[4];
-                TransparentColour[5] = Trans[5];
-   
-                break;
-            }
-   
-            case PNG_ColourType_Indexed :
-            {
-                /*
-		 *  Maximum of 256 one byte transparency entries.
-		 */
-		
-		if(ChunkHeaderLength > 256)
-                {
-                    CloseBufferedFile(ThePNG);
-  
-                    return;    
-                }
-
-                HasTransparentColour = qtrue;
-
-                /*
-                 *  alpha values for palette entries
-                 */
-
-                for(i = 0; i < ChunkHeaderLength; i++)
-                {
-                    OutPal[i * Q3IMAGE_BYTESPERPIXEL + 3] = Trans[i];
-                }
-
-                break;
+		Vector4Copy(mv,bmv);
             }
   
-            /*
-             *  All other ColourTypes should not have tRNS chunks
-             */
-
-            default :
+	mean_variance(x, y-KWH_RADIUS, x+KWH_RADIUS, y, columns, rows, targa_rgba, mv);
+	if( mv[3] < bmv[3] )
             {
-                CloseBufferedFile(ThePNG);
-  
-                return;
-            }
-        } 
+		Vector4Copy(mv,bmv);
     }
 
-    /*
-     *  Rewind to the start of the file.
-     */
-
-    if(!BufferedFileRewind(ThePNG, -1))
+	mean_variance(x, y, x+KWH_RADIUS, y+KWH_RADIUS, columns, rows, targa_rgba, mv);
+	if( mv[3] < bmv[3] )
     {
-        CloseBufferedFile(ThePNG);
- 
-        return; 
+		Vector4Copy(mv,bmv);
     }
  
-    /*
-     *  Skip the signature
-     */
-
-    if(!BufferedFileSkip(ThePNG, PNG_Signature_Size))
+	mean_variance(x-KWH_RADIUS, y, x, y+KWH_RADIUS, columns, rows, targa_rgba, mv);
+	if( mv[3] < bmv[3] )
     {
-        CloseBufferedFile(ThePNG);
- 
-        return; 
+		Vector4Copy(mv,bmv);
     }
-
-    /*
-     *  Decompress all IDAT chunks
-     */
-
-    DecompressedDataLength = DecompressIDATs(ThePNG, &DecompressedData);
-    if(!(DecompressedDataLength && DecompressedData))
-    {
-        CloseBufferedFile(ThePNG);
- 
-        return;
     }
 
-    /*
-     *  Allocate output buffer.
-     */
-
-    OutBuffer = ri.Malloc(IHDR_Width * IHDR_Height * Q3IMAGE_BYTESPERPIXEL); 
-    if(!OutBuffer)
-    {
-        ri.Free(DecompressedData); 
-        CloseBufferedFile(ThePNG);
+static void kuwahara(int columns, int rows, byte *targa_rgba){
+	int		row, column;
+	vec4_t rgbv;
  
-        return;  
+	for(row=0;row<rows;row++){
+		for(column=0;column<columns;column++){
+			rgb_kuwahara(column, row, columns, rows, targa_rgba, rgbv);
+			setImageRGB(targa_rgba,column,row,columns,rows,rgbv);
     }
-
-    /*
-     *  Interlaced and Non-interlaced images need to be handled differently.
-     */
-
-    switch(IHDR->InterlaceMethod)
-    {
-	case PNG_InterlaceMethod_NonInterlaced :
-	{
-	    if(!DecodeImageNonInterlaced(IHDR, OutBuffer, DecompressedData, DecompressedDataLength, HasTransparentColour, TransparentColour, OutPal))
-	    {
-		ri.Free(OutBuffer); 
-    		ri.Free(DecompressedData); 
-    		CloseBufferedFile(ThePNG);
-
-		return;
 	    }
-	
-	    break;
 	}
 	
-	case PNG_InterlaceMethod_Interlaced :
-	{
-	    if(!DecodeImageInterlaced(IHDR, OutBuffer, DecompressedData, DecompressedDataLength, HasTransparentColour, TransparentColour, OutPal))
-	    {
-		ri.Free(OutBuffer); 
-    		ri.Free(DecompressedData); 
-    		CloseBufferedFile(ThePNG);
+/****************************
+Symmetric Nearest Neighbour
+****************************/
 
-		return;
-	    }
+#define SNN_RADIUS 3
 	
-	    break;
+static int deltaE(int l1,int a1,int b1,int l2,int a2,int b2)
+{
+	return (l1-l2)*(l1-l2) + (a1-a2)*(a1-a2) + (b1-b2)*(b1-b2);
 	}
     
-	default :
+static void snn(int columns, int rows, byte *targa_rgba)
 	{
-	    ri.Free(OutBuffer); 
-    	    ri.Free(DecompressedData); 
-    	    CloseBufferedFile(ThePNG);
 
-	    return;
-	}
+	int row, column;
+	unsigned short sumR, sumG, sumB;
+	unsigned short count;
+	short u, v;
+	byte r, g, b;
+	byte r1, g1, b1;
+	byte r2, g2, b2;
+	for(row=0;row<rows;row++){
+		for(column=0;column<columns;column++){
+			sumR=0;
+			sumG=0;
+			sumB=0;
+			count=0;
+			
+			r=getImageR(targa_rgba,column,row,columns,rows);
+			g=getImageG(targa_rgba,column,row,columns,rows);
+			b=getImageB(targa_rgba,column,row,columns,rows);
+			
+			for(v=-SNN_RADIUS;v<=0;v++)
+			{
+				for(u=-SNN_RADIUS;u<=SNN_RADIUS;u++)
+				{
+					if(v==0&&u>=0) break;
+					// Sum pixels values
+					r1=getImageR(targa_rgba,column+u,row+v,columns,rows);
+					g1=getImageG(targa_rgba,column+u,row+v,columns,rows);
+					b1=getImageB(targa_rgba,column+u,row+v,columns,rows);
+					
+					r2=getImageR(targa_rgba,column-u,row-v,columns,rows);
+					g2=getImageG(targa_rgba,column-u,row-v,columns,rows);
+					b2=getImageB(targa_rgba,column-u,row-v,columns,rows);
+					
+					if ( deltaE(r,g,b,r1,g1,b1) < deltaE(r,g,b,r2,g2,b2))
+					{
+						sumR += r1;
+						sumG += g1;
+						sumB += b1;
     }
-
-    /*
-     *  update the pointer to the image data
-     */
-
-    *pic = OutBuffer;
- 
-    /*
-     *  Fill width and height.
-     */
-
-    if(width)
+					else
     {
-        *width = IHDR_Width;
+						sumR += r2;
+						sumG += g2;
+						sumB += b2;
+					}
+					count++;
     }
-
-    if(height)
-    {
-        *height = IHDR_Height;
     }
 
-    /*
-     *  DecompressedData is not needed anymore.
-     */
-
-    ri.Free(DecompressedData); 
-
-    /*
-     *  We have all data, so close the file.
-     */
+			r=(byte)((int)(2*sumR+r)/(int)(2*count+1));
+			g=(byte)((int)(2*sumG+g)/(int)(2*count+1));
+			b=(byte)((int)(2*sumB+b)/(int)(2*count+1));
 
-    CloseBufferedFile(ThePNG);
+			setImageR(targa_rgba,column,row,columns,rows,r);
+			setImageG(targa_rgba,column,row,columns,rows,g);
+			setImageB(targa_rgba,column,row,columns,rows,b);
+		}
+	}
 }
 
 //===================================================================
@@ -4386,12 +1437,12 @@
 // when there are multiple images of different formats available
 static imageExtToLoaderMap_t imageLoaders[ ] =
 {
-	{ "tga",  LoadTGA },
-	{ "jpg",  LoadJPG },
-	{ "jpeg", LoadJPG },
-	{ "png",  LoadPNG },
-	{ "pcx",  LoadPCX32 },
-	{ "bmp",  LoadBMP }
+	{ "tga",  R_LoadTGA },
+	{ "jpg",  R_LoadJPG },
+	{ "jpeg", R_LoadJPG },
+	{ "png",  R_LoadPNG },
+	{ "pcx",  R_LoadPCX },
+	{ "bmp",  R_LoadBMP }
 };
 
 static int numImageLoaders = sizeof( imageLoaders ) /
@@ -4471,6 +1522,7 @@
 			break;
 		}
 	}
+	
 }
 
 
@@ -4482,12 +1534,17 @@
 Returns NULL if it fails, not a default image.
 ==============
 */
-image_t	*R_FindImageFile( const char *name, qboolean mipmap, qboolean allowPicmip, int glWrapClampMode ) {
+image_t	*R_FindImageFile( const char *name, qboolean mipmap, qboolean allowPicmip, int glWrapClampMode, qboolean cubemap,qboolean normals,qboolean forcealpha )
+{
 	image_t	*image;
+	image_t	*result;
 	int		width, height;
 	byte	*pic;
 	long	hash;
-
+	char	mushname[MAX_QPATH];
+	int		i;
+	static char	*suf[6] = {"lf","rt","ft","bk","dn","up"};
+	//						+x  -x   +y   -y    +z  -z
 	if (!name) {
 		return NULL;
 	}
@@ -4508,13 +1565,15 @@
 					ri.Printf( PRINT_DEVELOPER, "WARNING: reused image %s with mixed allowPicmip parm\n", name );
 				}
 				if ( image->wrapClampMode != glWrapClampMode ) {
-					ri.Printf( PRINT_ALL, "WARNING: reused image %s with mixed glWrapClampMode parm\n", name );
+					ri.Printf( PRINT_DEVELOPER, "WARNING: reused image %s with mixed glWrapClampMode parm\n", name );
 				}
 			}
 			return image;
 		}
 	}
 
+	if (!cubemap)
+	{
 	//
 	// load the pic from disk
 	//
@@ -4523,9 +1582,223 @@
 		return NULL;
 	}
 
-	image = R_CreateImage( ( char * ) name, pic, width, height, mipmap, allowPicmip, glWrapClampMode );
+		image = R_CreateImage( ( char * ) name, pic, width, height, mipmap, allowPicmip, glWrapClampMode,normals,forcealpha );
+		ri.Free( pic );
+		return image;
+	}
+
+	//cubemap, same as above except we're going to do this 6 times.
+	//	  cubemap = qtrue on r_createimage too
+	for ( i=0 ; i<6 ; i++ ) {
+		char rename[MAX_QPATH];   
+	
+		COM_StripExtension( name, mushname, sizeof(mushname ) );
+		Com_sprintf( rename, MAX_QPATH, "%s_%s.tga", mushname, suf[i] );
+		
+		R_LoadImage( rename, &pic, &width, &height );
+
+		if( i==0 ) {
+			if( !pic ) {
+				ri.Printf( PRINT_ALL, "WARNING: bad primary cubemap name %s\n", name );
+				return 0;
+			}
+			else {
+				image = R_CreateCubeImage( ( char * )rename, pic, width, height, mipmap, allowPicmip, glWrapClampMode, 1, 0 );
+				if( !image ) return 0;
+			}
+		}
+		else
+		{
+			if( !pic ) ri.Printf( PRINT_ALL, "WARNING: bad other face cubemap name %s\n", name );
+			result = R_CreateCubeImage( ( char * )rename, pic, width, height, mipmap, allowPicmip, glWrapClampMode, i, image );
+		}
+		
+		ri.Free( pic );
+	}
+	return image;
+}
+
+
+ID_INLINE float _GetLum(byte *src)
+{
+	float r,g,b;
+	float m0,m1;
+	r=src[0];
+	g=src[1];
+	b=src[2];
+	if (r>g && r>b) 
+	{
+		m0=r;
+	}
+	else
+	{
+		if (g>r && g>b)
+		{
+			m0=g;
+		}
+		else m0=b;
+	}
+	
+	if (r<g && r<b) 
+	{
+		m1=r;
+	}
+	else
+	{
+		if (g<r && g<b)
+		{
+			m1=g;
+		}
+		else m1=b;
+	}
+
+	return ((m0+m1)/2.0f)/255.0f;
+
+
+}
+
+image_t	*R_BuildNormalsFromBump( const char *name,qboolean UseAlphaInFile) 
+{
+	image_t	*image;
+	int		width, height;
+	byte	*pic;
+	byte	*output;
+	long	hash;
+	char	genname[MAX_QPATH*2];
+	int x,y;
+	int samplex,sampley;
+	float start;
+	vec3_t norm;
+	qboolean UseAlpha=qfalse;
+
+	
+	int xx,yy;
+	float dif;
+	float scale=2.0f;
+
+	if (!name) {
+		return NULL;
+	}
+
+
+	sprintf(genname,"%s_autob",name);
+	genname[MAX_QPATH-1]=0;
+
+	hash = generateHashValue(genname);
+
+	//
+	// see if the image is already loaded /generated
+	//
+	for (image=hashTable[hash]; image; image=image->next) 
+	{
+		if ( !strcmp( genname, image->imgName ) ) 
+		{
+			return image;
+		}
+	}
+
+	//
+	// load the pic from disk
+	//
+	R_LoadImage( name, &pic, &width, &height );
+	output = ri.Malloc(width*height*4);
+	
+	if ( pic == NULL ) 
+	{
+		return NULL;
+	}
+	
+	//Scan the image for alpha.  If its all "255" then this was probably a 24bpp image or less, and had no alpha.
+	if (UseAlphaInFile==qtrue)
+	{
+		for (y=0;y<height;y++)
+		{
+			for (x=0;x<width;x++)
+			{
+				if (pic[((x+(y*width))*4)+3 ]!=255) 
+				{
+					UseAlpha=qtrue;
+					break;
+				}
+			}
+			if (UseAlpha==qtrue) break;
+		}
+	}
+
+	//modify pic into normals
+	for (y=0;y<height;y++)
+	{
+		for (x=0;x<width;x++)
+		{
+			norm[0]=0;
+			norm[1]=0;
+			norm[2]=1; //or scale
+
+			start=_GetLum(&pic[(x+(y*width))*4]);
+
+			//kernel size, 5x5
+			for (yy=y-1;yy<y+2;yy++)
+			{
+				for (xx=x-1;xx<x+2;xx++)
+				{
+					samplex=xx;
+					sampley=yy;
+					if (samplex<0) samplex+=width;
+					if (samplex>width-1) samplex-=width;
+					if (sampley<0) sampley+=height;
+					if (sampley>height-1) sampley-=height;
+					
+					dif=start-_GetLum(&pic[(samplex+(sampley*width))*4]);
+					norm[0]+=(xx-x)*dif*scale;
+					norm[1]+=(yy-y)*dif*scale;
+					
+					
+				
+				}
+			}
+
+			VectorNormalize(norm);
+
+			//pack rgba?
+			output[ ((x+(y*width))*4)+0]=(byte)((norm[0])*127.0)+128;
+			output[ ((x+(y*width))*4)+1]=(byte)((norm[1])*127.0)+128;
+			output[ ((x+(y*width))*4)+2]=(byte)((norm[2])*127.0)+128;
+			//output[ ((x+(y*width))*4)+3]=(byte)32;//0;//pic[((x+(y*width))*4)+3 ];//(byte)res;
+
+			if (UseAlpha==qtrue)
+			{
+				output[ ((x+(y*width))*4)+3]=pic[((x+(y*width))*4)+3 ];//(byte)res;
+			}
+			else
+			{
+				output[ ((x+(y*width))*4)+3]=32;//(byte)res;
+			}
+
+		}
+
+	}
+	
+	//Downscale it by 1/2
+	if (1)
+	{
+		R_MipMap(output,width,height,qtrue);
+		width/=2;
+		height/=2;
+	}
+	
+
+//	if (1)
+//	{
+//		fileHandle_t handle=FS_FOpenFileWrite(va("%d_test_%d_%d.raw",hash,width,height));
+//		FS_Write(output,width*height*4,handle);
+//		FS_FCloseFile(handle);
+//	}
+
+	image = R_CreateImage( ( char * ) genname, output, width , height , qtrue, qfalse, GL_REPEAT,qtrue,qtrue );
+	ri.Free( output );
 	ri.Free( pic );
 	return image;
+	
 }
 
 
@@ -4559,7 +1832,7 @@
 			data[y][x][3] = 255;			
 		}
 	}
-	tr.dlightImage = R_CreateImage("*dlight", (byte *)data, DLIGHT_SIZE, DLIGHT_SIZE, qfalse, qfalse, GL_CLAMP );
+	tr.dlightImage = R_CreateImage("*dlight", (byte *)data, DLIGHT_SIZE, DLIGHT_SIZE, qfalse, qfalse, GL_CLAMP_TO_EDGE,qfalse,qfalse );
 }
 
 
@@ -4649,7 +1922,7 @@
 	// standard openGL clamping doesn't really do what we want -- it includes
 	// the border color at the edges.  OpenGL 1.2 has clamp-to-edge, which does
 	// what we want.
-	tr.fogImage = R_CreateImage("*fog", (byte *)data, FOG_S, FOG_T, qfalse, qfalse, GL_CLAMP );
+	tr.fogImage = R_CreateImage("*fog", (byte *)data, FOG_S, FOG_T, qfalse, qfalse, GL_CLAMP_TO_EDGE,qfalse,qfalse );
 	ri.Hunk_FreeTempMemory( data );
 
 	borderColor[0] = 1.0;
@@ -4665,10 +1938,10 @@
 R_CreateDefaultImage
 ==================
 */
-#define	DEFAULT_SIZE	72
-#define	HALF_SIZE		36
-#define	THIRD_SIZE		12
-#define 	TWOTHIRD_SIZE	24	
+#define	DEFAULT_SIZE	64
+#define	HALF_SIZE		32
+#define	THIRD_SIZE		10
+#define 	TWOTHIRD_SIZE	21	
 static void R_CreateDefaultImage( void ) {
 	int		x,y;
 	byte	data[DEFAULT_SIZE][DEFAULT_SIZE][4];
@@ -4676,90 +1949,16 @@
 	// the default image will be a box, to allow you to see the mapping coordinates
 	Com_Memset( data, 0, sizeof( data ) );
 	
-
-for (y = 0 ; y < THIRD_SIZE; y++)
-   {
       for (x=0; x < DEFAULT_SIZE; x++)
+		for (y=0;y<DEFAULT_SIZE;y++)
       {
-         data[y][x][0]=255;
-         data[y][x][1]=0;
-         data[y][x][2]=0;
-         data[y][x][3]=255;
-
-         data[y+THIRD_SIZE][x][0]=255;
-         data[y+THIRD_SIZE][x][1]=255;
-         data[y+THIRD_SIZE][x][2]=255;
-         data[y+THIRD_SIZE][x][3]=255;
-
-         data[y+TWOTHIRD_SIZE][x][0]=0;
-         data[y+TWOTHIRD_SIZE][x][1]=0;
-         data[y+TWOTHIRD_SIZE][x][2]=255;
-         data[y+TWOTHIRD_SIZE][x][3]=255;
-
-         data[y+TWOTHIRD_SIZE+THIRD_SIZE][x][0]=255;
-         data[y+TWOTHIRD_SIZE+THIRD_SIZE][x][1]=0;
-         data[y+TWOTHIRD_SIZE+THIRD_SIZE][x][2]=0;
-         data[y+TWOTHIRD_SIZE+THIRD_SIZE][x][3]=255;
-
-         data[y+TWOTHIRD_SIZE+TWOTHIRD_SIZE][x][0]=255;
-         data[y+TWOTHIRD_SIZE+TWOTHIRD_SIZE][x][1]=255;
-         data[y+TWOTHIRD_SIZE+TWOTHIRD_SIZE][x][2]=255;
-         data[y+TWOTHIRD_SIZE+TWOTHIRD_SIZE][x][3]=255;
-
-         data[y+TWOTHIRD_SIZE+TWOTHIRD_SIZE+THIRD_SIZE][x][0]=0;
-         data[y+TWOTHIRD_SIZE+TWOTHIRD_SIZE+THIRD_SIZE][x][1]=0;
-         data[y+TWOTHIRD_SIZE+TWOTHIRD_SIZE+THIRD_SIZE][x][2]=255;
-         data[y+TWOTHIRD_SIZE+TWOTHIRD_SIZE+THIRD_SIZE][x][3]=255;
-
-      }
-   }
-
-
-
-
-for ( x = 0 ; x < DEFAULT_SIZE ; x++ ) {
-		data[0][x][0] = 255;
-		data[0][x][1] = 100;
-		data[0][x][2] = 0;
-		data[0][x][3] = 255;
-
-		data[HALF_SIZE][x][0] = 255;
-		data[HALF_SIZE][x][1] = 100;
-		data[HALF_SIZE][x][2] = 0;
-		data[HALF_SIZE][x][3] = 255;
-
-		data[HALF_SIZE-1][x][0] = 255;
-		data[HALF_SIZE-1][x][1] = 100;
-		data[HALF_SIZE-1][x][2] = 0;
-		data[HALF_SIZE-1][x][3] = 255;
-
-		data[DEFAULT_SIZE-1][x][0] = 255;
-		data[DEFAULT_SIZE-1][x][1] = 100;
-		data[DEFAULT_SIZE-1][x][2] = 0;
-		data[DEFAULT_SIZE-1][x][3] = 255;
-
-		data[x][0][0] = 255;
-		data[x][0][1] = 100;
-		data[x][0][2] = 0;
-		data[x][0][3] = 255;
-
-		data[x][HALF_SIZE][0] = 255;
-		data[x][HALF_SIZE][1] = 100;
-		data[x][HALF_SIZE][2] = 0;
-		data[x][HALF_SIZE][3] = 255;
-
-		data[x][HALF_SIZE-1][0] = 255;
-		data[x][HALF_SIZE-1][1] = 100;
-		data[x][HALF_SIZE-1][2] = 0;
-		data[x][HALF_SIZE-1][3] = 255;
-
-		data[x][DEFAULT_SIZE-1][0] = 255;
-		data[x][DEFAULT_SIZE-1][1] = 100;
-		data[x][DEFAULT_SIZE-1][2] = 0;
-		data[x][DEFAULT_SIZE-1][3] = 255;
+			data[x][y][0]=127;
+			data[x][y][1]=127;
+			data[x][y][2]=255;
+			data[x][y][3]=255;
 	}
 
-	tr.defaultImage = R_CreateImage("*default", (byte *)data, DEFAULT_SIZE, DEFAULT_SIZE, qtrue, qfalse, GL_REPEAT );
+	tr.defaultImage = R_CreateImage("*default", (byte *)data, DEFAULT_SIZE, DEFAULT_SIZE, qtrue, qfalse, GL_REPEAT ,qfalse,qfalse);
 }
 
 /*
@@ -4768,9 +1967,10 @@
 ==================
 */
 void R_CreateBuiltinImages( void ) {
-	int		x,y;
+	int		x,y,i;
 	byte	data[DEFAULT_SIZE][DEFAULT_SIZE][4];
 
+
 	R_CreateDefaultImage();
 
 	// we use a solid white image instead of disabling texturing
@@ -4775,7 +1975,35 @@
 
 	// we use a solid white image instead of disabling texturing
 	Com_Memset( data, 255, sizeof( data ) );
-	tr.whiteImage = R_CreateImage("*white", (byte *)data, 8, 8, qfalse, qfalse, GL_REPEAT );
+	tr.whiteImage = R_CreateImage("*white", (byte *)data, 8, 8, qfalse, qfalse, GL_REPEAT ,qfalse,qfalse);
+
+	// we use a solid white image instead of disabling texturing
+	Com_Memset( data, 0, sizeof( data ) );
+	tr.blackImage = R_CreateImage("*black", (byte *)data, 8, 8, qfalse, qfalse, GL_REPEAT ,qfalse,qfalse);
+
+	Com_Memset( data, 127, sizeof( data ) );
+	tr.greyImage = R_CreateImage("*grey", (byte *)data, 8, 8, qfalse, qfalse, GL_REPEAT ,qfalse,qfalse);
+
+	for (x=0;x<DEFAULT_SIZE;x++)
+		for (y=0;y<DEFAULT_SIZE;y++)
+		{
+			data[x][y][0]=0;
+			data[x][y][1]=127;
+			data[x][y][2]=0;
+			data[x][y][3]=255;
+		}
+	tr.greenImage = R_CreateImage("*green", (byte *)data, 8, 8, qfalse, qfalse, GL_REPEAT ,qfalse,qfalse);
+
+
+	for (x=0;x<DEFAULT_SIZE;x++)
+		for (y=0;y<DEFAULT_SIZE;y++)
+		{
+			data[x][y][0]=127;
+			data[x][y][1]=127;
+			data[x][y][2]=255;
+			data[x][y][3]=255;
+		}
+	tr.normalImage =       R_CreateImage("*normal",        (byte *)data, DEFAULT_SIZE, DEFAULT_SIZE, qfalse, qfalse, GL_REPEAT ,qfalse,qfalse);
 
 	// with overbright bits active, we need an image which is some fraction of full color,
 	// for default lightmaps, etc
@@ -4788,16 +2016,51 @@
 		}
 	}
 
-	tr.identityLightImage = R_CreateImage("*identityLight", (byte *)data, 8, 8, qfalse, qfalse, GL_REPEAT );
+	tr.identityLightImage = R_CreateImage("*identityLight", (byte *)data, 8, 8, qfalse, qfalse, GL_REPEAT ,qfalse,qfalse);
 
 
 	for(x=0;x<32;x++) {
 		// scratchimage is usually used for cinematic drawing
-		tr.scratchImage[x] = R_CreateImage("*scratch", (byte *)data, DEFAULT_SIZE, DEFAULT_SIZE, qfalse, qtrue, GL_CLAMP );
+		tr.scratchImage[x] = R_CreateImage("*scratch", (byte *)data, DEFAULT_SIZE, DEFAULT_SIZE, qfalse, qtrue, GL_CLAMP_TO_EDGE ,qfalse,qfalse);
 	}
 
 	R_CreateDlightImage();
 	R_CreateFogImage();
+
+
+	//Create Cubemap
+	for ( x=0 ; x<DEFAULT_SIZE ; x++ ) 
+	{
+		for ( y=0 ; y<DEFAULT_SIZE ; y++ ) 
+		{
+			data[y][x][0] = 0;
+			data[y][x][1] = 0;
+			data[y][x][2] = 0;
+			data[y][x][3] = 255;			
+		}
+	}
+	
+	for ( i=0 ; i<6 ; i++ )
+	{
+		
+		if ( i==0 )
+		{
+			tr.blackCubeImage = R_CreateCubeImage( "*blackcube",(byte *)data, DEFAULT_SIZE,DEFAULT_SIZE, qfalse, qfalse, GL_REPEAT, 1, NULL );
+		}
+		else
+		{
+			image_t *result;
+			result = R_CreateCubeImage( "*blackcube",(byte *)data, DEFAULT_SIZE, DEFAULT_SIZE, qfalse, qfalse, GL_REPEAT, i, tr.blackCubeImage );
+		}
+	}
+
+	{
+		//fixme: This is crap
+		char fileName[128]="textures/twoseven/water_n.tga";
+					
+		tr.waterImage = R_FindImageFile( fileName, qtrue, qtrue, GL_REPEAT, qfalse,qtrue,qtrue );	
+	}
+	
 }
 
 
@@ -4893,6 +2156,9 @@
 */
 void	R_InitImages( void ) {
 	Com_Memset(hashTable, 0, sizeof(hashTable));
+	
+	tr.imagesIndex = 1024;
+	
 	// build brightness translation tables
 	R_SetColorMappings();
 
@@ -4906,18 +2172,27 @@
 ===============
 */
 void R_DeleteTextures( void ) {
-	int		i;
+	int		i,j;
 
 	for ( i=0; i<tr.numImages ; i++ ) {
 		qglDeleteTextures( 1, &tr.images[i]->texnum );
+		if ( tr.images[i]->cubemap>0 ) {
+			for (j=0 ; j<5 ; j++) {
+				qglDeleteTextures( 1, &tr.images[i]->cubemap_faces[j] );
+			}
+		}
 	}
 	Com_Memset( tr.images, 0, sizeof( tr.images ) );
 
 	tr.numImages = 0;
+	tr.imagesIndex = 1024;
 
 	Com_Memset( glState.currenttextures, 0, sizeof( glState.currenttextures ) );
-	if ( qglBindTexture ) {
 		if ( qglActiveTextureARB ) {
+		GL_SelectTexture( 3 );
+		qglBindTexture( GL_TEXTURE_2D, 0 );
+		GL_SelectTexture( 2 );
+		qglBindTexture( GL_TEXTURE_2D, 0 );
 			GL_SelectTexture( 1 );
 			qglBindTexture( GL_TEXTURE_2D, 0 );
 			GL_SelectTexture( 0 );
@@ -4926,7 +2201,6 @@
 			qglBindTexture( GL_TEXTURE_2D, 0 );
 		}
 	}
-}
 
 /*
 ============================================================================
@@ -5054,7 +2328,11 @@
 	qhandle_t	hSkin;
 	skin_t		*skin;
 	skinSurface_t	*surf;
-	char		*text, *text_p;
+	union {
+		char *c;
+		void *v;
+	} text;
+	char		*text_p;
 	char		*token;
 	char		surfName[MAX_QPATH];
 
@@ -5103,12 +2381,12 @@
 	}
 
 	// load and parse the skin file
-    ri.FS_ReadFile( name, (void **)&text );
-	if ( !text ) {
+	ri.FS_ReadFile( name, &text.v );
+	if ( !text.c ) {
 		return 0;
 	}
 
-	text_p = text;
+	text_p = text.c;
 	while ( text_p && *text_p ) {
 		// get surface name
 		token = CommaParse( &text_p );
@@ -5137,7 +2415,7 @@
 		skin->numSurfaces++;
 	}
 
-	ri.FS_FreeFile( text );
+	ri.FS_FreeFile( text.v );
 
 
 	// never let a skin have 0 shaders
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_init.c bumpy-code/code/renderer/tr_init.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_init.c	2014-06-09 22:09:45.528844448 -0400
+++ bumpy-code/code/renderer/tr_init.c	2014-06-09 22:14:52.601548683 -0400
@@ -26,10 +26,14 @@
 glconfig_t	glConfig;
 qboolean	textureFilterAnisotropic = qfalse;
 int		maxAnisotropy = 0;
+float       displayAspect = 0.0f;
+qboolean    vertexBufferObjects = qfalse;
+qboolean    vertexShaders = qfalse;
                 
 glstate_t	glState;
 
 static void GfxInfo_f( void );
+static void GlslInfo_f( void );
 
 cvar_t	*r_flareSize;
 cvar_t	*r_flareFade;
@@ -49,11 +52,18 @@
 cvar_t	*r_detailTextures;
 
 cvar_t	*r_znear;
+cvar_t	*r_zproj;
+cvar_t	*r_stereoSeparation;
 
 cvar_t	*r_smp;
 cvar_t	*r_showSmp;
 cvar_t	*r_skipBackEnd;
 
+cvar_t	*r_stereoEnabled;
+cvar_t	*r_anaglyphMode;
+
+cvar_t	*r_greyscale;
+
 cvar_t	*r_ignorehwgamma;
 cvar_t	*r_measureOverdraw;
 
@@ -62,6 +72,7 @@
 cvar_t	*r_drawSun;
 cvar_t	*r_dynamiclight;
 cvar_t	*r_dlightBacks;
+cvar_t	*r_minEntityLight;
 
 cvar_t	*r_lodbias;
 cvar_t	*r_lodscale;
@@ -86,6 +91,9 @@
 cvar_t	*r_ext_texture_env_add;
 cvar_t	*r_ext_texture_filter_anisotropic;
 cvar_t	*r_ext_max_anisotropy;
+cvar_t	*r_ext_vertex_buffer_object;
+cvar_t	*r_ext_framebuffer_object;
+cvar_t	*r_ext_vertex_shader;
 
 cvar_t	*r_ignoreGLErrors;
 cvar_t	*r_logFile;
@@ -134,6 +143,9 @@
 cvar_t	*r_customwidth;
 cvar_t	*r_customheight;
 cvar_t	*r_customPixelAspect;
+cvar_t	*r_width;
+cvar_t	*r_height;
+cvar_t	*r_pixelAspect;
 
 cvar_t	*r_overBrightBits;
 cvar_t	*r_mapOverBrightBits;
@@ -144,6 +156,23 @@
 cvar_t	*r_showImages;
 
 cvar_t	*r_ambientScale;
+
+cvar_t	*r_decals;
+cvar_t	*r_maxstaticverts;
+cvar_t	*r_bloom;
+cvar_t	*r_autobump;
+cvar_t	*r_dof;
+cvar_t	*r_dofscale;
+cvar_t	*r_dofblend;
+cvar_t	*r_fancywater;
+cvar_t	*r_simpleshaders;
+cvar_t	*r_glsl_debug;
+
+cvar_t	*r_fogdensity;
+cvar_t	*r_fog_r;
+cvar_t	*r_fog_g;
+cvar_t	*r_fog_b;
+
 cvar_t	*r_directedScale;
 cvar_t	*r_debugLight;
 cvar_t	*r_debugSort;
@@ -200,6 +227,7 @@
 	//		- r_fullscreen
	//		- r_glDriver
	//		- r_mode
+	//		- r_(width|height|pixelAspect)
 	//		- r_(color|depth|stencil)bits
 	//		- r_ignorehwgamma
 	//		- r_gamma
@@ -228,7 +256,13 @@
 	// init command buffers and SMP
 	R_InitCommandBuffers();
 
+	// init GLSL shaders
+	R_LoadSimpleFragmentPrograms( );
+	R_LoadFragmentPrograms( );
+	R_LoadSM3FragmentPrograms( );
+
 	// print info
+	if( com_developer->integer )
 	GfxInfo_f();
 
 	// set default state
@@ -780,6 +808,7 @@
 		GL_SelectTexture( 0 );
 	}
 
+	GL_SelectTexture(0);
 	qglEnable(GL_TEXTURE_2D);
 	GL_TextureMode( r_textureMode->string );
 	GL_TexEnv( GL_MODULATE );
@@ -827,9 +858,9 @@
 	ri.Printf( PRINT_ALL, "\nGL_VENDOR: %s\n", glConfig.vendor_string );
 	ri.Printf( PRINT_ALL, "GL_RENDERER: %s\n", glConfig.renderer_string );
 	ri.Printf( PRINT_ALL, "GL_VERSION: %s\n", glConfig.version_string );
-	ri.Printf( PRINT_DEVELOPER, "GL_EXTENSIONS: %s\n", glConfig.extensions_string );
+	ri.Printf( PRINT_ALL, "GL_EXTENSIONS: %s\n", glConfig.extensions_string );
 	ri.Printf( PRINT_ALL, "GL_MAX_TEXTURE_SIZE: %d\n", glConfig.maxTextureSize );
-	ri.Printf( PRINT_ALL, "GL_MAX_ACTIVE_TEXTURES_ARB: %d\n", glConfig.maxActiveTextures );
+	ri.Printf( PRINT_ALL, "GL_MAX_TEXTURE_UNITS_ARB: %d\n", glConfig.numTextureUnits );
 	ri.Printf( PRINT_ALL, "\nPIXELFORMAT: color(%d-bits) Z(%d-bit) stencil(%d-bits)\n", glConfig.colorBits, glConfig.depthBits, glConfig.stencilBits );
 	ri.Printf( PRINT_ALL, "MODE: %d, %d x %d %s hz:", r_mode->integer, glConfig.vidWidth, glConfig.vidHeight, fsstrings[r_fullscreen->integer == 1] );
 	if ( glConfig.displayFrequency )
@@ -902,6 +933,56 @@
 	}
 }
 
+void GlslInfo_f( void ) 
+{
+	int j=0;
+
+	ri.Printf( PRINT_ALL, "------GLSL INFO------\n");
+
+	if ( r_ext_vertex_shader->integer ) 
+	{
+		ri.Printf( PRINT_ALL, "GLSL Enabled\n" );
+	}
+	else
+	{
+		ri.Printf( PRINT_ALL, "GLSL Disabled\n" );
+	}
+	ri.Printf( PRINT_ALL, "r_vbo %d\n" , r_ext_vertex_buffer_object->integer);
+	ri.Printf( PRINT_ALL, "r_simpleshaders %d\n" , r_simpleshaders->integer);
+	ri.Printf( PRINT_ALL, "r_dof %d\n" , r_dof->integer);
+	ri.Printf( PRINT_ALL, "r_bloom %d\n" , r_bloom->integer);
+	
+	for (j=1;j<FS_MAX_SHADERS;j++)
+	{
+		ri.Printf( PRINT_ALL, "------------\n");
+		ri.Printf( PRINT_ALL, "shader %d\n",j);
+		
+		ri.Printf( PRINT_ALL, "vs: %d %d %d\n",tr.fragshader[j].vertexShader,tr.fragshader[j].fragShader,tr.fragshader[j].program);
+		ri.Printf( PRINT_ALL, "diffuse0: %d\n",tr.fragshader[j].diffuse0);
+		ri.Printf( PRINT_ALL, "diffuse1: %d\n",tr.fragshader[j].diffuse1);
+		ri.Printf( PRINT_ALL, "bump0: %d\n",tr.fragshader[j].bump0);
+		ri.Printf( PRINT_ALL, "bump1: %d\n",tr.fragshader[j].bump1);
+		ri.Printf( PRINT_ALL, "normal0: %d\n",tr.fragshader[j].normal0);
+		ri.Printf( PRINT_ALL, "normal1: %d\n",tr.fragshader[j].normal1);
+		ri.Printf( PRINT_ALL, "cube: %d\n",tr.fragshader[j].cubemap);
+		ri.Printf( PRINT_ALL, "lm: %d\n",tr.fragshader[j].lightmap0);
+		ri.Printf( PRINT_ALL, "rad0: %d\n",tr.fragshader[j].radbump0);
+		ri.Printf( PRINT_ALL, "rad1: %d\n",tr.fragshader[j].radbump1);
+		ri.Printf( PRINT_ALL, "rad2: %d\n",tr.fragshader[j].radbump2);
+		ri.Printf( PRINT_ALL, "specbump: %d\n",tr.fragshader[j].specbump);
+		ri.Printf( PRINT_ALL, "ref: %d\n",tr.fragshader[j].reflectmap);
+		ri.Printf( PRINT_ALL, "refract: %d\n",tr.fragshader[j].reflectmap);
+		ri.Printf( PRINT_ALL, "lightuv: %d\n",tr.fragshader[j].light_uv_i);
+		ri.Printf( PRINT_ALL, "pos: %d\n",tr.fragshader[j].position_i);
+		ri.Printf( PRINT_ALL, "rgba: %d\n",tr.fragshader[j].rgba_i);
+		ri.Printf( PRINT_ALL, "uvs: %d %d %d\n",tr.fragshader[j].uv_i,tr.fragshader[j].stv_i,tr.fragshader[j].ttv_i);
+
+	}
+	ri.Printf( PRINT_ALL, "------END GLSL INFO------\n");
+
+}
+
+
 /*
 ===============
 R_Register
@@ -923,6 +1016,19 @@
 #else
 	r_ext_texture_env_add = ri.Cvar_Get( "r_ext_texture_env_add", "1", CVAR_ARCHIVE | CVAR_LATCH);
 #endif
+	r_ext_vertex_buffer_object = ri.Cvar_Get( "r_ext_vertex_buffer_object", "2", CVAR_ARCHIVE|CVAR_LATCH );
+	ri.Cvar_CheckRange( r_ext_vertex_buffer_object, 0, 2, qtrue );
+	//ri.Cvar_Alias( r_ext_vertex_buffer_object, "r_vbo");
+	r_ext_framebuffer_object = ri.Cvar_Get( "r_ext_framebuffer_object", "1", CVAR_ARCHIVE|CVAR_LATCH );
+	r_ext_vertex_shader = ri.Cvar_Get( "r_ext_vertex_shader", "1", CVAR_ARCHIVE|CVAR_LATCH );
+	//ri.Cvar_Alias( r_ext_vertex_shader, "r_glsl");
+	r_picmip = ri.Cvar_Get ("r_picmip", "0",
+			CVAR_ARCHIVE | CVAR_LATCH );
+	ri.Cvar_CheckRange( r_picmip, 0, 1, qtrue );
+	r_stereoEnabled = ri.Cvar_Get( "r_stereoEnabled", "0", CVAR_ARCHIVE | CVAR_LATCH);
+	r_greyscale = ri.Cvar_Get("r_greyscale", "0", CVAR_ARCHIVE | CVAR_LATCH);
+	r_zproj = ri.Cvar_Get( "r_zproj", "64", CVAR_ARCHIVE );
+	r_stereoSeparation = ri.Cvar_Get( "r_stereoSeparation", "64", CVAR_ARCHIVE );

 	r_ext_texture_filter_anisotropic = ri.Cvar_Get( "r_ext_texture_filter_anisotropic",
 			"0", CVAR_ARCHIVE | CVAR_LATCH );
@@ -986,14 +1064,11 @@
 	r_dynamiclight = ri.Cvar_Get( "r_dynamiclight", "1", CVAR_ARCHIVE );
 	r_dlightBacks = ri.Cvar_Get( "r_dlightBacks", "1", CVAR_ARCHIVE );
 	r_finish = ri.Cvar_Get ("r_finish", "0", CVAR_ARCHIVE);
-	r_textureMode = ri.Cvar_Get( "r_textureMode", "GL_LINEAR_MIPMAP_NEAREST", CVAR_ARCHIVE );
-#if USE_SDL_VIDEO
+	r_textureMode = ri.Cvar_Get( "r_textureMode",
+			"GL_LINEAR_MIPMAP_LINEAR", CVAR_ARCHIVE );
 	r_swapInterval = ri.Cvar_Get( "r_swapInterval", "0",
 					CVAR_ARCHIVE | CVAR_LATCH );
-#else
-	r_swapInterval = ri.Cvar_Get( "r_swapInterval", "0", CVAR_ARCHIVE );
-#endif
-	r_gamma = ri.Cvar_Get( "r_gamma", "1", CVAR_ARCHIVE );
+	r_gamma = ri.Cvar_Get( "r_gamma", "1.0", CVAR_ARCHIVE );
 	r_facePlaneCull = ri.Cvar_Get ("r_facePlaneCull", "1", CVAR_ARCHIVE );
 
 	r_railWidth = ri.Cvar_Get( "r_railWidth", "16", CVAR_ARCHIVE );
@@ -1005,6 +1080,35 @@
 	r_ambientScale = ri.Cvar_Get( "r_ambientScale", "0.6", CVAR_CHEAT );
 	r_directedScale = ri.Cvar_Get( "r_directedScale", "1", CVAR_CHEAT );
 
+	r_anaglyphMode = ri.Cvar_Get("r_anaglyphMode", "0", CVAR_ARCHIVE);
+
+	r_minEntityLight = ri.Cvar_Get("r_minEntityLight", "1.5", CVAR_ARCHIVE);
+	ri.Cvar_CheckRange( r_minEntityLight, 0.0f, 2.0f, qfalse );
+
+	r_bloom = ri.Cvar_Get( "r_bloom", "1", CVAR_ARCHIVE );
+	r_autobump = ri.Cvar_Get( "r_autobump", "1", CVAR_ARCHIVE |CVAR_LATCH );
+
+	r_dof = ri.Cvar_Get( "r_dof", "0", CVAR_ARCHIVE |CVAR_LATCH );
+	r_dofscale = ri.Cvar_Get( "r_dofscale", "2", CVAR_ARCHIVE );
+	ri.Cvar_CheckRange( r_dofscale, 0.0f, 10.0f, qfalse );
+	r_dofblend = ri.Cvar_Get( "r_dofblend", "0.5", CVAR_ARCHIVE ); // 3 frames or so
+	ri.Cvar_CheckRange( r_dofblend, 0.001f, 1.0f, qfalse );
+
+	// disables all pixelshader effects, just leaving the r_ext_vertex_buffer_object and FS_CHEAP
+	r_simpleshaders = ri.Cvar_Get( "r_simpleshaders", "0", CVAR_ARCHIVE | CVAR_LATCH ); 
+	r_glsl_debug = ri.Cvar_Get( "r_glsl_debug", "0", CVAR_ARCHIVE | CVAR_LATCH | CVAR_CHEAT ); 
+	// disable if you cant load sm3 shaders
+	r_maxstaticverts = ri.Cvar_Get( "r_maxstaticverts", "1500000", CVAR_ARCHIVE );
+	// controls whether or not to use the new triangle-soup decal code
+	r_decals = ri.Cvar_Get( "r_decals", "1", CVAR_ARCHIVE | CVAR_LATCH );
+	r_fancywater = ri.Cvar_Get( "r_fancywater", "1", CVAR_ARCHIVE | CVAR_LATCH );
+
+	r_fogdensity = ri.Cvar_Get( "r_fogdensity", "0.0", CVAR_ARCHIVE | CVAR_CHEAT );
+	r_fog_r = ri.Cvar_Get( "r_fog_r", "0.25", CVAR_ARCHIVE | CVAR_CHEAT );
+	r_fog_g = ri.Cvar_Get( "r_fog_g", "0.25", CVAR_ARCHIVE | CVAR_CHEAT );
+	r_fog_b = ri.Cvar_Get( "r_fog_b", "0.25", CVAR_ARCHIVE | CVAR_CHEAT );
+
+
 	//
 	// temporary variables that can change at any time
 	//
@@ -1066,6 +1170,7 @@
 	ri.Cmd_AddCommand( "screenshot", R_ScreenShot_f );
 	ri.Cmd_AddCommand( "screenshotJPEG", R_ScreenShotJPEG_f );
 	ri.Cmd_AddCommand( "gfxinfo", GfxInfo_f );
+	ri.Cmd_AddCommand( "glslinfo", GlslInfo_f );
 }
 
 /*
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_light.c bumpy-code/code/renderer/tr_light.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_light.c	2014-06-09 22:09:45.528844448 -0400
+++ bumpy-code/code/renderer/tr_light.c	2014-06-09 22:14:52.601548683 -0400
@@ -123,7 +123,8 @@
 
 =================
 */
-static void R_SetupEntityLightingGrid( trRefEntity_t *ent ) {
+void R_SetupEntityLightingGrid( trRefEntity_t *ent ) 
+{
 	vec3_t	lightOrigin;
 	int		pos[3];
 	int		i, j;
@@ -160,7 +161,7 @@
 	VectorClear( ent->directedLight );
 	VectorClear( direction );
 
-	assert( tr.world->lightGridData ); // bk010103 - NULL with -nolight maps
+	assert( tr.world->lightGridData ); // NULL with -nolight maps
 
 	// trilerp the light value
 	gridStep[0] = 8;
@@ -312,18 +313,18 @@
 		R_SetupEntityLightingGrid( ent );
 	} else {
 		ent->ambientLight[0] = ent->ambientLight[1] = 
-			ent->ambientLight[2] = tr.identityLight * 150;
+			ent->ambientLight[2] = tr.identityLight * ( r_minEntityLight->value * 150 );
 		ent->directedLight[0] = ent->directedLight[1] = 
-			ent->directedLight[2] = tr.identityLight * 150;
+			ent->directedLight[2] = tr.identityLight * ( r_minEntityLight->value * 150 );
 		VectorCopy( tr.sunDirection, ent->lightDir );
 	}
 
 	// bonus items and view weapons have a fixed minimum add
 	if ( 1 /* ent->e.renderfx & RF_MINLIGHT */ ) {
 		// give everything a minimum light add
-		ent->ambientLight[0] += tr.identityLight * 32;
-		ent->ambientLight[1] += tr.identityLight * 32;
-		ent->ambientLight[2] += tr.identityLight * 32;
+		ent->ambientLight[0] += tr.identityLight * ( r_minEntityLight->value * 32 );
+		ent->ambientLight[1] += tr.identityLight * ( r_minEntityLight->value * 32 );
+		ent->ambientLight[2] += tr.identityLight * ( r_minEntityLight->value * 32 );
 	}
 
 	//
@@ -380,7 +381,6 @@
 {
 	trRefEntity_t ent;
 	
-	// bk010103 - this segfaults with -nolight maps
 	if ( tr.world->lightGridData == NULL )
 	  return qfalse;
 
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_local.h bumpy-code/code/renderer/tr_local.h
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_local.h	2014-06-09 22:09:45.528844448 -0400
+++ bumpy-code/code/renderer/tr_local.h	2014-06-09 22:14:52.601548683 -0400
@@ -67,20 +68,76 @@
 } dlight_t;
 
 
-// a trRefEntity_t has all the information passed in by
-// the client game, as well as some locally derived info
 typedef struct {
-	refEntity_t	e;
 
-	float		axisLength;		// compensate for non-normalized axis
+	char name[128];
+
+	int vertexShader;
+	int fragShader;
+	int program;
+
+	//static base stuff
+	int position_i;
+	int uv_i;
+	int light_uv_i;
+	int normal_i;
+	int stv_i;
+	int ttv_i;
+	int rgba_i;
+	///
+
+	int diffuse0;
+	int normal0;
+	int bump0;
+	int diffuse1;
+	int normal1;
+	int bump1;
+	int lightmap0;
+	int radbump0;
+	int radbump1;
+	int radbump2;
+	int specbump;
+	int cubemap;
+	int cubemap2;
+	int reflectmap;
+	int refractmap;
+	int scenetexture;
+
+	int vertexType; //0 is illegal, 1 for static, 2 for model
+
+	//md5 additions
+/*	int boneindexs_i;
+	int boneweights_i;
+	int pos0_i;
+	int pos1_i;
+	int pos2_i;
+	int norm0_i;
+	int norm1_i;
+	int norm2_i;
+	int tangent0_i;
+	int tangent1_i;
+	int tangent2_i;
+	int bitangent0_i;
+	int bitangent1_i;
+	int bitangent2_i;*/
+
+	////
+
+} fragShader_t;
+
+typedef struct renderbuffer_s
+{
+	unsigned int frameBuffer;
+	unsigned int depth_rb;
+
+	unsigned int texnum; //colour
+	unsigned int depthtexnum; //colour
+	qboolean depthtexture; 
+	int x;
+	int y;
+	
+} renderbuffer_t;
 
-	qboolean	needDlights;	// true for bmodels that touch a dlight
-	qboolean	lightingCalculated;
-	vec3_t		lightDir;		// normalized direction towards light
-	vec3_t		ambientLight;	// color normalized to 0-255
-	int			ambientLightInt;	// 32 bit rgba packed
-	vec3_t		directedLight;
-} trRefEntity_t;
 
 
 typedef struct {
@@ -88,6 +145,7 @@
 	vec3_t		axis[3];		// orientation in world
 	vec3_t		viewOrigin;		// viewParms->or.origin in local coordinates
 	float		modelMatrix[16];
+	float		u_modelMatrix[16];  //unflipped
 } orientationr_t;
 
 typedef struct image_s {
@@ -103,12 +161,37 @@
 
 	qboolean	mipmap;
 	qboolean	allowPicmip;
-	int			wrapClampMode;		// GL_CLAMP or GL_REPEAT
+	qboolean        hasAlpha;
+	int			wrapClampMode;		// GL_CLAMP_TO_EDGE or GL_REPEAT
+	
+	qboolean	cubemap;
+	GLuint		cubemap_faces[5];	// The textures for the other 5 faces.
 
 	struct image_s*	next;
 } image_t;
 
+
+typedef struct {
+	vec3_t origin;
+	image_t *cubemap;
+} cubemapProbe_t;
+
 //===============================================================================
+// a trRefEntity_t has all the information passed in by
+// the client game, as well as some locally derived info
+typedef struct {
+	refEntity_t	e;
+
+	float		axisLength;		// compensate for non-normalized axis
+
+	qboolean	needDlights;	// true for bmodels that touch a dlight
+	qboolean	lightingCalculated;
+	vec3_t		lightDir;		// normalized direction towards light
+	vec3_t		ambientLight;	// color normalized to 0-255
+	int			ambientLightInt;	// 32 bit rgba packed
+	vec3_t		directedLight;
+} trRefEntity_t;
+
 
 typedef enum {
 	SS_BAD,
@@ -296,6 +379,7 @@
 	qboolean		isLightmap;
 	qboolean		vertexLightmap;
 	qboolean		isVideoMap;
+	
 } textureBundle_t;
 
 #define NUM_TEXTURE_BUNDLES 2
@@ -318,10 +402,17 @@
 	acff_t			adjustColorsForFog;
 
 	qboolean		isDetail;
+
+	fragShader_t   *program;
+	image_t*		normalmap;
+	image_t*		bumpmap;
+
 } shaderStage_t;
 
 struct shaderCommands_s;
 
+// any change in the LIGHTMAP_* defines here MUST be reflected in
+// R_FindShader() in tr_bsp.c
 #define LIGHTMAP_2D			-4		// shader is for 2D rendering
 #define LIGHTMAP_BY_VERTEX	-3		// pre-lit triangle models
 #define LIGHTMAP_WHITEIMAGE	-2
@@ -352,6 +443,8 @@
 
 typedef struct shader_s {
 	char		name[MAX_QPATH];		// game path, including extension
+	long			nameHash;
+
 	int			lightmapIndex;			// for a shader to match, both name and lightmapIndex must match
 
 	int			index;					// this shader == tr.shaders[index]
@@ -411,9 +504,20 @@
 
   struct shader_s *remappedShader;                  // current shader this one is remapped too
 
-  int shaderStates[MAX_STATES_PER_SHADER];          // index to valid shader states
-
 	struct	shader_s	*next;
+
+	qboolean  isGLSL;								// Shader is using one of the GLSL iterators... the image stages have been manipulated
+	qboolean  isGLSLStatic;					    // Use SF_STATIC to render with, not the dynamic tess 
+	qboolean implicitLoad;							//set to true after we've attempted to implicitly load some normals or bumps
+
+	qboolean noFancyWater;							//Don't render this if fancy water is on
+	int isFancyWater;								//Replace this with a generic "override with a nice frag shader" command
+
+	vec3_t tint;									//For fragshaders
+	float  scale;									//for fragshaders
+
+	qboolean useOffsetMapping;						//Only true if both _n and _b are present
+	qboolean whiteLightmap;			
 } shader_t;
 
 typedef struct shaderState_s {
@@ -433,6 +537,8 @@
 	vec3_t		vieworg;
 	vec3_t		viewaxis[3];		// transformation matrix
 
+	stereoFrame_t	stereoFrame;
+
 	int			time;				// time in milliseconds for shader effects and other time dependent rendering issues
 	int			rdflags;			// RDF_NOWORLDMODEL, etc
 
@@ -457,10 +563,17 @@
 	int			numDrawSurfs;
 	struct drawSurf_s	*drawSurfs;
 
+	byte*	pixelTarget; //set this to Non Null to copy to a buffer after scene rendering
+								 // this doesnt interfere with the dof/bloom code
+	int		pixelTargetX;		//xy size for pixeltarget.
+	int		pixelTargetY;
 
-} trRefdef_t;
+	unsigned int*	zbuffer;
 
+} trRefdef_t;
 
+#define REF_CUBEMAP_SIZE 64
+#define REF_VISCALC_SIZE 256
 //=================================================================================
 
 // skins allow models to be retextured without modifying the model file
@@ -504,6 +617,12 @@
 	cplane_t	frustum[4];
 	vec3_t		visBounds[2];
 	float		zFar;
+	stereoFrame_t	stereoFrame;
+
+	cplane_t	waterPlane;		//Clip anything above or below this depending on water view
+	int			isWater;		//0 Normal Scene, 1 draw Below Water, 2 Draw above water only
+	qboolean    isUnderwater;   //obviously can only be true if doWater==true too
+	qboolean	doWater;	    //rendering a water surf
 } viewParms_t;
 
 
@@ -531,7 +650,8 @@
 	SF_FLARE,
 	SF_ENTITY,				// beams, rails, lightning, etc that can be determined by entity
 	SF_DISPLAY_LIST,
-
+	SF_STATIC,
+	SF_DECALSURF,
 	SF_NUM_SURFACE_TYPES,
 	SF_MAX = 0x7fffffff			// ensures that sizeof( surfaceType_t ) == sizeof( int )
 } surfaceType_t;
@@ -614,6 +734,29 @@
 } srfSurfaceFace_t;
 
 
+typedef struct {
+	surfaceType_t	surfaceType;
+	cplane_t	plane;
+	shader_t		*shader;
+		
+	int			merged; //surfacemerge marker
+	int			surfnum; //debugging
+	// dynamic lighting information
+	int			dlightBits[SMP_FRAMES];
+
+	//The data is inside vbo_vertexBuffer + vbo_indexBuffer
+	//we just need to store the info for the draw call
+	int			numVerts;
+	int			numIndices;
+	int			startIndex;	//offset
+	int			startVertex;
+
+	vec3_t		origin;
+	image_t		*cubemap;
+	int			modelNum;
+				
+} srfSurfaceStatic_t;
+
 // misc_models in maps are turned into direct geometry by q3map
 typedef struct {
 	surfaceType_t	surfaceType;
@@ -663,6 +806,19 @@
 } msurface_t;
 
 
+//Simple triangle surface type.
+//We're going to have ALOT of these but it allows for fairly
+//efficient poly soup decal code
+typedef struct 
+{
+	surfaceType_t surfType;
+	vec3_t v[3];
+	cplane_t plane;
+	msurface_t* surf;
+	int viewCount;
+}
+srfSurfaceDecal_t;
+
 
 #define	CONTENTS_NODE		-1
 typedef struct mnode_s {
@@ -682,6 +838,15 @@
 
 	msurface_t	**firstmarksurface;
 	int			nummarksurfaces;
+	
+	//Decal stuff
+	msurface_t	**o_firstmarksurface; //we tamper with this, best to have a clean copy
+	int			o_nummarksurfaces;
+	srfSurfaceDecal_t	**decalTris;
+	int			numDecalTris;
+
+	int			newVisCluster;
+
 } mnode_t;
 
 typedef struct {
@@ -700,6 +865,7 @@
 	dshader_t	*shaders;
 
 	bmodel_t	*bmodels;
+	int			numbmodels;
 
 	int			numplanes;
 	cplane_t	*planes;
@@ -732,6 +898,11 @@
 
 	char		*entityString;
 	char		*entityParsePoint;
+
+	int			numdecalTris;
+	srfSurfaceDecal_t *decalTris;
+
+
 } world_t;
 
 //======================================================================
@@ -776,7 +951,7 @@
 #define	MAX_DRAWIMAGES			2048
 #define	MAX_LIGHTMAPS			256
 #define	MAX_SKINS				1024
-
+#define MAX_PROBES				128
 
 #define	MAX_DRAWSURFS			0x10000
 #define	DRAWSURF_MASK			(MAX_DRAWSURFS-1)
@@ -826,14 +1001,38 @@
 #define FUNCTABLE_MASK		(FUNCTABLE_SIZE-1)
 
 
+//world surface shaders
+typedef enum
+{
+	FS_NONE=0,
+	FS_CHEAP,
+	FS_RAD_BUMP,
+	FS_RAD_BUMP_OFFSET,
+	FS_WATER,
+	FS_WATER_CHEAP,
+	
+	FS_RAD_TERRAIN_ALPHA,
+	FS_TERRAIN_ALPHA_CHEAP,
+
+	FS_VERTEX_LIGHT,
+	FS_VERTEX_LIGHT_CHEAP,
+	FS_WIREFRAME,
+
+
+
+	FS_MAX_SHADERS
+} fshader_t;
+
 // the renderer front end should never modify glstate_t
 typedef struct {
-	int			currenttextures[2];
+	int			currenttextures[12];
 	int			currenttmu;
 	qboolean	finishCalled;
 	int			texEnv[2];
 	int			faceCulling;
 	unsigned long	glStateBits;
+	int			VBOBound;
+	fragShader_t *currentFragShader;
 } glstate_t;
 
 
@@ -851,6 +1050,17 @@
 	int		msec;			// total msec for backend run
 } backEndCounters_t;
 
+
+typedef struct 
+{  // batch clusters. 
+	int numSurfs;
+	srfSurfaceStatic_t *surfs;	
+	int		frame; // draw frame.  if ==frame this cluster has been flagged as visible
+	
+} batchClusters_t;
+
+
+
 // all state modified by the back end is seperated
 // from the front end state
 typedef struct {
@@ -867,6 +1077,9 @@
 	byte		color2D[4];
 	qboolean	vertexes2D;		// shader needs to be finished
 	trRefEntity_t	entity2D;	// currentEntity will point at this when doing 2D rendering
+	qboolean	doneBloom;		// done bloom this frame
+	qboolean	doneSurfaces;   // done any 3d surfaces already
+	
 } backEndState_t;
 
 /*
@@ -895,13 +1108,24 @@
 
 	const byte				*externalVisData;	// from RE_SetWorldVisData, shared with CM_Load
 
+	image_t					*fatlightmap;
+	image_t					*radbump[4];       //three fat lightmaps for radbumping, 1 for spec
+	qboolean				radbumping;			//false if we're not						
+
 	image_t					*defaultImage;
 	image_t					*scratchImage[32];
 	image_t					*fogImage;
 	image_t					*dlightImage;	// inverse-quare highlight for projective adding
 	image_t					*flareImage;
 	image_t					*whiteImage;			// full of 0xff
+	image_t					*blackImage;			// full of 0x00
+	image_t					*greyImage;			// full of 0x0f
+	image_t					*greenImage;			// full of 0x0f
+	image_t					*testCubemap;
+	image_t					*blackCubeImage;	
+	image_t					*waterImage;	
 	image_t					*identityLightImage;	// full of tr.identityLightByte
+	image_t					*normalImage;			// full of normals
 
 	shader_t				*defaultShader;
 	shader_t				*shadowShader;
@@ -945,6 +1169,7 @@
 	int						numModels;
 
 	int						numImages;
+	int						imagesIndex; //added so we can index cubemaps properly, seeing they share an index num
 	image_t					*images[MAX_DRAWIMAGES];
 
 	// shader indexes from other modules will be looked up in tr.shaders[]
@@ -963,6 +1188,56 @@
 	float					sawToothTable[FUNCTABLE_SIZE];
 	float					inverseSawToothTable[FUNCTABLE_SIZE];
 	float					fogTable[FOG_TABLE_SIZE];
+
+	unsigned int			VBO_vertexBuffer;
+	unsigned int			VBO_indexBuffer;
+
+
+	staticVert_t*		    staticVertexData; // Temporary storage before we get to VBO_vertexBuffer
+	unsigned int*		    staticIndexData;
+	int						numStaticVertex; 
+	int						numStaticIndex;
+
+	batchClusters_t			*batchClusters;
+	int						numBatchClusters;
+
+	int						fatLightmapSize;
+	int						fatLightmapStep;
+
+	
+	//All of this stuff is bloom related
+	fragShader_t			row3_fragshader;	// blur kernel, used for 7x7 box filter
+	fragShader_t			combine2_fragshader; // blit 2 textures @ blendfactor
+	
+	fragShader_t			bloom_fragshader;	//final bloom only scene composite
+	fragShader_t			bloom_fog_fragshader;	//final fog+bloom scene composite
+	fragShader_t			bloom_fog_dof_fragshader;	//final fog+dof+bloom scene composite
+	fragShader_t			hdrcull_fragshader;	 //used for setting up the blit for hdr bloom.  Anything under ~1.0 gets culled to black
+	
+	fragShader_t			fragshader[FS_MAX_SHADERS];	//All frag shaders
+	
+
+	unsigned int			sceneTexnum;
+	unsigned int			depthTexnum;
+	unsigned int			underwaterTexnum;
+	unsigned int			reflectionTexnum;
+	
+	float DOF_focus;
+
+	byte*	cubeTemp[6];	// 6 textures for cubemap storage
+	qboolean	flipx;
+	qboolean	flipy;
+	
+	cubemapProbe_t cubeProbes[MAX_PROBES];
+	int cubeProbesCount;
+	
+	//Todo: move this to backend
+	renderbuffer_t	sceneTexture;
+	renderbuffer_t	bloomTexture;
+	renderbuffer_t	bloomTempX;
+
+
+	
 } trGlobals_t;
 
 extern backEndState_t	backEnd;
@@ -975,7 +1250,9 @@
 // the glconfig_t struct.
 extern qboolean		textureFilterAnisotropic;
 extern int		maxAnisotropy;
-                
+extern float     displayAspect;
+extern qboolean  vertexBufferObjects;
+extern qboolean  vertexShaders;
 
 //
 // cvars
@@ -992,14 +1269,14 @@
 
 extern cvar_t	*r_ignore;				// used for debugging anything
 extern cvar_t	*r_verbose;				// used for verbose debug spew
-extern cvar_t	*r_ignoreFastPath;		// allows us to ignore our Tess fast paths
 
 extern cvar_t	*r_znear;				// near Z clip plane
+extern cvar_t	*r_zproj;				// z distance of projection plane
+extern cvar_t	*r_stereoSeparation;			// separation of cameras for stereo rendering
 
 extern cvar_t	*r_stencilbits;			// number of desired stencil bits
 extern cvar_t	*r_depthbits;			// number of desired depth bits
 extern cvar_t	*r_colorbits;			// number of desired color bits, only relevant for fullscreen
-extern cvar_t	*r_stereo;				// desired pixelformat stereo flag
 extern cvar_t	*r_texturebits;			// number of desired texture bits
 										// 0 = use framebuffer depth
 										// 16 = use 16-bit textures
@@ -1022,6 +1299,11 @@
 extern cvar_t	*r_dynamiclight;		// dynamic lights enabled/disabled
 extern cvar_t	*r_dlightBacks;			// dlight non-facing surfaces for continuity
 
+extern cvar_t	*r_minEntityLight;		// minimum entity light value
+
+extern cvar_t	*r_specularLighting;		// extra specular pass for default shader
+extern cvar_t	*r_specularLightingExponent;	// specular exponent for extra pass
+
 extern	cvar_t	*r_norefresh;			// bypasses the ref rendering
 extern	cvar_t	*r_drawentities;		// disable/enable entity rendering
 extern	cvar_t	*r_drawworld;			// disable/enable world rendering
@@ -1033,6 +1315,10 @@
 extern	cvar_t	*r_nocurves;
 extern	cvar_t	*r_showcluster;
 
+extern cvar_t	*r_width;
+extern cvar_t	*r_height;
+extern cvar_t	*r_pixelAspect;
+
 extern cvar_t	*r_mode;				// video mode
 extern cvar_t	*r_fullscreen;
 extern cvar_t	*r_minimize;
@@ -1090,6 +1376,11 @@
 extern	cvar_t	*r_showSmp;
 extern	cvar_t	*r_skipBackEnd;
 
+extern	cvar_t	*r_stereoEnabled;
+extern	cvar_t	*r_anaglyphMode;
+
+extern	cvar_t	*r_greyscale;
+
 extern	cvar_t	*r_ignoreGLErrors;
 
 extern	cvar_t	*r_overBrightBits;
@@ -1106,6 +1397,27 @@
 
 extern	cvar_t	*r_GLlibCoolDownMsec;
 
+extern cvar_t	*r_ext_vertex_buffer_object;
+extern cvar_t	*r_bloom;
+extern cvar_t	*r_autobump;
+extern cvar_t	*r_dof;
+extern cvar_t	*r_dofscale;
+extern cvar_t	*r_dofblend;
+extern cvar_t	*r_ext_vertex_shader;
+extern cvar_t	*r_maxstaticverts;
+extern cvar_t	*r_radbump;
+extern cvar_t	*r_decals;
+extern cvar_t	*r_fancywater;
+extern cvar_t	*r_simpleshaders;
+extern cvar_t	*r_glsl_debug;
+
+extern cvar_t	*r_fogdensity;
+extern cvar_t	*r_fog_r;
+extern cvar_t	*r_fog_g;
+extern cvar_t	*r_fog_b;
+
+extern cvar_t	*r_ext_framebuffer_object;
+
 //====================================================================
 
 float R_NoiseGet4f( float x, float y, float z, float t );
@@ -1128,6 +1440,11 @@
 
 void R_AddDrawSurf( surfaceType_t *surface, shader_t *shader, int fogIndex, int dlightMap );
 
+void R_LoadFragmentPrograms( void );
+void R_LoadSM3FragmentPrograms( void );
+
+void R_LoadSimpleFragmentPrograms( void );
+void R_CreateRenderTextures( renderbuffer_t *buffer, int xres, int yres, qboolean depth, qboolean depthtexture );
 
 #define	CULL_IN		0		// completely unclipped
 #define	CULL_CLIP	1		// clipped by one or more planes
@@ -1138,17 +1455,22 @@
 int R_CullPointAndRadius( vec3_t origin, float radius );
 int R_CullLocalPointAndRadius( vec3_t origin, float radius );
 
+void R_SetupProjection(viewParms_t *dest, float zProj, qboolean computeFrustum);
 void R_RotateForEntity( const trRefEntity_t *ent, const viewParms_t *viewParms, orientationr_t *or );
 
 /*
 ** GL wrapper/helper functions
 */
 void	GL_Bind( image_t *image );
+void	GL_BindCube( image_t *image );
+void	GL_BindCubeTexnum( int texnum );
+void	GL_BindTexnum( int texnum );
 void	GL_SetDefaultState (void);
 void	GL_SelectTexture( int unit );
 void	GL_TextureMode( const char *string );
 void	GL_CheckErrors( void );
 void	GL_State( unsigned long stateVector );
+void    SetViewportAndScissor( void );
 void	GL_TexEnv( int env );
 void	GL_Cull( int cullType );
 
@@ -1203,10 +1525,16 @@
 model_t		*R_AllocModel( void );
 
 void    	R_Init( void );
-image_t		*R_FindImageFile( const char *name, qboolean mipmap, qboolean allowPicmip, int glWrapClampMode );
+image_t		*R_FindImageFile( const char *name, qboolean mipmap, qboolean allowPicmip, int glWrapClampMode, qboolean cubemap,qboolean normals,qboolean forcealpha );
+
+image_t	*R_BuildNormalsFromBump( const char *name,qboolean UseAlphaInFile);
 
 image_t		*R_CreateImage( const char *name, const byte *pic, int width, int height, qboolean mipmap
-					, qboolean allowPicmip, int wrapClampMode );
+					, qboolean allowPicmip, int wrapClampMode,qboolean normals,qboolean forcealpha );
+
+image_t		*R_CreateCubeImage( const char *name, const byte *pic, int width, int height, 
+					   qboolean mipmap, qboolean allowPicmip, int glWrapClampMode,int CubemapFace, image_t *cubemapParent );
+
 qboolean	R_GetModeInfo( int *width, int *height, float *windowAspect, int mode );
 
 void		R_SetColorMappings( void );
@@ -1242,6 +1570,7 @@
 shader_t	*R_GetShaderByHandle( qhandle_t hShader );
 shader_t	*R_GetShaderByState( int index, long *cycleTime );
 shader_t *R_FindShaderByName( const char *name );
+shader_t *R_FindShaderByNameHashAndLightmap(long hash,int lightmapIndex );
 void		R_InitShaders( void );
 void		R_ShaderList_f( void );
 void    R_RemapShader(const char *oldShader, const char *newShader, const char *timeOffset);
@@ -1271,6 +1600,7 @@
 						    unsigned char green[256],
 							unsigned char blue[256] );
 
+void		GL_ResolveHardwareType( void );
 
 /*
 ====================================================================
@@ -1314,10 +1644,18 @@
 	int			numPasses;
 	void		(*currentStageIteratorFunc)( void );
 	shaderStage_t	**xstages;
+
+
+	//27 array of surfaces to render at EndSurface
+	//(remember that the texture setup calls all occur during EndFrame.. So we have to que these
+	srfSurfaceStatic_t *StaticSurfs[2048];
+	int	numStaticSurfs;
+
 } shaderCommands_t;
 
 extern	shaderCommands_t	tess;
 
+void RB_SetGL2D (void);
 void RB_BeginSurface(shader_t *shader, int fogNum );
 void RB_EndSurface(void);
 void RB_CheckOverflow( int verts, int indexes );
@@ -1328,6 +1666,12 @@
 void RB_StageIteratorVertexLitTexture( void );
 void RB_StageIteratorLightmappedMultitexture( void );
 
+//New
+void RB_StageIteratorWater_GLSL( void );
+void RB_StageIteratorLightmappedMultitexture_GLSL( void );
+void RB_StageIteratorLightmappedTerrain_GLSL( void );
+void RB_StageIteratorCheapFancyWater_GLSL( void);
+
 void RB_AddQuadStamp( vec3_t origin, vec3_t left, vec3_t up, byte *color );
 void RB_AddQuadStampExt( vec3_t origin, vec3_t left, vec3_t up, byte *color, float s1, float t1, float s2, float t2 );
 
@@ -1344,6 +1688,7 @@
 
 void R_AddBrushModelSurfaces( trRefEntity_t *e );
 void R_AddWorldSurfaces( void );
+void R_AddWorldSurface( msurface_t *surf, int dlightBits );
 qboolean R_inPVS( const vec3_t p1, const vec3_t p2 );
 
 
@@ -1485,12 +1830,29 @@
 
 /*
 =============================================================
+
+IMAGE LOADERS
+
+=============================================================
+*/
+
+void R_LoadBMP( const char *name, byte **pic, int *width, int *height );
+void R_LoadJPG( const char *name, byte **pic, int *width, int *height );
+void R_LoadPCX( const char *name, byte **pic, int *width, int *height );
+void R_LoadPNG( const char *name, byte **pic, int *width, int *height );
+void R_LoadTGA( const char *name, byte **pic, int *width, int *height );
+
+/*
+=============================================================
 =============================================================
 */
 void	R_TransformModelToClip( const vec3_t src, const float *modelMatrix, const float *projectionMatrix,
 							vec4_t eye, vec4_t dst );
 void	R_TransformClipToWindow( const vec4_t clip, const viewParms_t *view, vec4_t normalized, vec4_t window );
 
+void myGlMultVector(  const float *matrix, vec3_t point );
+void myGlMultVectorRot(  const float *matrix, vec3_t point );
+
 void	RB_DeformTessGeometry( void );
 
 void	RB_CalcEnvironmentTexCoords( float *dstTexCoords );
@@ -1602,6 +1964,18 @@
 	qboolean			motionJpeg;
 } videoFrameCommand_t;
 
+typedef struct
+{
+	int commandId;
+
+	GLboolean rgba[4];
+} colorMaskCommand_t;
+
+typedef struct
+{
+	int commandId;
+} clearDepthCommand_t;
+
 typedef enum {
 	RC_END_OF_LIST,
 	RC_SET_COLOR,
@@ -1610,7 +1984,9 @@
 	RC_DRAW_BUFFER,
 	RC_SWAP_BUFFERS,
 	RC_SCREENSHOT,
-	RC_VIDEOFRAME
+	RC_VIDEOFRAME,
+	RC_COLORMASK,
+	RC_CLEARDEPTH
 } renderCommand_t;
 
 
@@ -1665,10 +2041,55 @@
 void RE_TakeVideoFrame( int width, int height,
 		byte *captureBuffer, byte *encodeBuffer, qboolean motionJpeg );
 
+void R_BuildCubeMaps( void );
+
+
 // font stuff
 void R_InitFreeType( void );
 void R_DoneFreeType( void );
 void RE_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font);
 
+void RB_SetupFragment( fragShader_t* frag, shader_t *shader );
+
+
+void RB_BindFragmentTextures(fragShader_t *frag,int diffuse0,	int normal0,    int bump0,
+												int diffuse1,	int normal1,	int bump1,
+												int cubemapA,int cubemapB);
+
+void RB_Blur( unsigned int source, renderbuffer_t *tempx, renderbuffer_t *dest, qboolean hdrclip, float HdrCut );
+void RB_SetFrameBuffer(renderbuffer_t *buffer);
+void RB_PostProcess( void );
+void GL_BindVBO( int Mode );
+void GL_UnBindVBO( void );
+
+void R_StoreDecalSurf(vec3_t v0,vec3_t v1,vec3_t v2,msurface_t *match);
+void R_AddDecalSurfs( void );
+
+void myGlMultPlane( const float *m, vec4_t plane, float* out);
+
+qboolean R_ParseEntitysForKey(char* classname, char* key, char *storage,int sizeofstore,int num);
+
+#define WATER_RES_X 512
+#define WATER_RES_Y 512
+
+#define GEOMETRY_INDEX_OFFSET(index) (const void *)((index * sizeof(unsigned int)))
+#define GEOMETRY_VERTEX_OFFSET(number, vertex, field) (const void *)((number * sizeof(vertex)) + (long int)&(((vertex*)0)->field))
+
+shader_t *GLSLMakeCloneOfShader(shader_t* checkshader);
+shader_t *GLSLOptimizeShader(shader_t *checkshader);
+shader_t *GLSLOptimizeShader_Simple(shader_t *checkshader);
+void GLSLLoadImplicitStages(shader_t* checkshader);
+qboolean R_LoadWorldFragShader(fragShader_t *frag, char* vertexprog, char* fragprog);
+
+mnode_t *R_PointInLeaf( const vec3_t p ) ;
+
+
+void R_SetupEntityLightingGrid( trRefEntity_t *ent ) ;
+cubemapProbe_t *R_FindBestCubeMap(vec3_t origin);
+float R_FindBestTwoCubeMaps(vec3_t origin,cubemapProbe_t **A, cubemapProbe_t **B);
+
+image_t *R_CreateCubeImage( const char *name, const byte *pic, int width, int height, 
+					   qboolean mipmap, qboolean allowPicmip, int glWrapClampMode,int CubemapFace, image_t *cubemapParent );
+
 
 #endif //TR_LOCAL_H
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_main.c bumpy-code/code/renderer/tr_main.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_main.c	2014-06-09 22:09:45.529844441 -0400
+++ bumpy-code/code/renderer/tr_main.c	2014-06-09 22:14:52.602548675 -0400
@@ -220,6 +220,41 @@
 	}
 }
 
+
+void myGlMultVector(  const float *matrix, vec3_t point )
+{
+	int i;
+	vec3_t eye;
+	for ( i = 0 ; i < 3 ; i++ ) 
+	{
+		eye[i] = 
+			point[0] * matrix[ i + 0 * 4 ] +
+			point[1] * matrix[ i + 1 * 4 ] +
+			point[2] * matrix[ i + 2 * 4 ] +
+			1 * matrix[ i + 3 * 4 ];
+	}
+	point[0]=eye[0];
+	point[1]=eye[1];
+	point[2]=eye[2];
+}
+
+//only use the rotational part
+void myGlMultVectorRot(  const float *matrix, vec3_t point )
+{
+	int i;
+	vec3_t eye;
+	for ( i = 0 ; i < 3 ; i++ ) 
+	{
+		eye[i] = 
+			point[0] * matrix[ i + 0 * 4 ] +
+			point[1] * matrix[ i + 1 * 4 ] +
+			point[2] * matrix[ i + 2 * 4 ];
+	}
+	point[0]=eye[0];
+	point[1]=eye[1];
+	point[2]=eye[2];
+}
+
 /*
 ==========================
 R_TransformClipToWindow
@@ -260,6 +295,42 @@
 	}
 }
 
+void myGlMultPlane( const float *m, vec4_t plane, float* out)
+{
+	vec3_t PP,PN;
+
+	//out[0] = plane[0] * m[0]  + plane[1] * m[1]  + plane[2] * m[2]  + plane[3] * m[3];
+	//out[1] = plane[0] * m[4]  + plane[1] * m[5]  + plane[2] * m[6]  + plane[3] * m[7];
+	//out[2] = plane[0] * m[8]  + plane[1] * m[9]  + plane[2] * m[10] + plane[3] * m[11];
+	//out[3] = plane[0] * m[12] + plane[1] * m[13] + plane[2] * m[14] + plane[3] * m[15];
+
+	//return;
+
+//fvector3 PPt = PP * M;
+//fvector3 PNt = PN * M.upper3x3Part();
+//PNt.normalize();
+//fvector4 PlaneNew(PNt.x, PNt.y, PNt.z, -(PPt DOT PNt));
+
+	//Point on plane
+	PP[0]=plane[0]*plane[3];
+	PP[1]=plane[1]*plane[3];
+	PP[2]=plane[2]*plane[3];
+
+	PN[0]=plane[0];
+	PN[1]=plane[1];
+	PN[2]=plane[2];
+
+	myGlMultVector(m,PP);
+	myGlMultVectorRot(m,PN);
+	
+	VectorNormalize(PN);
+
+	out[0]=PN[0];
+	out[1]=PN[1];
+	out[2]=PN[2];
+	out[3]=-(PN[0]*PP[0]+PN[1]*PP[1]+PN[2]*PP[2]);
+}
+
 /*
 =================
 R_RotateForEntity
@@ -340,6 +411,7 @@
 {
 	float	viewerMatrix[16];
 	vec3_t	origin;
+	int j;
 
 	Com_Memset (&tr.or, 0, sizeof(tr.or));
 	tr.or.axis[0][0] = 1;
@@ -374,14 +446,48 @@
 	// to OpenGL's coordinate system (looking down -Z)
 	myGlMultMatrix( viewerMatrix, s_flipMatrix, tr.or.modelMatrix );
 
+	for (j=0;j<16;j++)
+	{
+		tr.or.u_modelMatrix[j]=viewerMatrix[j];
+	}
+
 	tr.viewParms.world = tr.or;
+}
+
+
+
+void R_ViewMat(float *viewerMatrix) 
+{
+	vec3_t	origin;
+
+	VectorCopy( tr.viewParms.or.origin, origin );
+
+	viewerMatrix[0] = tr.viewParms.or.axis[0][0];
+	viewerMatrix[4] = tr.viewParms.or.axis[0][1];
+	viewerMatrix[8] = tr.viewParms.or.axis[0][2];
+	viewerMatrix[12] = -origin[0] * viewerMatrix[0] + -origin[1] * viewerMatrix[4] + -origin[2] * viewerMatrix[8];
+
+	viewerMatrix[1] = tr.viewParms.or.axis[1][0];
+	viewerMatrix[5] = tr.viewParms.or.axis[1][1];
+	viewerMatrix[9] = tr.viewParms.or.axis[1][2];
+	viewerMatrix[13] = -origin[0] * viewerMatrix[1] + -origin[1] * viewerMatrix[5] + -origin[2] * viewerMatrix[9];
+
+	viewerMatrix[2] = tr.viewParms.or.axis[2][0];
+	viewerMatrix[6] = tr.viewParms.or.axis[2][1];
+	viewerMatrix[10] = tr.viewParms.or.axis[2][2];
+	viewerMatrix[14] = -origin[0] * viewerMatrix[2] + -origin[1] * viewerMatrix[6] + -origin[2] * viewerMatrix[10];
+
+	viewerMatrix[3] = 0;
+	viewerMatrix[7] = 0;
+	viewerMatrix[11] = 0;
+	viewerMatrix[15] = 1;
 
 }
 
 /*
 ** SetFarClip
 */
-static void SetFarClip( void )
+static void R_SetFarClip( void )
 {
 	float	farthestCornerDistance = 0;
 	int		i;
@@ -393,6 +499,24 @@
 		return;
 	}
 
+	//27 hack:  I couldnt be bothered (its slow) inversing the view projecting for dof z calculations/fog
+	//so we fix zfar 
+	if (0)
+	{
+		float *wMins,*wMaxs;
+		vec3_t v;
+		wMins = tr.world->bmodels[0].bounds[0];
+		wMaxs = tr.world->bmodels[0].bounds[1];
+		v[0]=wMaxs[0]-wMins[0];
+		v[1]=wMaxs[1]-wMins[1];
+		v[2]=wMaxs[2]-wMins[2];
+
+		
+		tr.viewParms.zFar = VectorLength(v);
+		return;
+	}
+	
+
 	//
 	// set far clipping planes dynamically
 	//
@@ -442,97 +566,144 @@
 	tr.viewParms.zFar = sqrt( farthestCornerDistance );
 }
 
+/*
+=================
+R_SetupFrustum
+
+Set up the culling frustum planes for the current view using the results we got from computing the first two rows of
+the projection matrix.
+=================
+*/
+void R_SetupFrustum (viewParms_t *dest, float xmin, float xmax, float ymax, float zProj, float stereoSep)
+{
+	vec3_t ofsorigin;
+	float oppleg, adjleg, length;
+	int i;
+	
+	if(stereoSep == 0 && xmin != -xmax)
+	{
+		// symmetric case can be simplified
+		VectorCopy(dest->or.origin, ofsorigin);
+
+		length = sqrt(xmax * xmax + zProj * zProj);
+		oppleg = xmax / length;
+		adjleg = zProj / length;
+
+		VectorScale(dest->or.axis[0], oppleg, dest->frustum[0].normal);
+		VectorMA(dest->frustum[0].normal, adjleg, dest->or.axis[1], dest->frustum[0].normal);
+
+		VectorScale(dest->or.axis[0], oppleg, dest->frustum[1].normal);
+		VectorMA(dest->frustum[1].normal, -adjleg, dest->or.axis[1], dest->frustum[1].normal);
+	}
+	else
+	{
+		// In stereo rendering, due to the modification of the projection matrix, dest->or.origin is not the
+		// actual origin that we're rendering so offset the tip of the view pyramid.
+		VectorMA(dest->or.origin, stereoSep, dest->or.axis[1], ofsorigin);
+	
+		oppleg = xmax + stereoSep;
+		length = sqrt(oppleg * oppleg + zProj * zProj);
+		VectorScale(dest->or.axis[0], oppleg / length, dest->frustum[0].normal);
+		VectorMA(dest->frustum[0].normal, zProj / length, dest->or.axis[1], dest->frustum[0].normal);
+
+		oppleg = xmin + stereoSep;
+		length = sqrt(oppleg * oppleg + zProj * zProj);
+		VectorScale(dest->or.axis[0], -oppleg / length, dest->frustum[1].normal);
+		VectorMA(dest->frustum[1].normal, -zProj / length, dest->or.axis[1], dest->frustum[1].normal);
+	}
+
+	length = sqrt(ymax * ymax + zProj * zProj);
+	oppleg = ymax / length;
+	adjleg = zProj / length;
+
+	VectorScale(dest->or.axis[0], oppleg, dest->frustum[2].normal);
+	VectorMA(dest->frustum[2].normal, adjleg, dest->or.axis[2], dest->frustum[2].normal);
+
+	VectorScale(dest->or.axis[0], oppleg, dest->frustum[3].normal);
+	VectorMA(dest->frustum[3].normal, -adjleg, dest->or.axis[2], dest->frustum[3].normal);
+	
+	for (i=0 ; i<4 ; i++) {
+		dest->frustum[i].type = PLANE_NON_AXIAL;
+		dest->frustum[i].dist = DotProduct (ofsorigin, dest->frustum[i].normal);
+		SetPlaneSignbits( &dest->frustum[i] );
+	}
+}
 
 /*
 ===============
 R_SetupProjection
 ===============
 */
-void R_SetupProjection( void ) {
+void R_SetupProjection(viewParms_t *dest, float zProj, qboolean computeFrustum)
+{
 	float	xmin, xmax, ymin, ymax;
-	float	width, height, depth;
-	float	zNear, zFar;
+	float	width, height, stereoSep = r_stereoSeparation->value;
 
-	// dynamically compute far clip plane distance
-	SetFarClip();
+	/*
+	 * offset the view origin of the viewer for stereo rendering 
+	 * by setting the projection matrix appropriately.
+	 */
 
-	//
-	// set up projection matrix
-	//
-	zNear	= r_znear->value;
-	zFar	= tr.viewParms.zFar;
+	if(stereoSep != 0)
+	{
+		if(dest->stereoFrame == STEREO_LEFT)
+			stereoSep = zProj / r_stereoSeparation->value;
+		else if(dest->stereoFrame == STEREO_RIGHT)
+			stereoSep = zProj / -r_stereoSeparation->value;
+		else
+			stereoSep = 0;
+	}
 
-	ymax = zNear * tan( tr.refdef.fov_y * M_PI / 360.0f );
+	ymax = zProj * tan(dest->fovY * M_PI / 360.0f);
 	ymin = -ymax;
 
-	xmax = zNear * tan( tr.refdef.fov_x * M_PI / 360.0f );
+	xmax = zProj * tan(dest->fovX * M_PI / 360.0f);
 	xmin = -xmax;
 
 	width = xmax - xmin;
 	height = ymax - ymin;
-	depth = zFar - zNear;
 
-	tr.viewParms.projectionMatrix[0] = 2 * zNear / width;
-	tr.viewParms.projectionMatrix[4] = 0;
-	tr.viewParms.projectionMatrix[8] = ( xmax + xmin ) / width;	// normally 0
-	tr.viewParms.projectionMatrix[12] = 0;
-
-	tr.viewParms.projectionMatrix[1] = 0;
-	tr.viewParms.projectionMatrix[5] = 2 * zNear / height;
-	tr.viewParms.projectionMatrix[9] = ( ymax + ymin ) / height;	// normally 0
-	tr.viewParms.projectionMatrix[13] = 0;
-
-	tr.viewParms.projectionMatrix[2] = 0;
-	tr.viewParms.projectionMatrix[6] = 0;
-	tr.viewParms.projectionMatrix[10] = -( zFar + zNear ) / depth;
-	tr.viewParms.projectionMatrix[14] = -2 * zFar * zNear / depth;
-
-	tr.viewParms.projectionMatrix[3] = 0;
-	tr.viewParms.projectionMatrix[7] = 0;
-	tr.viewParms.projectionMatrix[11] = -1;
-	tr.viewParms.projectionMatrix[15] = 0;
+	dest->projectionMatrix[0] = 2 * zProj / width;
+	dest->projectionMatrix[4] = 0;
+	dest->projectionMatrix[8] = (xmax + xmin + 2 * stereoSep) / width;
+	dest->projectionMatrix[12] = 2 * zProj * stereoSep / width;
+
+	dest->projectionMatrix[1] = 0;
+	dest->projectionMatrix[5] = 2 * zProj / height;
+	dest->projectionMatrix[9] = ( ymax + ymin ) / height;	// normally 0
+	dest->projectionMatrix[13] = 0;
+
+	dest->projectionMatrix[3] = 0;
+	dest->projectionMatrix[7] = 0;
+	dest->projectionMatrix[11] = -1;
+	dest->projectionMatrix[15] = 0;
+
+	// Now that we have all the data for the projection matrix we can also setup the view frustum.
+	if(computeFrustum)
+		R_SetupFrustum(dest, xmin, xmax, ymax, zProj, stereoSep);
 }
 
 /*
-=================
-R_SetupFrustum
+===============
+R_SetupProjectionZ
 
-Setup that culling frustum planes for the current view
-=================
+Sets the z-component transformation part in the projection matrix
+===============
 */
-void R_SetupFrustum (void) {
-	int		i;
-	float	xs, xc;
-	float	ang;
-
-	ang = tr.viewParms.fovX / 180 * M_PI * 0.5f;
-	xs = sin( ang );
-	xc = cos( ang );
-
-	VectorScale( tr.viewParms.or.axis[0], xs, tr.viewParms.frustum[0].normal );
-	VectorMA( tr.viewParms.frustum[0].normal, xc, tr.viewParms.or.axis[1], tr.viewParms.frustum[0].normal );
-
-	VectorScale( tr.viewParms.or.axis[0], xs, tr.viewParms.frustum[1].normal );
-	VectorMA( tr.viewParms.frustum[1].normal, -xc, tr.viewParms.or.axis[1], tr.viewParms.frustum[1].normal );
-
-	ang = tr.viewParms.fovY / 180 * M_PI * 0.5f;
-	xs = sin( ang );
-	xc = cos( ang );
-
-	VectorScale( tr.viewParms.or.axis[0], xs, tr.viewParms.frustum[2].normal );
-	VectorMA( tr.viewParms.frustum[2].normal, xc, tr.viewParms.or.axis[2], tr.viewParms.frustum[2].normal );
+void R_SetupProjectionZ(viewParms_t *dest)
+{
+	float zNear, zFar, depth;
 
-	VectorScale( tr.viewParms.or.axis[0], xs, tr.viewParms.frustum[3].normal );
-	VectorMA( tr.viewParms.frustum[3].normal, -xc, tr.viewParms.or.axis[2], tr.viewParms.frustum[3].normal );
+	zNear	= r_znear->value;
+	zFar	= dest->zFar;	
+	depth	= zFar - zNear;
 
-	for (i=0 ; i<4 ; i++) {
-		tr.viewParms.frustum[i].type = PLANE_NON_AXIAL;
-		tr.viewParms.frustum[i].dist = DotProduct (tr.viewParms.or.origin, tr.viewParms.frustum[i].normal);
-		SetPlaneSignbits( &tr.viewParms.frustum[i] );
-	}
+	dest->projectionMatrix[2] = 0;
+	dest->projectionMatrix[6] = 0;
+	dest->projectionMatrix[10] = -( zFar + zNear ) / depth;
+	dest->projectionMatrix[14] = -2 * zFar * zNear / depth;
 }
 
-
 /*
 =================
 R_MirrorPoint
@@ -815,7 +986,8 @@
 	unsigned int pointOr = 0;
 	unsigned int pointAnd = (unsigned int)~0;
 
-	if ( glConfig.smpActive ) {		// FIXME!  we can't do RB_BeginSurface/RB_EndSurface stuff with smp!
+	// FIXME!  we can't do RB_BeginSurface/RB_EndSurface stuff with smp and anaglyph mode!
+	if ( glConfig.smpActive || r_anaglyphMode->integer || !drawSurf->surface ) {		
 		return qfalse;
 	}
 
@@ -959,6 +1131,116 @@
 }
 
 /*
+========================
+GetSurfaceOrientations
+========================
+*/
+void R_GetSurfaceOrientations( cplane_t *plane,  orientation_t *surface, orientation_t *camera )
+{
+	VectorCopy( plane->normal, surface->axis[0] );
+	PerpendicularVector( surface->axis[1], surface->axis[0] );
+	CrossProduct( surface->axis[0], surface->axis[1], surface->axis[2] );
+
+	VectorScale( plane->normal, plane->dist, surface->origin );
+	VectorCopy( surface->origin, camera->origin );
+	VectorSubtract( vec3_origin, surface->axis[0], camera->axis[0] );
+	VectorCopy( surface->axis[1], camera->axis[1] );
+	VectorCopy( surface->axis[2], camera->axis[2] );
+
+}
+
+/*
+========================
+R_DoWaterView 
+
+Returns qtrue if another view has been rendered
+========================
+*/
+qboolean R_DoWaterView (drawSurf_t *drawSurf, int entityNum) {
+//	vec4_t			clipDest[128];
+	viewParms_t		newParms;
+	viewParms_t		oldParms;
+	orientation_t	surface, camera;
+	cplane_t		plane;
+	srfSurfaceStatic_t *srf;
+		
+	// don't recursively do water
+	if (tr.viewParms.doWater) {
+		// tesselated water has this issue - so we just ignore and not spam console
+		// ri.Printf( PRINT_DEVELOPER, "WARNING: recursive water found\n" );
+		return qfalse;
+	}
+
+	srf = (srfSurfaceStatic_t *)drawSurf->surface;
+	// trivially reject portal/mirror
+	//This wont work because vbo surfs dont fill out tess...
+	//if ( SurfIsOffscreen( drawSurf, clipDest ) ) {
+	//	return qfalse;
+	//}
+
+	//Set plane
+	tr.viewParms.doWater = qtrue;
+	tr.viewParms.waterPlane.normal[0] = 0;
+	tr.viewParms.waterPlane.normal[1] = 0;
+	tr.viewParms.waterPlane.normal[2] = -1;
+	tr.viewParms.waterPlane.dist = srf->origin[2];
+
+	if ( DotProduct(tr.viewParms.waterPlane.normal,tr.viewParms.or.origin)+tr.viewParms.waterPlane.dist >0)
+	{
+		tr.viewParms.isUnderwater=qtrue;	
+	}
+
+	// save old viewParms so we can return to it after the mirror view
+	oldParms = tr.viewParms;
+
+	newParms = tr.viewParms;
+	newParms.isWater = 1;
+	newParms.viewportWidth=WATER_RES_X;
+	newParms.viewportHeight=WATER_RES_Y;
+	newParms.viewportX =0;//tr.refdef.x;
+	newParms.viewportY =0;// glConfig.vidHeight - ( tr.refdef.y + WATER_RES_Y );
+
+
+	tr.refdef.rdflags|= RDF_NOEFFECTS ;
+
+	// render the mirror view
+	R_RenderView (&newParms);
+
+	//Do the second view now
+	newParms = tr.viewParms;
+	newParms.isWater = 2;
+	newParms.isMirror = qtrue;
+	newParms.viewportWidth = WATER_RES_X;
+	newParms.viewportHeight = WATER_RES_Y;
+	newParms.viewportX = 0;//tr.refdef.x;
+	newParms.viewportY = 0;//glConfig.vidHeight - ( tr.refdef.y + WATER_RES_Y );
+	
+
+	plane.dist=tr.viewParms.waterPlane.dist;
+	plane.normal[0]=-tr.viewParms.waterPlane.normal[0];
+	plane.normal[1]=-tr.viewParms.waterPlane.normal[1];
+	plane.normal[2]=-tr.viewParms.waterPlane.normal[2];
+
+	R_GetSurfaceOrientations( &plane, &surface, &camera );
+
+	R_MirrorPoint (oldParms.or.origin, &surface, &camera, newParms.or.origin );
+	R_MirrorVector (oldParms.or.axis[0], &surface, &camera, newParms.or.axis[0]);
+	R_MirrorVector (oldParms.or.axis[1], &surface, &camera, newParms.or.axis[1]);
+	R_MirrorVector (oldParms.or.axis[2], &surface, &camera, newParms.or.axis[2]);
+
+
+	// render the mirror view
+	tr.refdef.rdflags|= RDF_NOEFFECTS;
+	R_RenderView (&newParms); 
+
+	tr.viewParms = oldParms;
+	tr.refdef.rdflags&= ~RDF_NOEFFECTS;
+	
+	return qtrue; 
+}
+
+
+/*
 =================
 R_SpriteFogNum
 
@@ -1119,6 +1401,19 @@
 	for ( i = 0 ; i < numDrawSurfs ; i++ ) {
 		R_DecomposeSort( (drawSurfs+i)->sort, &entityNum, &shader, &fogNum, &dlighted );
 
+		if (!shader) continue;
+		// check to see if we're drawing the water surface here ^^
+		if (shader->optimalStageIteratorFunc==RB_StageIteratorWater_GLSL)
+		{
+			R_DoWaterView((drawSurfs+i),0);
+			break;
+		}
+	}
+
+	for ( i = 0 ; i < numDrawSurfs ; i++ ) {
+		R_DecomposeSort( (drawSurfs+i)->sort, &entityNum, &shader, &fogNum, &dlighted );
+
+
 		if ( shader->sort > SS_PORTAL ) {
 			break;
 		}
@@ -1169,7 +1464,8 @@
 		// we don't want the hacked weapon position showing in 
 		// mirrors, because the true body position will already be drawn
 		//
-		if ( (ent->e.renderfx & RF_FIRST_PERSON) && tr.viewParms.isPortal) {
+                //if ( (ent->e.renderfx & RF_FIRST_PERSON) && (tr.viewParms.isPortal || tr.viewParms.isWater) ) {
+		if ( (ent->e.renderfx & RF_FIRST_PERSON) && (tr.viewParms.isPortal || tr.viewParms.isWater) ) {
 			continue;
 		}
 
@@ -1251,7 +1547,12 @@
 	// this needs to be done before entities are
 	// added, because they use the projection
 	// matrix for lod calculation
-	R_SetupProjection ();
+
+	// dynamically compute far clip plane distance
+	R_SetFarClip();
+
+	// we know the size of the clipping volume. Now set the rest of the projection matrix.
+	R_SetupProjectionZ (&tr.viewParms);
 
 	R_AddEntitySurfaces ();
 }
@@ -1336,7 +1637,7 @@
 	// set viewParms.world
 	R_RotateForViewer ();
 
-	R_SetupFrustum ();
+	R_SetupProjection(&tr.viewParms, r_zproj->value, qtrue);
 
 	R_GenerateDrawSurfs();
 
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_marks.c bumpy-code/code/renderer/tr_marks.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_marks.c	2014-06-09 22:09:45.529844441 -0400
+++ bumpy-code/code/renderer/tr_marks.c	2014-06-09 22:14:52.602548675 -0400
@@ -133,7 +133,7 @@
 */
 void R_BoxSurfaces_r(mnode_t *node, vec3_t mins, vec3_t maxs, surfaceType_t **list, int listsize, int *listlength, vec3_t dir) {
 
-	int			s, c;
+	int			s, c, j;
 	msurface_t	*surf, **mark;
 
 	// do the tail recursion in a loop
@@ -157,6 +157,8 @@
 		if (*listlength >= listsize) break;
 		//
 		surf = *mark;
+		if (surf->viewCount == tr.viewCount) continue; //27: optimization, this surface has already been checked
+
 		// check if the surface has NOIMPACT or NOMARKS set
 		if ( ( surf->shader->surfaceFlags & ( SURF_NOIMPACT | SURF_NOMARKS ) )
 			|| ( surf->shader->contentFlags & CONTENTS_FOG ) ) {
@@ -173,6 +175,7 @@
 				surf->viewCount = tr.viewCount;
 			}
 		}
+		//else if (*(surfaceType_t *) (surf->data) != SF_GRID && *(surfaceType_t *) (surf->data) != SF_STATIC) surf->viewCount = tr.viewCount;
 		else if (*(surfaceType_t *) (surf->data) != SF_GRID) surf->viewCount = tr.viewCount;
 		// check the viewCount because the surface may have
 		// already been added if it spans multiple leafs
@@ -183,6 +186,39 @@
 		}
 		mark++;
 	}
+
+
+	// add the decal surfaces
+	
+	for (j=0;j<node->numDecalTris;j++)
+	{
+		if (*listlength >= listsize) break;		
+		if (node->decalTris[j]->viewCount == tr.viewCount) continue;
+
+		s = BoxOnPlaneSide( mins, maxs, &node->decalTris[j]->plane );
+		if (s == 1 || s == 2) 
+		{
+			node->decalTris[j]->viewCount = tr.viewCount;
+		}
+		else 
+		if (DotProduct(node->decalTris[j]->plane.normal , dir) > -0.5) 
+		{
+			// don't add faces that make sharp angles with the projection direction
+			node->decalTris[j]->viewCount = tr.viewCount;
+			
+		}
+		
+		// check the viewCount because the surface may have
+		// already been added if it spans multiple leafs
+		if (node->decalTris[j]->viewCount != tr.viewCount) 
+		{
+			node->decalTris[j]->viewCount = tr.viewCount;
+			list[*listlength] = (surfaceType_t *)node->decalTris[j];
+			(*listlength)++;
+		}
+	
+	}
+	
 }
 
 /*
@@ -250,11 +286,12 @@
 
 =================
 */
+#define MAX_SURFS 512
 int R_MarkFragments( int numPoints, const vec3_t *points, const vec3_t projection,
 				   int maxPoints, vec3_t pointBuffer, int maxFragments, markFragment_t *fragmentBuffer ) {
 	int				numsurfaces, numPlanes;
 	int				i, j, k, m, n;
-	surfaceType_t	*surfaces[64];
+	surfaceType_t	*surfaces[MAX_SURFS];
 	vec3_t			mins, maxs;
 	int				returnedFragments;
 	int				returnedPoints;
@@ -264,6 +301,7 @@
 	int				numClipPoints;
 	float			*v;
 	srfSurfaceFace_t *surf;
+	srfSurfaceDecal_t *Ssurf;
 	srfGridMesh_t	*cv;
 	drawVert_t		*dv;
 	vec3_t			normal;
@@ -308,7 +346,7 @@
 	numPlanes = numPoints + 2;
 
 	numsurfaces = 0;
-	R_BoxSurfaces_r(tr.world->nodes, mins, maxs, surfaces, 64, &numsurfaces, projectionDir);
+	R_BoxSurfaces_r(tr.world->nodes, mins, maxs, surfaces, MAX_SURFS, &numsurfaces, projectionDir);
 	//assert(numsurfaces <= 64);
 	//assert(numsurfaces != 64);
 
@@ -401,6 +439,7 @@
 
 			surf = ( srfSurfaceFace_t * ) surfaces[i];
 			// check the normal of this face
+			//27: Why does this get done twice?
 			if (DotProduct(surf->plane.normal, projectionDir) > -0.5) {
 				continue;
 			}
@@ -416,7 +455,8 @@
 			for ( k = 0 ; k < surf->numIndices ; k += 3 ) {
 				for ( j = 0 ; j < 3 ; j++ ) {
 					v = surf->points[0] + VERTEXSIZE * indexes[k+j];;
-					VectorMA( v, MARKER_OFFSET, surf->plane.normal, clipPoints[0][j] );
+					//VectorMA( v, MARKER_OFFSET, surf->plane.normal, clipPoints[0][j] );
+					VectorCopy( v, clipPoints[0][j] );
 				}
 				// add the fragments of this face
 				R_AddMarkFragments( 3 , clipPoints,
@@ -430,7 +470,61 @@
 			}
 			continue;
 		}
-		else {
+		else if (*surfaces[i] == SF_DECALSURF) 
+		{
+			Ssurf = ( srfSurfaceDecal_t* ) surfaces[i];
+			
+			VectorCopy( Ssurf->v[0],clipPoints[0][0]);
+			VectorCopy( Ssurf->v[1],clipPoints[0][1]);
+			VectorCopy( Ssurf->v[2],clipPoints[0][2]);
+			R_AddMarkFragments( 3 , clipPoints,
+						   numPlanes, normals, dists,
+						   maxPoints, pointBuffer,
+						   maxFragments, fragmentBuffer,
+						&returnedPoints, &returnedFragments, mins, maxs);
+			if ( returnedFragments == maxFragments ) 
+			{
+				return returnedFragments;	// not enough space for more fragments
+			}
+			continue;
+
+
+		}
+		/*else 
+		if (*surfaces[i] == SF_STATIC)
+		{
+			//Todo: Marky
+			Ssurf = ( srfSurfaceStatic_t * ) surfaces[i];
+
+			for (j=0;j<Ssurf->numIndices;j+=3)
+			{
+				staticVert_t* V[3];
+
+				V[0]=&tr.staticVertexData[tr.staticIndexData[Ssurf->startIndex+j+0]];
+				V[1]=&tr.staticVertexData[tr.staticIndexData[Ssurf->startIndex+j+1]];
+				V[2]=&tr.staticVertexData[tr.staticIndexData[Ssurf->startIndex+j+2]];
+
+				VectorCopy( V[0]->position,clipPoints[0][0]);
+				VectorCopy( V[1]->position,clipPoints[0][1]);
+				VectorCopy( V[2]->position,clipPoints[0][2]);
+				
+				R_AddMarkFragments( 3 , clipPoints,
+					   numPlanes, normals, dists,
+					   maxPoints, pointBuffer,
+					   maxFragments, fragmentBuffer,
+					   &returnedPoints, &returnedFragments, mins, maxs);
+				if ( returnedFragments == maxFragments ) 
+				{
+					return returnedFragments;	// not enough space for more fragments
+				}
+
+			}
+			
+			continue;
+
+		}*/
+		else
+		{
 			// ignore all other world surfaces
 			// might be cool to also project polygons on a triangle soup
 			// however this will probably create huge amounts of extra polys
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_mesh.c bumpy-code/code/renderer/tr_mesh.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_mesh.c	2014-06-09 22:09:45.529844441 -0400
+++ bumpy-code/code/renderer/tr_mesh.c	2014-06-09 22:14:52.602548675 -0400
@@ -297,7 +297,7 @@
 	qboolean		personalModel;
 
 	// don't add third_person objects if not in a portal
-	personalModel = (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.isPortal;
+	personalModel = (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.isPortal && !tr.viewParms.isWater;
 
 	if ( ent->e.renderfx & RF_WRAP_FRAMES ) {
 		ent->e.frame %= tr.currentModel->md3[0]->numFrames;
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_model.c bumpy-code/code/renderer/tr_model.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_model.c	2014-06-09 22:09:45.529844441 -0400
+++ bumpy-code/code/renderer/tr_model.c	2014-06-09 22:14:52.602548675 -0400
@@ -83,7 +83,10 @@
 */
 qhandle_t RE_RegisterModel( const char *name ) {
 	model_t		*mod;
-	unsigned	*buf;
+	union {
+		unsigned *u;
+		void *v;
+	} buf;
 	int			lod;
 	int			ident;
 	qboolean	loaded = qfalse;
@@ -151,19 +154,19 @@
 	{
 		int filesize;
 		
-		filesize = ri.FS_ReadFile(name, (void **) &buf);
-		if(!buf)
+		filesize = ri.FS_ReadFile(name, (void **) &buf.v);
+		if(!buf.u)
 		{
 			ri.Printf (PRINT_WARNING,"RE_RegisterModel: couldn't load %s\n", name);
 			mod->type = MOD_BAD;
 			return 0;
 		}
 		
-		ident = LittleLong(*(unsigned *)buf);
+		ident = LittleLong(*(unsigned *)buf.u);
 		if(ident == MDR_IDENT)
-			loaded = R_LoadMDR(mod, buf, filesize, name);
+			loaded = R_LoadMDR(mod, buf.u, filesize, name);
 
-		ri.FS_FreeFile (buf);
+		ri.FS_FreeFile (buf.v);
 		
 		if(!loaded)
 		{
@@ -184,26 +187,26 @@
 		else
 			Com_sprintf(namebuf, sizeof(namebuf), "%s.%s", filename, fext);
 
-		ri.FS_ReadFile( namebuf, (void **)&buf );
-		if ( !buf ) {
+		ri.FS_ReadFile( namebuf, &buf.v );
+		if ( !buf.u ) {
 			continue;
 		}
 		
 		loadmodel = mod;
 		
-		ident = LittleLong(*(unsigned *)buf);
+		ident = LittleLong(*(unsigned *)buf.u);
 		if ( ident == MD4_IDENT ) {
-			loaded = R_LoadMD4( mod, buf, name );
+			loaded = R_LoadMD4( mod, buf.u, name );
 		} else {
 			if ( ident != MD3_IDENT ) {
 				ri.Printf (PRINT_WARNING,"RE_RegisterModel: unknown fileid for %s\n", name);
 				goto fail;
 			}
 
-			loaded = R_LoadMD3( mod, lod, buf, name );
+			loaded = R_LoadMD3( mod, lod, buf.u, name );
 		}
 		
-		ri.FS_FreeFile (buf);
+		ri.FS_FreeFile (buf.v);
 
 		if ( !loaded ) {
 			if ( lod == 0 ) {
@@ -404,13 +407,13 @@
 }
 
 
+#ifdef RAVENMD4
 
 /*
 =================
 R_LoadMDR
 =================
 */
-#ifdef RAVENMD4
 static qboolean R_LoadMDR( model_t *mod, void *buffer, int filesize, const char *mod_name ) 
 {
 	int					i, j, k, l;
@@ -444,9 +447,9 @@
 	
 	mod->type = MOD_MDR;
 
-	pinmodel->numFrames = LittleLong(pinmodel->numFrames);
-	pinmodel->numBones = LittleLong(pinmodel->numBones);
-	pinmodel->ofsFrames = LittleLong(pinmodel->ofsFrames);
+	LL(pinmodel->numFrames);
+	LL(pinmodel->numBones);
+	LL(pinmodel->ofsFrames);
 	
 	// This is a model that uses some type of compressed Bones. We don't want to uncompress every bone for each rendered frame
 	// over and over again, we'll uncompress it in this function already, so we must adjust the size of the target md4.
@@ -458,6 +461,14 @@
 		size += pinmodel->numFrames * pinmodel->numBones * ((sizeof(mdrBone_t) - sizeof(mdrCompBone_t)));
 	}
 	
+	// simple bounds check
+	if(pinmodel->numBones < 0 ||
+		sizeof(*mdr) + pinmodel->numFrames * (sizeof(*frame) + (pinmodel->numBones - 1) * sizeof(*frame->bones)) > size)
+	{
+		ri.Printf(PRINT_WARNING, "R_LoadMDR: %s has broken structure.\n", mod_name);
+		return qfalse;
+	}
+
 	mod->dataSize += size;
 	mod->md4 = mdr = ri.Hunk_Alloc( size, h_low );
 
@@ -470,7 +481,7 @@
 	mdr->numBones = pinmodel->numBones;
 	mdr->numLODs = LittleLong(pinmodel->numLODs);
 	mdr->numTags = LittleLong(pinmodel->numTags);
-	// We don't care about offset values, we'll generate them ourselves while loading.
+	// We don't care about the other offset values, we'll generate them ourselves while loading.
 	
 	mod->numLods = mdr->numLODs;
 
@@ -565,6 +576,13 @@
 	// swap all the LOD's
 	for ( l = 0 ; l < mdr->numLODs ; l++)
 	{
+		// simple bounds check
+		if((byte *) (lod + 1) > (byte *) mdr + size)
+		{
+			ri.Printf(PRINT_WARNING, "R_LoadMDR: %s has broken structure.\n", mod_name);
+			return qfalse;
+		}
+
 		lod->numSurfaces = LittleLong(curlod->numSurfaces);
 		
 		// swap all the surfaces
@@ -572,7 +590,15 @@
 		lod->ofsSurfaces = (int)((byte *) surf - (byte *) lod);
 		cursurf = (mdrSurface_t *) ((byte *)curlod + LittleLong(curlod->ofsSurfaces));
 		
-		for ( i = 0 ; i < lod->numSurfaces ; i++) {
+		for ( i = 0 ; i < lod->numSurfaces ; i++)
+		{
+			// simple bounds check
+			if((byte *) (surf + 1) > (byte *) mdr + size)
+			{
+				ri.Printf(PRINT_WARNING, "R_LoadMDR: %s has broken structure.\n", mod_name);
+				return qfalse;
+			}
+
 			// first do some copying stuff
 			
 			surf->ident = SF_MDR;
@@ -616,6 +642,15 @@
 			
 			for(j = 0; j < surf->numVerts; j++)
 			{
+				LL(curv->numWeights);
+			
+				// simple bounds check
+				if(curv->numWeights < 0 || (byte *) (v + 1) + (curv->numWeights - 1) * sizeof(*weight) > (byte *) mdr + size)
+				{
+					ri.Printf(PRINT_WARNING, "R_LoadMDR: %s has broken structure.\n", mod_name);
+					return qfalse;
+				}
+
 				v->normal[0] = LittleFloat(curv->normal[0]);
 				v->normal[1] = LittleFloat(curv->normal[1]);
 				v->normal[2] = LittleFloat(curv->normal[2]);
@@ -623,7 +658,7 @@
 				v->texCoords[0] = LittleFloat(curv->texCoords[0]);
 				v->texCoords[1] = LittleFloat(curv->texCoords[1]);
 				
-				v->numWeights = LittleLong(curv->numWeights);
+				v->numWeights = curv->numWeights;
 				weight = &v->weights[0];
 				curweight = &curv->weights[0];
 				
@@ -650,6 +685,13 @@
 			surf->ofsTriangles = (int)((byte *) tri - (byte *) surf);
 			curtri = (mdrTriangle_t *)((byte *) cursurf + LittleLong(cursurf->ofsTriangles));
 			
+			// simple bounds check
+			if(surf->numTriangles < 0 || (byte *) (tri + surf->numTriangles) > (byte *) mdr + size)
+			{
+				ri.Printf(PRINT_WARNING, "R_LoadMDR: %s has broken structure.\n", mod_name);
+				return qfalse;
+			}
+
 			for(j = 0; j < surf->numTriangles; j++)
 			{
 				tri->indexes[0] = LittleLong(curtri->indexes[0]);
@@ -681,6 +723,13 @@
 	mdr->ofsTags = (int)((byte *) tag - (byte *) mdr);
 	curtag = (mdrTag_t *) ((byte *)pinmodel + LittleLong(pinmodel->ofsTags));
 	
+	// simple bounds check
+	if(mdr->numTags < 0 || (byte *) (tag + mdr->numTags) > (byte *) mdr + size)
+	{
+		ri.Printf(PRINT_WARNING, "R_LoadMDR: %s has broken structure.\n", mod_name);
+		return qfalse;
+	}
+	
 	for (i = 0 ; i < mdr->numTags ; i++)
 	{
 		tag->boneIndex = LittleLong(curtag->boneIndex);
@@ -690,7 +739,7 @@
 		curtag++;
 	}
 	
-	// And finally we know the offset to the end.
+	// And finally we know the real offset to the end.
 	mdr->ofsEnd = (int)((byte *) tag - (byte *) mdr);
 
 	// phew! we're done.
@@ -875,7 +924,7 @@
 	// NOTE: this sucks, for some reason the first stretch pic is never drawn
 	// without this we'd see a white flash on a level load because the very
 	// first time the level shot would not be drawn
-	RE_StretchPic(0, 0, 0, 0, 0, 0, 1, 1, 0);
+//	RE_StretchPic(0, 0, 0, 0, 0, 0, 1, 1, 0);
 }
 
 //=============================================================================
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_public.h bumpy-code/code/renderer/tr_public.h
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_public.h	2014-06-09 22:09:45.529844441 -0400
+++ bumpy-code/code/renderer/tr_public.h	2014-06-09 22:14:52.603548668 -0400
@@ -130,7 +130,9 @@
 	void	(*Free)( void *buf );
 
 	cvar_t	*(*Cvar_Get)( const char *name, const char *value, int flags );
+	void	(*Cvar_Alias)( cvar_t *var, const char *var_name );
 	void	(*Cvar_Set)( const char *name, const char *value );
+	void	(*Cvar_CheckRange)( cvar_t *cv, float minVal, float maxVal, qboolean shouldBeIntegral );
 
 	void	(*Cmd_AddCommand)( const char *name, void(*cmd)(void) );
 	void	(*Cmd_RemoveCommand)( const char *name );
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_scene.c bumpy-code/code/renderer/tr_scene.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_scene.c	2014-06-09 22:09:45.529844441 -0400
+++ bumpy-code/code/renderer/tr_scene.c	2014-06-09 22:14:52.603548668 -0400
@@ -208,8 +208,10 @@
 	if ( !tr.registered ) {
 		return;
 	}
-  // https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=402
-	if ( r_numentities >= ENTITYNUM_WORLD ) {
+	if ( r_numentities >= MAX_ENTITIES ) {
+		return;
+	}
+	if ( Q_isnan(ent->origin[0]) || Q_isnan(ent->origin[1]) || Q_isnan(ent->origin[2]) ) {
 		return;
 	}
 	if ( ent->reType < 0 || ent->reType >= RT_MAX_REF_ENTITY_TYPE ) {
@@ -381,15 +383,34 @@
 	// convert to GL's 0-at-the-bottom space
 	//
 	Com_Memset( &parms, 0, sizeof( parms ) );
+	
+	if (tr.refdef.pixelTarget==NULL)
+	{
 	parms.viewportX = tr.refdef.x;
 	parms.viewportY = glConfig.vidHeight - ( tr.refdef.y + tr.refdef.height );
+	}
+	else
+	{
+		//Driver bug, if we try and do pixel target work along the top edge of a window
+		//we can end up capturing part of the status bar. (see screenshot corruption..)
+		//Soooo.. use the middle.
+		parms.viewportX = glConfig.vidWidth / 2;
+		parms.viewportY = glConfig.vidHeight / 2;
+	}
+
 	parms.viewportWidth = tr.refdef.width;
 	parms.viewportHeight = tr.refdef.height;
 	parms.isPortal = qfalse;
 
+	parms.doWater = qfalse;
+	parms.isUnderwater= qfalse;
+	parms.isWater = 0;
+	
 	parms.fovX = tr.refdef.fov_x;
 	parms.fovY = tr.refdef.fov_y;
 
+	parms.stereoFrame = tr.refdef.stereoFrame;
+
 	VectorCopy( fd->vieworg, parms.or.origin );
 	VectorCopy( fd->viewaxis[0], parms.or.axis[0] );
 	VectorCopy( fd->viewaxis[1], parms.or.axis[1] );
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_shade.c bumpy-code/code/renderer/tr_shade.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_shade.c	2014-06-09 22:09:45.530844434 -0400
+++ bumpy-code/code/renderer/tr_shade.c	2014-06-09 22:14:52.608548631 -0400
@@ -278,6 +278,52 @@
 }
 
 
+static void DrawStaticTris (shaderCommands_t *input) 
+{
+	int j;
+	int col;
+	int uniform_location;
+	vec3_t tint;
+	srfSurfaceStatic_t *srf;
+
+	RB_SetupFragment(&tr.fragshader[FS_WIREFRAME],NULL);
+
+	GL_SelectTexture(0);
+	GL_Bind( tr.whiteImage);
+	//GL_SelectTexture(1);
+	//GL_Bind( tr.whiteImage );
+	//qglDisable( GL_TEXTURE_2D );
+	
+
+	qglDisableClientState (GL_COLOR_ARRAY);
+	qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
+
+		
+ 	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
+	qglDepthRange( 0, 0 );
+
+	for (j=0;j<tess.numStaticSurfs;j++)
+	{
+		srf=tess.StaticSurfs[j];		
+		
+		//multicolor wireframe fun
+		col=srf->shader->stages[0]->bundle[0].image[0]->texnum % 6;
+		if (col==0) VectorSet(tint,0.5f  ,0.5f ,1);		
+		if (col==1) VectorSet(tint,0.5f  ,1    ,0.5f);	
+		if (col==2) VectorSet(tint,1     ,0.5f ,0.5f);	
+		if (col==3) VectorSet(tint,0.5f ,0.0 ,0);		
+		if (col==4) VectorSet(tint,0.5f  ,  0  ,0.5f);	
+		if (col==5) VectorSet(tint,0     ,0.0, 0.5f);	
+
+		uniform_location = qglGetUniformLocationARB(tr.fragshader[FS_WIREFRAME].program, "tint");
+		if (uniform_location>-1) qglUniform3fARB(uniform_location,tint[0],tint[1],tint[2]);
+
+		qglDrawElements(GL_TRIANGLES, srf->numIndices , GL_UNSIGNED_INT,  GEOMETRY_INDEX_OFFSET(srf->startIndex)  );
+	}
+
+	qglDepthRange( 0, 1 );
+}
+
 /*
 ================
 DrawNormals
@@ -318,6 +364,7 @@
 
 	shader_t *state = (shader->remappedShader) ? shader->remappedShader : shader;
 
+	tess.numStaticSurfs=0;
 	tess.numIndexes = 0;
 	tess.numVertexes = 0;
 	tess.shader = state;
@@ -455,9 +500,19 @@
 		radius = dl->radius;
 		scale = 1.0f / radius;
 
+		if(r_greyscale->integer)
+		{
+			float luminance;
+			
+			luminance = (dl->color[0] * 255.0f + dl->color[1] * 255.0f + dl->color[2] * 255.0f) / 3;
+			floatColor[0] = floatColor[1] = floatColor[2] = luminance;
+		}
+		else
+		{
 		floatColor[0] = dl->color[0] * 255.0f;
 		floatColor[1] = dl->color[1] * 255.0f;
 		floatColor[2] = dl->color[2] * 255.0f;
+		}
 		floatColorVec0 = vec_ld(0, floatColor);
 		floatColorVec1 = vec_ld(11, floatColor);
 		floatColorVec0 = vec_perm(floatColorVec0,floatColorVec0,floatColorVecPerm);
@@ -599,9 +654,20 @@
 		radius = dl->radius;
 		scale = 1.0f / radius;
 
+		if(r_greyscale->integer)
+		{
+			float luminance;
+			
+			luminance = (dl->color[0] * 255.0f + dl->color[1] * 255.0f + dl->color[2] * 255.0f) / 3;
+			floatColor[0] = floatColor[1] = floatColor[2] = luminance;
+		}
+		else
+		{
 		floatColor[0] = dl->color[0] * 255.0f;
 		floatColor[1] = dl->color[1] * 255.0f;
 		floatColor[2] = dl->color[2] * 255.0f;
+		}
+
 		for ( i = 0 ; i < tess.numVertexes ; i++, texCoords += 2, colors += 4 ) {
 			int		clip = 0;
 			vec3_t	dist;
@@ -938,6 +1004,18 @@
 			break;
 		}
 	}
+	
+	// if in greyscale rendering mode turn all color values into greyscale.
+	if(r_greyscale->integer)
+	{
+		int scale;
+		
+		for(i = 0; i < tess.numVertexes; i++)
+		{
+			scale = (tess.svars.colors[i][0] + tess.svars.colors[i][1] + tess.svars.colors[i][2]) / 3;
+			tess.svars.colors[i][0] = tess.svars.colors[i][1] = tess.svars.colors[i][2] = scale;
+		}
+	}
 }
 
 /*
@@ -1301,7 +1379,8 @@
 
 //define	REPLACE_MODE
 
-void RB_StageIteratorLightmappedMultitexture( void ) {
+void RB_StageIteratorLightmappedMultitexture( void )
+{
 	shaderCommands_t *input;
 
 	input = &tess;
@@ -1401,6 +1480,588 @@
 		qglUnlockArraysEXT();
 		GLimp_LogComment( "glUnlockArraysEXT\n" );
 	}
+	
+}
+
+
+
+void RB_StageIteratorCheapFancyWater_GLSL( void ) 
+{
+	shaderCommands_t *input;
+	srfSurfaceStatic_t *srf;
+	int j;
+	int diffuse,normal,bump,cube;
+
+	input = &tess;
+	
+	//call the program
+	RB_SetupFragment(tess.shader->stages[0]->program,tess.shader);
+	
+	//
+	// log this call
+	//
+	if ( r_logFile->integer ) {
+		// don't just call LogComment, or we will get
+		// a call to va() every frame!
+		GLimp_LogComment( va("--- RB_StageIteratorCheapFancyWater_GLSL( %s ) ---\n", tess.shader->name) );
+	}
+
+	//
+	// set face culling appropriately
+	//
+	GL_Cull( input->shader->cullType );
+
+
+	GL_State( GLS_DEFAULT );	
+
+	GL_State( input->shader->stages[0]->stateBits);
+	//Todo: get vertex colors encoded
+	//		although I cant recall any maps actually using these still
+	
+	qglColor3f (1,1,1);
+
+	//Diffuse 
+	diffuse=tess.xstages[0]->bundle[0].image[0]->texnum;
+	if (tess.xstages[0]->normalmap!=NULL)
+	{
+		normal= tess.xstages[0]->normalmap->texnum;
+	}
+	else
+	{
+		normal=tr.normalImage->texnum;
+	}
+	//bump/offset map
+	if (tess.xstages[0]->bumpmap!=NULL)
+	{
+		bump=  tess.xstages[0]->bumpmap->texnum;
+	}
+	else
+	{
+		bump=tr.greyImage->texnum;
+	}
+
+	for (j=0;j<tess.numStaticSurfs;j++)
+	{
+		srf=tess.StaticSurfs[j];		
+		//cubemap
+	
+		if (tr.refdef.rdflags & RDF_NOCUBEMAP ||  !srf->cubemap || normal==tr.normalImage->texnum)
+		{
+			cube= tr.blackCubeImage->texnum;
+		}
+		else
+		{
+			cube= srf->cubemap->texnum;
+		}
+		RB_BindFragmentTextures(glState.currentFragShader,diffuse,normal,bump ,0,0,0,cube,0);
+
+
+// srf->numIndices
+		{
+		
+
+
+		qglDrawElements(GL_TRIANGLES, srf->numIndices, GL_UNSIGNED_INT, GEOMETRY_INDEX_OFFSET(srf->startIndex));
+		}
+	}
+
+
+
+
+}
+
+void RB_SetVertexRGB_GLSL(	shaderStage_t	*pStage)
+{
+	vec3_t forceColor={1,1,1};
+	float forceAlpha=0;
+	float RGBMode=0;
+	float AlphaMode=0;
+	int uniform_location;
+	//Bind the correct vertex colors
+	switch (pStage->rgbGen)
+	{
+		case CGEN_IDENTITY:
+			//Com_Memset( tess.svars.colors, 0xff, tess.numVertexes * 4 );
+			VectorSet(forceColor,1,1,1);
+			RGBMode=0;
+			break;
+		default:
+		case CGEN_IDENTITY_LIGHTING:
+			
+			VectorSet(forceColor,tr.identityLight,tr.identityLight,tr.identityLight);
+			RGBMode=0;
+			break;
+		case CGEN_LIGHTING_DIFFUSE:
+			
+			RGBMode=1;
+			break;
+		case CGEN_EXACT_VERTEX:
+			
+			RGBMode=1;
+			break;
+		case CGEN_CONST:
+			
+			VectorSet(forceColor,pStage->constantColor[0]/255.0f,pStage->constantColor[1]/255.0f,pStage->constantColor[2]/255.0f);
+			RGBMode=0;
+			break;
+		case CGEN_VERTEX:
+			RGBMode=1;			
+			
+			break;
+		case CGEN_ONE_MINUS_VERTEX:
+			RGBMode=2;
+			break;
+		case CGEN_WAVEFORM:
+			RGBMode=1; //wrong/todo
+			break;
+	
+	}
+
+	
+	uniform_location = qglGetUniformLocationARB(pStage->program->program, "rgbmode");
+	if (uniform_location>-1) qglUniform1fARB(uniform_location,RGBMode);
+	uniform_location = qglGetUniformLocationARB(pStage->program->program, "alphamode");
+	if (uniform_location>-1) qglUniform1fARB(uniform_location,AlphaMode);
+	uniform_location = qglGetUniformLocationARB(pStage->program->program, "rgbcolor");
+	if (uniform_location>-1) qglUniform4fARB(uniform_location,forceColor[0],forceColor[1],forceColor[2],forceAlpha);
+
+}
+
+void RB_StageIteratorLightmappedMultitexture_GLSL( void ) 
+{
+	shaderCommands_t *input;
+	srfSurfaceStatic_t *srf;
+	int j;
+	int diffuse,normal,bump,cube;
+	shaderStage_t	*pStage;
+	int		i;
+	deformStage_t	*ds;
+	int uniform_location;
+	fragShader_t* frag;
+
+
+	input = &tess;
+	
+	frag=tess.shader->stages[0]->program;
+	pStage=tess.shader->stages[0];
+	//call the program
+	RB_SetupFragment(pStage->program,tess.shader);
+	
+
+	if (strstr(tess.shader->name,"textures/lundesert/grass1"))
+	{
+		input = &tess;
+	}
+	//
+	// log this call
+	//
+	if ( r_logFile->integer ) {
+		// don't just call LogComment, or we will get
+		// a call to va() every frame!
+		GLimp_LogComment( va("--- RB_StageIteratorLightmappedMultitexture_GLSL( %s ) ---\n", tess.shader->name) );
+	}
+
+	//
+	// set face culling appropriately
+	GL_Cull( input->shader->cullType );
+
+	// set polygon offset if necessary
+	if ( input->shader->polygonOffset )
+	{
+		qglEnable( GL_POLYGON_OFFSET_FILL );
+		qglPolygonOffset( r_offsetFactor->value, r_offsetUnits->value );
+	}
+
+
+
+	GL_State( GLS_DEFAULT );	
+
+	GL_State(  pStage->stateBits);
+	
+	qglColor3f (1,1,1);
+
+	//Diffuse 
+	diffuse=tess.xstages[0]->bundle[0].image[0]->texnum;
+	if (tess.xstages[0]->normalmap!=NULL)
+	{
+		normal= tess.xstages[0]->normalmap->texnum;
+	}
+	else
+	{
+		normal=tr.normalImage->texnum;
+	}
+	//bump/offset map
+	if (tess.xstages[0]->bumpmap!=NULL)
+	{
+		bump=  tess.xstages[0]->bumpmap->texnum;
+	}
+	else
+	{
+		bump=tr.greyImage->texnum;
+	}
+
+	RB_SetVertexRGB_GLSL(pStage);
+
+	
+	
+	for ( i = 0 ; i < tess.shader->numDeforms ; i++ ) 
+	{
+		ds = &tess.shader->deforms[ i ];
+
+		switch ( ds->deformation ) 
+		{
+			case DEFORM_WAVE:
+			//RB_CalcDeformVertexes( ds );
+				uniform_location = qglGetUniformLocationARB(frag->program, "IN_deformtype");
+				if (uniform_location>-1) qglUniform1fARB(uniform_location, ds->deformationWave.func );
+				uniform_location = qglGetUniformLocationARB(frag->program, "IN_deformationSpread");
+				if (uniform_location>-1) qglUniform1fARB(uniform_location, ds->deformationSpread);
+				uniform_location = qglGetUniformLocationARB(frag->program, "IN_phase");
+				if (uniform_location>-1) qglUniform1fARB(uniform_location, ds->deformationWave.phase);
+				uniform_location = qglGetUniformLocationARB(frag->program, "IN_frequency");
+				if (uniform_location>-1) qglUniform1fARB(uniform_location, ds->deformationWave.frequency );
+				uniform_location = qglGetUniformLocationARB(frag->program, "IN_amplitude");
+				if (uniform_location>-1) qglUniform1fARB(uniform_location, ds->deformationWave.amplitude );
+				uniform_location = qglGetUniformLocationARB(frag->program, "IN_base");
+				if (uniform_location>-1) qglUniform1fARB(uniform_location, ds->deformationWave.base );
+
+			break;
+			case DEFORM_BULGE:
+		//		RB_CalcBulgeVertexes( ds );
+			break;
+			case DEFORM_MOVE:
+			//	RB_CalcMoveVertexes( ds );
+			break;
+		}
+	}
+
+	for (j=0;j<tess.numStaticSurfs;j++)
+	{
+		srf=tess.StaticSurfs[j];		
+		//cubemap
+	
+		if (tr.refdef.rdflags & RDF_NOCUBEMAP ||  !srf->cubemap || normal==tr.normalImage->texnum)
+		{
+			cube= tr.blackCubeImage->texnum;
+		}
+		else
+		{
+			cube= srf->cubemap->texnum;
+		}
+		RB_BindFragmentTextures(glState.currentFragShader,diffuse,normal,bump ,0,0,0,cube,0);
+
+		qglDrawElements(GL_TRIANGLES, srf->numIndices , GL_UNSIGNED_INT,  GEOMETRY_INDEX_OFFSET(srf->startIndex)  );
+	}
+
+	
+	if ( input->shader->polygonOffset )
+	{
+		qglDisable( GL_POLYGON_OFFSET_FILL );
+	}
+	uniform_location = qglGetUniformLocationARB(frag->program, "IN_deformtype");
+	if (uniform_location>-1) qglUniform1fARB(uniform_location, 0);
+}
+
+
+void RB_StageIteratorLightmappedTerrain_GLSL( void ) 
+{
+	shaderCommands_t *input;
+	srfSurfaceStatic_t *srf;
+	int j;
+	int diffuse,normal,bump,cube;
+	int diffuse1,normal1,bump1;
+
+	input = &tess;
+	
+	//call the program
+	RB_SetupFragment(tess.shader->stages[0]->program,tess.shader);
+	
+	//
+	// log this call
+	//
+	if ( r_logFile->integer ) {
+		// don't just call LogComment, or we will get
+		// a call to va() every frame!
+		GLimp_LogComment( va("--- RB_StageIteratorLightmappedMultitexture_GLSL( %s ) ---\n", tess.shader->name) );
+	}
+
+	//
+	// set face culling appropriately
+	//
+	//
+	// set face culling appropriately
+	//
+	GL_Cull( input->shader->cullType );
+
+	// set polygon offset if necessary
+	if ( input->shader->polygonOffset )
+	{
+		qglEnable( GL_POLYGON_OFFSET_FILL );
+		qglPolygonOffset( r_offsetFactor->value, r_offsetUnits->value );
+	}
+
+
+
+	GL_State( GLS_DEFAULT );	
+
+	//Todo: get vertex colors encoded
+	//		although I cant recall any maps actually using these still
+	
+	qglColor3f (1,1,1);
+
+	//Diffuse 
+	diffuse=tess.xstages[0]->bundle[0].image[0]->texnum;
+	if (tess.xstages[0]->normalmap!=NULL)
+	{
+		normal= tess.xstages[0]->normalmap->texnum;
+	}
+	else
+	{
+		normal=tr.normalImage->texnum;
+	}
+	//bump/offset map
+	if (tess.xstages[0]->bumpmap!=NULL)
+	{
+		bump=  tess.xstages[0]->bumpmap->texnum;
+	}
+	else
+	{
+		bump=tr.greyImage->texnum;
+	}
+
+	//Diffuse 
+	diffuse1=tess.xstages[1]->bundle[0].image[0]->texnum;
+	if (tess.xstages[1]->normalmap!=NULL)
+	{
+		normal1= tess.xstages[1]->normalmap->texnum;
+	}
+	else
+	{
+		normal1=tr.normalImage->texnum;
+	}
+	//bump/offset map
+	if (tess.xstages[1]->bumpmap!=NULL)
+	{
+		bump1=  tess.xstages[1]->bumpmap->texnum;
+	}
+	else
+	{
+		bump1=tr.greyImage->texnum;
+	}
+
+	for (j=0;j<tess.numStaticSurfs;j++)
+	{
+		srf=tess.StaticSurfs[j];		
+		//cubemap
+	
+		if (tr.refdef.rdflags & RDF_NOCUBEMAP ||  !srf->cubemap || normal==tr.normalImage->texnum)
+		{
+			cube= tr.blackCubeImage->texnum;
+		}
+		else
+		{
+			cube= srf->cubemap->texnum;
+		}
+		RB_BindFragmentTextures(glState.currentFragShader,diffuse,normal,bump ,diffuse1,normal1,bump1,cube,0);
+
+
+
+		qglDrawElements(GL_TRIANGLES, srf->numIndices , GL_UNSIGNED_INT,  GEOMETRY_INDEX_OFFSET(srf->startIndex)  );
+	}
+
+	
+
+		
+}
+
+
+
+
+void RB_StageIteratorWater_GLSL( void ) {
+	shaderCommands_t *input;
+	srfSurfaceStatic_t *srf;
+	int j;
+
+	input = &tess;
+
+	//return;
+	//
+	// log this call
+	//
+	if ( r_logFile->integer ) {
+		// don't just call LogComment, or we will get
+		// a call to va() every frame!
+		GLimp_LogComment( va("--- RB_StageIteratorWater( %s ) ---\n", tess.shader->name) );
+	}
+
+	if (!(backEnd.viewParms.doWater && backEnd.viewParms.isWater==0)) return;
+	
+	//
+	// set face culling appropriately
+	//
+	GL_Cull( input->shader->cullType );
+
+	GL_State( GLS_DEFAULT );	
+	RB_SetupFragment(&tr.fragshader[FS_WATER],tess.shader);
+
+	qglColor3f (1,1,1);
+//			GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE  );
+	RB_BindFragmentTextures(&tr.fragshader[FS_WATER],0,tr.waterImage->texnum,0,0,0,0,0,0);
+
+	for (j=0;j<tess.numStaticSurfs;j++)
+	{
+		srf=tess.StaticSurfs[j];		
+		qglDrawElements(GL_TRIANGLES, srf->numIndices , GL_UNSIGNED_INT,  GEOMETRY_INDEX_OFFSET(srf->startIndex)  );
+	}
+
+}
+
+
+void RB_BindFragmentTextures(fragShader_t *frag,int diffuse0,	int normal0,    int bump0,
+												int diffuse1,	int normal1,	int bump1,
+												int cubemapA,int cubemapB)
+{
+
+	int texnum=0;
+
+	/*int diffuse0;
+	int normal0;
+	int bump0;
+	int diffuse1;
+	int normal1;
+	int bump1;
+	int lightmap0;
+	int radbump0;
+	int radbump1;
+	int radbump2;
+	int cubemap;
+	int reflectmap;
+	int refractmap;
+	int scenetexture;*/
+
+	if (frag->diffuse0!=-1) 
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_2D );
+		
+		if (r_glsl_debug->integer>0)
+		{
+			GL_BindTexnum(tr.greenImage->texnum);
+		}
+		else
+		{
+			GL_BindTexnum(diffuse0);
+		}
+	}
+	if (frag->normal0!=-1) 
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_2D );
+		GL_BindTexnum(normal0);
+	}
+	if (frag->bump0!=-1) 
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_2D );
+		GL_BindTexnum(bump0);
+	}
+
+
+	if (frag->diffuse1!=-1) 
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_2D );
+		
+		if (r_glsl_debug->integer>0)
+		{
+			GL_BindTexnum(tr.greenImage->texnum);
+		}
+		else
+		{
+			GL_BindTexnum(diffuse1);
+		}
+
+	}
+	if (frag->normal1!=-1) 
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_2D );
+		GL_BindTexnum(normal1);
+	}
+	if (frag->bump1!=-1) 
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_2D );
+		GL_BindTexnum(bump1);
+	}
+
+	if (frag->lightmap0!=-1) 
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_2D );
+		
+		if (tess.shader->whiteLightmap==qtrue)
+		{
+			GL_BindTexnum(tr.whiteImage->texnum);
+		}
+		else
+		{
+			GL_BindTexnum(tr.fatlightmap->texnum);
+		}
+	}
+	
+	
+	if (frag->radbump0!=-1) 
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_2D );
+		GL_BindTexnum(tr.radbump[0]->texnum);
+	}
+	if (frag->radbump1!=-1) 
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_2D );
+		GL_BindTexnum(tr.radbump[1]->texnum);
+	}
+	if (frag->radbump2!=-1) 
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_2D );
+		GL_BindTexnum(tr.radbump[2]->texnum);
+	}
+	if (frag->specbump!=-1) 
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_2D );
+		GL_BindTexnum(tr.radbump[3]->texnum);
+	}
+
+	if (frag->cubemap!=-1)
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_CUBE_MAP );
+		GL_BindCubeTexnum(cubemapA);
+	}
+	if (frag->cubemap2!=-1)
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_CUBE_MAP );
+		GL_BindCubeTexnum(cubemapB);
+	}
+
+	if (frag->reflectmap!=-1)
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_2D );
+		GL_BindTexnum(tr.reflectionTexnum);
+	}
+	if (frag->refractmap!=-1)
+	{
+		GL_SelectTexture(texnum++);
+		qglEnable( GL_TEXTURE_2D );
+		GL_BindTexnum(tr.underwaterTexnum);
+	}
+
 }
 
 /*
@@ -1411,7 +2072,8 @@
 
 	input = &tess;
 
-	if (input->numIndexes == 0) {
+	//27 New static surface stuff
+	if (input->numIndexes == 0 && tess.numStaticSurfs==0) {
 		return;
 	}
 
@@ -1440,23 +2102,44 @@
 	backEnd.pc.c_indexes += tess.numIndexes;
 	backEnd.pc.c_totalIndexes += tess.numIndexes * tess.numPasses;
 
+	//Vbo on or off?
+
+	if (tess.numStaticSurfs==0)
+	{
+		RB_SetupFragment(NULL,tess.shader);
+	}
+		
 	//
 	// call off to shader specific tess end function
 	//
+	//Actual drawing!
 	tess.currentStageIteratorFunc();
 
 	//
 	// draw debugging stuff
 	//
+	if(tess.numStaticSurfs==0)
+	{
 	if ( r_showtris->integer ) {
 		DrawTris (input);
 	}
 	if ( r_shownormals->integer ) {
 		DrawNormals (input);
 	}
+	}
+	else
+	{
+		//Vbo version
+		if ( r_showtris->integer ) {
+			DrawStaticTris (input);
+		}
+	
+	}
 	// clear shader so we can tell we don't have any unclosed surfaces
 	tess.numIndexes = 0;
 
+	tess.numStaticSurfs=0;
+
 	GLimp_LogComment( "----------\n" );
 }
 
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_shader.c bumpy-code/code/renderer/tr_shader.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_shader.c	2014-06-09 22:09:45.530844434 -0400
+++ bumpy-code/code/renderer/tr_shader.c	2014-06-09 22:14:52.608548631 -0400
@@ -66,6 +68,32 @@
 	return hash;
 }
 
+//Old one was getting collisions
+static long generateShaderHash( const char *fname )
+{
+	int		i;
+	long	hash;
+	char	letter;
+
+	int bitoffset=0;
+	hash = 0;
+	i = 0;
+	while (fname[i] != '\0') 
+	{
+		letter = tolower(fname[i]);
+		if (letter =='.') break;				// don't include extension
+		if (letter =='\\') letter = '/';		// damn path names
+		if (letter == PATH_SEP) letter = '/';		// damn path names
+		hash= hash ^ (long)(letter<<bitoffset);
+		bitoffset+=8;
+		if (bitoffset>32*8) bitoffset=0;
+		i++;
+	}
+	//hash = (hash ^ (hash >> 10) ^ (hash >> 20));
+	//hash &= (size-1);
+	return hash;
+}
+
 void R_RemapShader(const char *shaderName, const char *newShaderName, const char *timeOffset) {
 	char		strippedName[MAX_QPATH];
 	int			hash;
@@ -628,16 +656,26 @@
 			else if ( !Q_stricmp( token, "$lightmap" ) )
 			{
 				stage->bundle[0].isLightmap = qtrue;
-				if ( shader.lightmapIndex < 0 ) {
+				//27 fix: a stage with SURF_NOLIGHTMAP shouldn't be referencing $lightmap
+				if ( shader.lightmapIndex < 0 || shader.surfaceFlags & SURF_NOLIGHTMAP )
+				{
 					stage->bundle[0].image[0] = tr.whiteImage;
-				} else {
-					stage->bundle[0].image[0] = tr.lightmaps[shader.lightmapIndex];
+					if ( shader.lightmapIndex >=0 && shader.surfaceFlags & SURF_NOLIGHTMAP )
+					{
+						ri.Printf( PRINT_WARNING, "WARNING: conflicting use of NOLIGHTMAP and a $LIGHTMAP stage in shader '%s'\n", shader.name );
+					}
+					
+				
+				} else
+				{
+					
+					stage->bundle[0].image[0] = tr.fatlightmap; //tr.lightmaps[shader.lightmapIndex];
 				}
 				continue;
 			}
 			else
 			{
-				stage->bundle[0].image[0] = R_FindImageFile( token, !shader.noMipMaps, !shader.noPicMip, GL_REPEAT );
+				stage->bundle[0].image[0] = R_FindImageFile( token, !shader.noMipMaps, !shader.noPicMip, GL_REPEAT, qfalse,qfalse,qfalse );
 				if ( !stage->bundle[0].image[0] )
 				{
 					ri.Printf( PRINT_WARNING, "WARNING: R_FindImageFile could not find '%s' in shader '%s'\n", token, shader.name );
@@ -657,7 +695,7 @@
 				return qfalse;
 			}
 
-			stage->bundle[0].image[0] = R_FindImageFile( token, !shader.noMipMaps, !shader.noPicMip, GL_CLAMP );
+			stage->bundle[0].image[0] = R_FindImageFile( token, !shader.noMipMaps, !shader.noPicMip, GL_CLAMP_TO_EDGE, qfalse,qfalse,qfalse );
 			if ( !stage->bundle[0].image[0] )
 			{
 				ri.Printf( PRINT_WARNING, "WARNING: R_FindImageFile could not find '%s' in shader '%s'\n", token, shader.name );
@@ -687,7 +725,7 @@
 				}
 				num = stage->bundle[0].numImageAnimations;
 				if ( num < MAX_IMAGE_ANIMATIONS ) {
-					stage->bundle[0].image[num] = R_FindImageFile( token, !shader.noMipMaps, !shader.noPicMip, GL_REPEAT );
+					stage->bundle[0].image[num] = R_FindImageFile( token, !shader.noMipMaps, !shader.noPicMip, GL_REPEAT, qfalse,qfalse,qfalse );
 					if ( !stage->bundle[0].image[num] )
 					{
 						ri.Printf( PRINT_WARNING, "WARNING: R_FindImageFile could not find '%s' in shader '%s'\n", token, shader.name );
@@ -834,6 +872,9 @@
 			}
 			else if ( !Q_stricmp( token, "identityLighting" ) )
 			{
+				if ( r_overBrightBits->integer == 0 )
+					stage->rgbGen = CGEN_IDENTITY;
+				else
 				stage->rgbGen = CGEN_IDENTITY_LIGHTING;
 			}
 			else if ( !Q_stricmp( token, "entity" ) )
@@ -1009,6 +1050,35 @@
 		}
 	}
 
+	// I assume DST_ALPHA is always 1, so I just replace it with GL_ONE
+	if ( blendSrcBits == GLS_SRCBLEND_DST_ALPHA )
+		blendSrcBits = GLS_SRCBLEND_ONE;
+	else if ( blendSrcBits == GLS_SRCBLEND_ONE_MINUS_DST_ALPHA )
+		blendSrcBits = GLS_SRCBLEND_ZERO;
+
+	if ( blendDstBits == GLS_DSTBLEND_DST_ALPHA )
+		blendDstBits = GLS_DSTBLEND_ONE;
+	else if ( blendDstBits == GLS_DSTBLEND_ONE_MINUS_DST_ALPHA )
+		blendDstBits = GLS_DSTBLEND_ZERO;
+
+	// If the image has no (real) alpha channel, we can do the same
+	// for SRC_ALPHA
+	if ( !stage->bundle[0].image[0]->hasAlpha &&
+	     stage->alphaGen == AGEN_IDENTITY) {
+		if ( blendSrcBits == GLS_SRCBLEND_SRC_ALPHA )
+			blendSrcBits = GLS_SRCBLEND_ONE;
+		else if ( blendSrcBits == GLS_SRCBLEND_ONE_MINUS_SRC_ALPHA )
+			blendSrcBits = GLS_SRCBLEND_ZERO;
+		
+		if ( blendDstBits == GLS_DSTBLEND_SRC_ALPHA )
+			blendDstBits = GLS_DSTBLEND_ONE;
+		else if ( blendDstBits == GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA )
+			blendDstBits = GLS_DSTBLEND_ZERO;
+
+		// also alphaFunc makes no sense without alpha
+		atestBits = 0;
+	}
+
 	//
 	// if cgen isn't explicitly specified, use either identity or identitylighting
 	//
@@ -1016,7 +1086,7 @@
 		if ( blendSrcBits == 0 ||
 			blendSrcBits == GLS_SRCBLEND_ONE || 
 			blendSrcBits == GLS_SRCBLEND_SRC_ALPHA ) {
-			stage->rgbGen = CGEN_IDENTITY_LIGHTING;
+			stage->rgbGen = CGEN_IDENTITY; // CGEN_IDENTITY_LIGHTING // Why? White is better and lets us optimize later
 		} else {
 			stage->rgbGen = CGEN_IDENTITY;
 		}
@@ -1034,7 +1104,7 @@
 	}
 
 	// decide which agens we can skip
-	if ( stage->alphaGen == AGEN_IDENTITY ) { //@Barbatos bugfix - previously CGEN_IDENTITY
+	if ( stage->alphaGen == AGEN_IDENTITY ) {
 		if ( stage->rgbGen == CGEN_IDENTITY
 			|| stage->rgbGen == CGEN_LIGHTING_DIFFUSE ) {
 			stage->alphaGen = AGEN_SKIP;
@@ -1230,11 +1300,8 @@
 		for (i=0 ; i<6 ; i++) {
 			Com_sprintf( pathname, sizeof(pathname), "%s_%s.tga"
 				, token, suf[i] );
-#ifdef GL_CLAMP_TO_EDGE
-			shader.sky.outerbox[i] = R_FindImageFile( ( char * ) pathname, qtrue, qtrue, GL_CLAMP_TO_EDGE );
-#else
-			shader.sky.outerbox[i] = R_FindImageFile( ( char * ) pathname, qtrue, qtrue, GL_CLAMP );
-#endif
+			shader.sky.outerbox[i] = R_FindImageFile( ( char * ) pathname, qtrue, qtrue, GL_CLAMP_TO_EDGE, qfalse,qfalse,qfalse );
+
 			if ( !shader.sky.outerbox[i] ) {
 				shader.sky.outerbox[i] = tr.defaultImage;
 			}
@@ -1264,7 +1331,7 @@
 		for (i=0 ; i<6 ; i++) {
 			Com_sprintf( pathname, sizeof(pathname), "%s_%s.tga"
 				, token, suf[i] );
-			shader.sky.innerbox[i] = R_FindImageFile( ( char * ) pathname, qtrue, qtrue, GL_REPEAT );
+			shader.sky.innerbox[i] = R_FindImageFile( ( char * ) pathname, qtrue, qtrue, GL_REPEAT, qfalse,qfalse,qfalse );
 			if ( !shader.sky.innerbox[i] ) {
 				shader.sky.innerbox[i] = tr.defaultImage;
 			}
@@ -1432,7 +1499,6 @@
 		// stage definition
 		else if ( token[0] == '{' )
 		{
-			// 20051019 misantropia -- fix buffer overrun.
 			if ( s >= MAX_SHADER_STAGES ) {
 				ri.Printf( PRINT_WARNING, "WARNING: too many stages in shader %s\n", shader.name );
 				return qfalse;
@@ -1481,6 +1547,48 @@
 			tr.sunDirection[1] = sin( a ) * cos( b );
 			tr.sunDirection[2] = sin( b );
 		}
+				
+		// fancy water
+		else if ( !Q_stricmp( token, "q3map_fancywater" ) )
+		{
+			token = COM_ParseExt( text, qfalse );
+			shader.scale = atof( token );
+		
+			token = COM_ParseExt( text, qfalse );
+			shader.tint[0] = atof( token );
+			token = COM_ParseExt( text, qfalse );
+			shader.tint[1] = atof( token );
+			token = COM_ParseExt( text, qfalse );
+			shader.tint[2] = atof( token );
+			
+			shader.isFancyWater = 1;
+
+			ri.Printf( PRINT_DEVELOPER, "Loaded shader %s with fancy water...\n", shader.name );
+		}
+		// fancy water - cheap
+		else if ( !Q_stricmp( token, "q3map_cheapwater" )  )
+		{
+			token = COM_ParseExt( text, qfalse );
+			shader.scale = atof( token );
+
+			token = COM_ParseExt( text, qfalse );
+			shader.tint[0] = atof( token );
+			token = COM_ParseExt( text, qfalse );
+			shader.tint[1] = atof( token );
+			token = COM_ParseExt( text, qfalse );
+			shader.tint[2] = atof( token );
+			
+			shader.isFancyWater = 2;
+
+			ri.Printf( PRINT_DEVELOPER, "Loaded shader %s with cheap fancy water...\n", shader.name );
+		}
+		else if ( !Q_stricmp( token, "q3map_nofancywater" ) )
+		{
+			if (r_fancywater->integer)
+			{
+				shader.noFancyWater=qtrue;
+			}
+		}
 		else if ( !Q_stricmp( token, "deformVertexes" ) ) {
 			ParseDeform( text );
 			continue;
@@ -1648,10 +1756,7 @@
 		goto done;
 	}
 
-	if ( r_ignoreFastPath->integer )
-	{
-		return;
-	}
+	
 
 	//
 	// see if this can go into the vertex lit fast path
@@ -1660,7 +1765,7 @@
 	{
 		if ( stages[0].rgbGen == CGEN_LIGHTING_DIFFUSE )
 		{
-			if ( stages[0].alphaGen == AGEN_IDENTITY )
+			if ( stages[0].alphaGen == AGEN_IDENTITY  ||  stages[0].alphaGen == AGEN_VERTEX )
 			{
 				if ( stages[0].bundle[0].tcGen == TCGEN_TEXTURE )
 				{
@@ -1683,22 +1788,24 @@
 	//
 	// see if this can go into an optimized LM, multitextured path
 	//
+
 	if ( shader.numUnfoggedPasses == 1 )
 	{
-		if ( ( stages[0].rgbGen == CGEN_IDENTITY ) && ( stages[0].alphaGen == AGEN_IDENTITY ) )
+	
+	//	if ( ( stages[0].rgbGen == CGEN_IDENTITY_LIGHTING ) && ( stages[0].alphaGen == AGEN_IDENTITY ) )
+		
 		{
 			if ( stages[0].bundle[0].tcGen == TCGEN_TEXTURE && 
 				stages[0].bundle[1].tcGen == TCGEN_LIGHTMAP )
 			{
-				if ( !shader.polygonOffset )
+				if ( !shader.polygonOffset && stages[0].bundle[1].image[0]==tr.fatlightmap ) //Fix for when custom lightstyles are used.
 				{
 					if ( !shader.numDeforms )
 					{
-						if ( shader.multitextureEnv )
-						{
 							shader.optimalStageIteratorFunc = RB_StageIteratorLightmappedMultitexture;
+						
 							goto done;
-						}
+						
 					}
 				}
 			}
@@ -1828,9 +1935,7 @@
 			return qfalse;
 		}
 	}
-
-	//@Fenix - bugfix (previously was CGEN_WAVEFORM )
-	if ( stages[0].alphaGen == AGEN_WAVEFORM  )
+	if ( stages[0].alphaGen == CGEN_WAVEFORM )
 	{
 		if ( memcmp( &stages[0].alphaWave,
 					 &stages[1].alphaWave,
@@ -1981,7 +2087,8 @@
 GeneratePermanentShader
 ====================
 */
-static shader_t *GeneratePermanentShader( void ) {
+static shader_t *GeneratePermanentShader(shader_t *sourceshader ) 
+{
 	shader_t	*newShader;
 	int			i, b;
 	int			size, hash;
@@ -1993,11 +2100,11 @@
 
 	newShader = ri.Hunk_Alloc( sizeof( shader_t ), h_low );
 
-	*newShader = shader;
+	*newShader = *sourceshader;
 
-	if ( shader.sort <= SS_OPAQUE ) {
+	if ( sourceshader->sort <= SS_OPAQUE ) {
 		newShader->fogPass = FP_EQUAL;
-	} else if ( shader.contentFlags & CONTENTS_FOG ) {
+	} else if ( sourceshader->contentFlags & CONTENTS_FOG ) {
 		newShader->fogPass = FP_LE;
 	}
 
@@ -2009,19 +2116,45 @@
 
 	tr.numShaders++;
 
-	for ( i = 0 ; i < newShader->numUnfoggedPasses ; i++ ) {
+	if (sourceshader==&shader)
+	{
+		//copy from the global variables
+		for ( i = 0 ; i < newShader->numUnfoggedPasses ; i++ ) 
+		{
 		if ( !stages[i].active ) {
 			break;
 		}
 		newShader->stages[i] = ri.Hunk_Alloc( sizeof( stages[i] ), h_low );
 		*newShader->stages[i] = stages[i];
 
-		for ( b = 0 ; b < NUM_TEXTURE_BUNDLES ; b++ ) {
+			for ( b = 0 ; b < NUM_TEXTURE_BUNDLES ; b++ ) 
+			{
 			size = newShader->stages[i]->bundle[b].numTexMods * sizeof( texModInfo_t );
 			newShader->stages[i]->bundle[b].texMods = ri.Hunk_Alloc( size, h_low );
 			Com_Memcpy( newShader->stages[i]->bundle[b].texMods, stages[i].bundle[b].texMods, size );
 		}
 	}
+	}
+	else
+	{
+		//copy from sourceshader
+		for ( i = 0 ; i < newShader->numUnfoggedPasses ; i++ ) 
+		{
+			if ( !sourceshader->stages[i]->active ) {
+				break;
+			}
+			newShader->stages[i] = ri.Hunk_Alloc( sizeof( stages[i] ), h_low );
+			*newShader->stages[i] = *sourceshader->stages[i];
+
+			for ( b = 0 ; b < NUM_TEXTURE_BUNDLES ; b++ ) 
+			{
+				size = newShader->stages[i]->bundle[b].numTexMods * sizeof( texModInfo_t );
+				newShader->stages[i]->bundle[b].texMods = ri.Hunk_Alloc( size, h_low );
+				Com_Memcpy( newShader->stages[i]->bundle[b].texMods, sourceshader->stages[i]->bundle[b].texMods, size );
+			}
+		}
+
+	}
 
 	SortNewShader();
 
@@ -2029,6 +2162,9 @@
 	newShader->next = hashTable[hash];
 	hashTable[hash] = newShader;
 
+	newShader->nameHash=generateShaderHash(newShader->name);
+
+
 	return newShader;
 }
 
@@ -2154,7 +2290,8 @@
 	//
 	// set appropriate stage information
 	//
-	for ( stage = 0; stage < MAX_SHADER_STAGES; stage++ ) {
+	for ( stage = 0; stage < MAX_SHADER_STAGES; ) 
+	{
 		shaderStage_t *pStage = &stages[stage];
 
 		if ( !pStage->active ) {
@@ -2165,17 +2302,33 @@
 		if ( !pStage->bundle[0].image[0] ) {
 			ri.Printf( PRINT_WARNING, "Shader %s has a stage with no image\n", shader.name );
 			pStage->active = qfalse;
+			stage++;
 			continue;
 		}
 
 		//
 		// ditch this stage if it's detail and detail textures are disabled
 		//
-		if ( pStage->isDetail && !r_detailTextures->integer ) {
-			if ( stage < ( MAX_SHADER_STAGES - 1 ) ) {
-				memmove( pStage, pStage + 1, sizeof( *pStage ) * ( MAX_SHADER_STAGES - stage - 1 ) );
-				Com_Memset(  pStage + 1, 0, sizeof( *pStage ) );
+		if ( pStage->isDetail && !r_detailTextures->integer )
+		{
+			int index;
+			
+			for(index = stage + 1; index < MAX_SHADER_STAGES; index++)
+			{
+				if(!stages[index].active)
+					break;
+			}
+			
+			if(index < MAX_SHADER_STAGES)
+				memmove(pStage, pStage + 1, sizeof(*pStage) * (index - stage));
+			else
+			{
+				if(stage + 1 < MAX_SHADER_STAGES)
+					memmove(pStage, pStage + 1, sizeof(*pStage) * (index - stage - 1));
+				
+				Com_Memset(&stages[index - 1], 0, sizeof(*stages));
 			}
+			
 			continue;
 		}
 
@@ -2244,6 +2397,8 @@
 				}
 			}
 		}
+		
+		stage++;
 	}
 
 	// there are times when you will need to manually apply a sort to
@@ -2278,6 +2433,21 @@
 	}
 
 
+	if (strstr(shader.name,"ivy2"))
+	{
+		//stages[0].bundle[0].image[0]=tr.defaultImage;
+		stage=stage;
+	}
+
+	//Some plants are both vertex lit and lightmapped cause someone forgot to use spawnflags 4
+	if (shader.lightmapIndex==LIGHTMAP_BY_VERTEX && stage>1 && stages[1].bundle[0].isLightmap && stages[1].bundle[0].image[0]==tr.whiteImage)
+	{
+		ri.Printf( PRINT_DEVELOPER, "WARNING: model using shader '%s' is VERTEX LIT but that shader has a lightmap stage!\n", shader.name );
+		shader.whiteLightmap=qtrue;
+				
+	}
+
+
 	//
 	// compute number of passes
 	//
@@ -2290,7 +2460,557 @@
 	// determine which stage iterator function is appropriate
 	ComputeStageIteratorFunc();
 
-	return GeneratePermanentShader();
+	return GeneratePermanentShader(&shader);
+}
+
+
+qboolean GLSL_CanEmulateDeforms(shader_t *checkshader)
+{
+	//Check a shader and see if we're able to emulate its deforms in glsl
+	if (checkshader->numDeforms==0) return qtrue;
+
+	if (checkshader->numDeforms>1) return qfalse;
+
+	if (checkshader->deforms[0].deformation==DEFORM_WAVE) return qtrue;  //yes we can!
+	if (checkshader->deforms[0].deformation==DEFORM_BULGE) return qfalse;
+	if (checkshader->deforms[0].deformation==DEFORM_MOVE) return qfalse;
+	
+
+	return qfalse;
+}
+
+qboolean GLSL_CanEmulateStage(shaderStage_t *stage)
+{
+	int b=0;
+	int tm=0;
+	//Check a stage and see if we're able to emulate its deforms in glsl
+	switch (stage->rgbGen)
+	{
+		case CGEN_BAD:
+			return qfalse;
+			break;
+		case CGEN_IDENTITY_LIGHTING:
+			break;
+		case CGEN_IDENTITY:
+			break;
+		case CGEN_ENTITY:
+			return qfalse;   //not doing entity yet
+			break;
+		case CGEN_ONE_MINUS_ENTITY:
+			return qfalse;    //not doing entity yet
+			break;
+		case CGEN_EXACT_VERTEX:
+			break;
+		case CGEN_VERTEX:
+			break;
+		case CGEN_ONE_MINUS_VERTEX:
+			break;
+		case CGEN_WAVEFORM:
+			return qfalse;  // cant do waveform (yet)
+			break;
+		case CGEN_LIGHTING_DIFFUSE:
+			return qfalse;	// not doing this yet, but should be easy, just dir, dircolor + ambient (see md5 stuff)
+			break;
+		case CGEN_FOG:
+			return qfalse;  //cant do fog (yet)
+			break;
+		case CGEN_CONST:
+			break;
+	}
+
+	switch (stage->alphaGen)
+	{
+		case AGEN_IDENTITY:
+			break;
+		case AGEN_SKIP:
+			break;
+		case AGEN_ENTITY:
+			return qfalse;  //nope
+			break;
+		case AGEN_ONE_MINUS_ENTITY:
+			return qfalse;  //nope not yet
+			break;
+		case AGEN_VERTEX:
+			break;
+		case AGEN_ONE_MINUS_VERTEX:
+			break;
+		case AGEN_LIGHTING_SPECULAR:
+			return qfalse; //cant do specular calc in shader yet, probably can later
+			break;
+		case AGEN_WAVEFORM:
+			return qfalse; //nope
+			break;
+		case AGEN_PORTAL:
+			return qfalse;  //nope - probably dont ever want to
+			break;
+		case AGEN_CONST:
+			break;
+	}
+
+	//Check the texture bundles now for tcmods
+	for ( b = 0; b < NUM_TEXTURE_BUNDLES; b++ ) 
+	{
+		switch ( stage->bundle[b].tcGen )
+		{
+			case TCGEN_IDENTITY:
+				break;
+			case TCGEN_TEXTURE:
+				break;
+			case TCGEN_LIGHTMAP:
+				//Logic here, if its already lightmap then leave it?
+				break;
+			case TCGEN_VECTOR:
+				break;
+			case TCGEN_FOG:
+				return qfalse;	
+				break;
+			case TCGEN_ENVIRONMENT_MAPPED:
+				return qfalse;
+				break;
+			case TCGEN_BAD:
+				break;
+		}
+
+		for ( tm = 0; tm < stage->bundle[b].numTexMods ; tm++ ) 
+		{
+			switch ( stage->bundle[b].texMods[tm].type )
+			{
+				case TMOD_NONE:
+					tm = TR_MAX_TEXMODS;		// break out of for loop
+					break;
+
+				case TMOD_TURBULENT:
+					return qfalse;
+					break;
+
+				case TMOD_ENTITY_TRANSLATE:
+					return qfalse;
+					break;
+
+				case TMOD_SCROLL:
+					return qfalse;
+					break;
+
+				case TMOD_SCALE:
+					return qfalse;
+					break;
+				
+				case TMOD_STRETCH:
+					return qfalse;
+					break;
+
+				case TMOD_TRANSFORM:
+					return qfalse;
+					break;
+
+				case TMOD_ROTATE:
+					return qfalse;
+					break;
+			}
+		}
+	}
+
+	return qtrue;
+}
+
+
+void FixRgbGen(shader_t* checkshader)
+{
+	//Collapse the rGBgen if we're lightmapping, with consideration for vertex lit stuff that thinks it has a lightmap *sigh*
+
+	if (checkshader->numUnfoggedPasses>1)
+	{
+		//if (checkshader->stages[1]->bundle[0].isLightmap)
+		//{
+			
+			
+		//	if (checkshader->stages[1]->rgbGen==CGEN_EXACT_VERTEX || checkshader->stages[1]->rgbGen==CGEN_IDENTITY )
+		//	{
+		//		checkshader->stages[0]->rgbGen=CGEN_VERTEX;
+		//	}
+		//	else
+		//	{
+		if (checkshader->stages[0]->rgbGen!=CGEN_EXACT_VERTEX && checkshader->stages[0]->rgbGen!=CGEN_VERTEX)
+		{
+			checkshader->stages[0]->rgbGen=checkshader->stages[1]->rgbGen;
+		}
+		//	}
+		
+			//checkshader->stages[1]->rgbGen=CGEN_VERTEX;
+			//checkshader->stages[0]->alphaGen=checkshader->stages[1]->alphaGen;
+		//}
+	}
+
+	
+}
+
+shader_t *GLSLOptimizeShader_Simple(shader_t *checkshader)
+{
+	//if we're doing simples, use the meanest nastiest ones possible
+
+	if (r_ext_vertex_buffer_object->integer && r_ext_vertex_shader->integer)
+	{
+		if (checkshader->numUnfoggedPasses==1 && GLSL_CanEmulateDeforms(checkshader) && GLSL_CanEmulateStage(checkshader->stages[0]) && !checkshader->isSky  )
+		{
+			//probably a static surface
+			if (checkshader->optimalStageIteratorFunc==RB_StageIteratorLightmappedMultitexture)
+			{
+				//Yep we are.
+				checkshader=GLSLMakeCloneOfShader(checkshader);
+				checkshader->optimalStageIteratorFunc=RB_StageIteratorLightmappedMultitexture_GLSL;
+			
+				checkshader->stages[0]->program=&tr.fragshader[FS_CHEAP];
+				checkshader->isGLSL=qtrue;
+				checkshader->isGLSLStatic=qtrue; //render from a SF_STATIC
+				FixRgbGen(checkshader);
+				return checkshader;
+			}
+
+		}
+
+		if (checkshader->optimalStageIteratorFunc==RB_StageIteratorGeneric && checkshader->lightmapIndex<0  && GLSL_CanEmulateDeforms(checkshader) && GLSL_CanEmulateStage(checkshader->stages[0]) ) 
+		{
+			
+			if (checkshader->numUnfoggedPasses==1 || (checkshader->numUnfoggedPasses==2 && checkshader->whiteLightmap) )
+			{
+				checkshader=GLSLMakeCloneOfShader(checkshader);
+				GLSLLoadImplicitStages(checkshader);
+
+				checkshader->optimalStageIteratorFunc= RB_StageIteratorLightmappedMultitexture_GLSL;
+				checkshader->stages[0]->program=&tr.fragshader[FS_VERTEX_LIGHT_CHEAP];
+				checkshader->isGLSL=qtrue;
+				checkshader->isGLSLStatic=qtrue; //render from a SF_STATIC
+				FixRgbGen(checkshader);
+				return checkshader;
+			}
+
+		}
+
+		//See if its terrain
+		if (checkshader->numUnfoggedPasses==3 &&  checkshader->numDeforms==0 &&  checkshader->optimalStageIteratorFunc==RB_StageIteratorGeneric)
+		{
+			//Stage 2 is the lightmap, stage 1 is the alphagen vertex
+			//Todo/possible bug: might have to inspect harder to make sure this is what we think it is.  Blendfuncs too maybe
+			if (checkshader->stages[2]->bundle[0].image[0]==tr.fatlightmap &&
+				checkshader->stages[1]->alphaGen==AGEN_VERTEX) 
+			{
+				checkshader=GLSLMakeCloneOfShader(checkshader);
+				GLSLLoadImplicitStages(checkshader);
+
+				checkshader->optimalStageIteratorFunc=RB_StageIteratorLightmappedTerrain_GLSL;
+				
+				checkshader->stages[0]->program=&tr.fragshader[FS_TERRAIN_ALPHA_CHEAP];
+
+				checkshader->stages[0]->stateBits= GLS_DEFAULT;
+				checkshader->isGLSL=qtrue;
+				checkshader->isGLSLStatic=qtrue; //render from a SF_STATIC
+				return checkshader;
+			}
+		}
+
+		//Tree shader
+		//&& checkshader->stages[1]->stateBits & GLS_DEPTHFUNC_EQUAL
+		if (checkshader->numUnfoggedPasses==2 && checkshader->stages[1]->bundle[0].isLightmap  &&  GLSL_CanEmulateDeforms(checkshader) && GLSL_CanEmulateStage(checkshader->stages[0]) )
+		{
+			checkshader=GLSLMakeCloneOfShader(checkshader);
+			GLSLLoadImplicitStages(checkshader);
+			checkshader->optimalStageIteratorFunc=RB_StageIteratorLightmappedMultitexture_GLSL;
+			checkshader->stages[0]->program=&tr.fragshader[FS_CHEAP];
+			checkshader->isGLSL=qtrue;
+			checkshader->isGLSLStatic=qtrue; //render from a SF_STATIC
+
+			FixRgbGen(checkshader);
+			return checkshader;
+		}
+
+	}
+	return checkshader;
+}
+
+
+//Inspects a shader, and determines if its suitable for one of our glsl paths
+//We don't want to call this for every shader, because it assumes the surface type this shader is using is glsl compatible (SF_STATIC etc)
+shader_t *GLSLOptimizeShader(shader_t *checkshader)
+{
+	//determine if we should use the static vertex path
+	if (!r_ext_vertex_buffer_object->integer || !r_ext_vertex_shader->integer) return checkshader;
+		
+	if (checkshader->numUnfoggedPasses==0) return checkshader;
+	if (checkshader->isSky) return checkshader;  //dont optimize skys
+	if (checkshader->sort==SS_PORTAL) return checkshader; //Dont optimize mirrors..
+
+	if (r_simpleshaders->integer) 
+	{
+		return GLSLOptimizeShader_Simple(checkshader);
+	}
+	
+		
+	//quick and nasty ones for water
+	if (checkshader->isFancyWater==1 && r_fancywater->integer==1)
+	{
+		ri.Printf( PRINT_DEVELOPER, "Shader %s is fancy water!\n", checkshader->name );
+		checkshader->optimalStageIteratorFunc=RB_StageIteratorWater_GLSL;
+		checkshader->stages[0]->program=&tr.fragshader[FS_WATER];
+		checkshader->isGLSL=qtrue;
+		checkshader->isGLSLStatic=qtrue; //render from a SF_STATIC
+
+		//set the blending
+		checkshader->stages[0]->stateBits= GLS_DEFAULT;
+		return checkshader;
+	}
+
+	if ((checkshader->isFancyWater==2 && r_fancywater->integer) || ( checkshader->isFancyWater==1 && r_fancywater->integer==2) )
+	{
+		//cheap fancy water just uses the regular vbo path
+		ri.Printf( PRINT_DEVELOPER, "Shader %s is cheap fancy water!\n", checkshader->name );
+		checkshader->optimalStageIteratorFunc=RB_StageIteratorCheapFancyWater_GLSL;
+		checkshader->stages[0]->program=&tr.fragshader[FS_WATER_CHEAP];
+		checkshader->isGLSL=qtrue;
+		checkshader->isGLSLStatic=qtrue; //render from a SF_STATIC
+		
+		checkshader->stages[0]->normalmap=tr.waterImage;
+
+		//set the blending
+		checkshader->stages[0]->stateBits= GLS_DEFAULT |  GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA ;
+		return checkshader;
+	}
+
+	//if (checkshader->numUnfoggedPasses==1 &&  checkshader->numDeforms==0 &&  checkshader->optimalStageIteratorFunc==RB_StageIteratorVertexLitTexture)
+	if (checkshader->optimalStageIteratorFunc==RB_StageIteratorGeneric && checkshader->lightmapIndex<0  && GLSL_CanEmulateDeforms(checkshader) && GLSL_CanEmulateStage(checkshader->stages[0]) ) 
+	{
+	
+		//Check the number of stages, if the 2nd stage is a redundant lightmap, ignore it
+		if (checkshader->numUnfoggedPasses==1 || (checkshader->numUnfoggedPasses==2 && checkshader->whiteLightmap) )
+		{
+			checkshader=GLSLMakeCloneOfShader(checkshader);
+			GLSLLoadImplicitStages(checkshader);
+
+			checkshader->optimalStageIteratorFunc= RB_StageIteratorLightmappedMultitexture_GLSL;
+			if (!checkshader->stages[0]->normalmap )
+			{
+				checkshader->stages[0]->program=&tr.fragshader[FS_VERTEX_LIGHT_CHEAP];
+			}
+			else
+			{
+				checkshader->stages[0]->program=&tr.fragshader[FS_VERTEX_LIGHT];
+			}
+			checkshader->isGLSL=qtrue;
+			checkshader->isGLSLStatic=qtrue; //render from a SF_STATIC
+			FixRgbGen(checkshader);
+			return checkshader;
+		}
+
+	}
+
+	//See if its terrain
+	if (checkshader->numUnfoggedPasses==3 &&  checkshader->numDeforms==0 &&  checkshader->optimalStageIteratorFunc==RB_StageIteratorGeneric)
+	{
+		//Stage 2 is the lightmap, stage 1 is the alphagen vertex
+		//Todo/possible bug: might have to inspect harder to make sure this is what we think it is.  Blendfuncs too maybe
+		if (checkshader->stages[2]->bundle[0].image[0]==tr.fatlightmap &&
+			checkshader->stages[1]->alphaGen==AGEN_VERTEX) 
+		{
+			checkshader=GLSLMakeCloneOfShader(checkshader);
+			GLSLLoadImplicitStages(checkshader);
+
+			checkshader->optimalStageIteratorFunc=RB_StageIteratorLightmappedTerrain_GLSL;
+
+			//if (checkshader->stages[1]->stateBits & GLS_ATEST_GE_80)
+			if (!checkshader->stages[0]->normalmap )		
+			{
+				checkshader->stages[0]->program=&tr.fragshader[FS_TERRAIN_ALPHA_CHEAP];
+			}
+			else
+			{
+				checkshader->stages[0]->program=&tr.fragshader[FS_RAD_TERRAIN_ALPHA];
+			}
+
+			checkshader->stages[0]->stateBits= GLS_DEFAULT;
+			checkshader->isGLSL=qtrue;
+			checkshader->isGLSLStatic=qtrue; //render from a SF_STATIC
+
+			return checkshader;
+		}
+	}
+				
+	if (checkshader->numUnfoggedPasses==1  && !checkshader->isSky &&  GLSL_CanEmulateDeforms(checkshader) && GLSL_CanEmulateStage(checkshader->stages[0]))
+	{
+		//probably a static surface
+		if (checkshader->optimalStageIteratorFunc==RB_StageIteratorLightmappedMultitexture)
+		{
+			//Yep we are.
+			checkshader=GLSLMakeCloneOfShader(checkshader);
+			GLSLLoadImplicitStages(checkshader);
+			checkshader->optimalStageIteratorFunc=RB_StageIteratorLightmappedMultitexture_GLSL;
+
+			//Pick the appropriate fragment program
+			if (!checkshader->stages[0]->normalmap )		
+			{
+				//If we have no normal map, use a cheap version			
+				checkshader->stages[0]->program=&tr.fragshader[FS_CHEAP];
+			}
+			else
+			{
+				if (checkshader->stages[0]->bumpmap && checkshader->useOffsetMapping)
+				{
+					checkshader->stages[0]->program=&tr.fragshader[FS_RAD_BUMP_OFFSET];
+				}
+				else
+				{
+					checkshader->stages[0]->program=&tr.fragshader[FS_RAD_BUMP];
+				}
+			}
+			checkshader->isGLSL=qtrue;
+			checkshader->isGLSLStatic=qtrue; //render from a SF_STATIC
+
+			FixRgbGen(checkshader);
+			return checkshader;
+		}
+	}
+
+	//Check to see if its like a tree billboard with alpha cutout /and or lightmap
+	//&& checkshader->stages[1]->stateBits & GLS_DEPTHFUNC_EQUAL 
+	if (checkshader->numUnfoggedPasses==2 && checkshader->stages[1]->bundle[0].isLightmap &&  GLSL_CanEmulateDeforms(checkshader) && GLSL_CanEmulateStage(checkshader->stages[0]) )
+	{
+		checkshader=GLSLMakeCloneOfShader(checkshader);
+		GLSLLoadImplicitStages(checkshader);
+		checkshader->optimalStageIteratorFunc=RB_StageIteratorLightmappedMultitexture_GLSL;
+
+		//Pick the appropriate fragment program
+		if (!checkshader->stages[0]->normalmap )		
+		{
+			//If we have no normal map, use a cheap version			
+			checkshader->stages[0]->program=&tr.fragshader[FS_CHEAP];
+		}
+		else
+		{
+			if (checkshader->stages[0]->bumpmap && checkshader->useOffsetMapping)
+			{
+				checkshader->stages[0]->program=&tr.fragshader[FS_RAD_BUMP_OFFSET];
+			}
+			else
+			{
+				checkshader->stages[0]->program=&tr.fragshader[FS_RAD_BUMP];
+			}
+		}
+		checkshader->isGLSL=qtrue;
+		checkshader->isGLSLStatic=qtrue; //render from a SF_STATIC
+		FixRgbGen(checkshader);
+		return checkshader;
+
+	}
+
+
+	
+
+
+
+	if (checkshader->isGLSL==qfalse)
+	{
+		ri.Printf( PRINT_DEVELOPER, "Shader %s is unable to be optimized!\n", checkshader->name );
+	}
+	
+	return checkshader;
+}
+
+shader_t *GLSLMakeCloneOfShader(shader_t* checkshader)
+{
+	//clone/find the shader with _GLSL appended
+	char newname[1024];
+	char oldname[1024];
+	long nameHash;
+	shader_t *oldshader;
+	strcpy(oldname,checkshader->name);
+	sprintf(newname,"%s_GLSL",checkshader->name);
+
+	nameHash=generateShaderHash(newname);
+	
+	//see if we're already updated this
+	oldshader=R_FindShaderByNameHashAndLightmap(nameHash,checkshader->lightmapIndex);
+	if (oldshader!=tr.defaultShader) return oldshader;
+
+
+	//clone the shader
+	oldshader=checkshader;
+	strcpy(checkshader->name,newname);//use the new name
+	checkshader= GeneratePermanentShader(checkshader);
+	strcpy(oldshader->name,oldname);//put it back
+	////////////////////////
+
+	return checkshader;
+}
+
+
+void GLSLLoadImplicitStages(shader_t* checkshader)
+{
+	int j;
+	if (checkshader->implicitLoad==qtrue) return;
+	checkshader->implicitLoad=qtrue;
+
+	for (j=0;j<checkshader->numUnfoggedPasses;j++)
+	{
+		int r=0; //Dont bother with the other bundles
+		image_t *image_normal;
+		char fileName_normal[128];
+		char fileName[128];
+		//Look for the normal map too, implicitly
+		
+		
+		if ( checkshader->stages[j]->bundle[r].isVideoMap==qfalse && checkshader->stages[j]->bundle[r].isLightmap==qfalse &&  checkshader->stages[j]->bumpmap==NULL  &&  checkshader->stages[j]->normalmap==NULL)
+		{
+			Com_sprintf(fileName_normal,sizeof(fileName_normal),"%s",checkshader->stages[j]->bundle[r].image[0]->imgName);
+			COM_StripExtension(fileName_normal,fileName_normal,sizeof(fileName_normal));
+			Com_sprintf(fileName,sizeof(fileName),"%s_n.tga",fileName_normal);
+			image_normal = R_FindImageFile( fileName, qtrue, qtrue, GL_REPEAT, qfalse ,qtrue,qtrue);
+			if ( !image_normal ) 
+			{
+				ri.Printf( PRINT_DEVELOPER, "No implict *_n normal map for shader %s\n", checkshader->stages[j]->bundle[r].image[0]->imgName );
+			}
+			else
+			{
+				checkshader->stages[j]->normalmap=image_normal;
+			}
+	
+			//Look for the bump map too, implicitly
+			Com_sprintf(fileName_normal,sizeof(fileName_normal),"%s",checkshader->stages[j]->bundle[r].image[0]->imgName);
+			COM_StripExtension(fileName_normal,fileName_normal,sizeof(fileName_normal));
+			Com_sprintf(fileName,sizeof(fileName),"%s_b.tga",fileName_normal);
+			image_normal = R_FindImageFile( fileName, qtrue, qtrue,  GL_REPEAT,qfalse,qfalse,qfalse );
+			if ( !image_normal ) 
+			{
+				ri.Printf( PRINT_DEVELOPER, "No implict *_b bump/offset map for shader %s\n", checkshader->stages[j]->bundle[r].image[0]->imgName );
+			}
+			else
+			{
+				checkshader->stages[j]->bumpmap=image_normal;
+				
+
+				//If theres no normalmap, we can just build one from the bump
+				if (checkshader->stages[j]->normalmap==NULL)
+				{
+					checkshader->stages[j]->normalmap=R_BuildNormalsFromBump(fileName,qtrue);
+
+				}	
+				else
+				{
+					//If theres a manually supplied N and B, use offset mapping
+					checkshader->useOffsetMapping=qtrue;
+					//checkshader->useOffsetMapping=qfalse;
+				}
+
+			}
+
+			//Ugh yucky hack for autobumping
+			if (r_autobump->integer>0)
+			{
+				if (checkshader->stages[j]->normalmap==NULL)
+				{
+					checkshader->stages[j]->normalmap=R_BuildNormalsFromBump(fileName_normal,qfalse);
+				}
+			}
+
+		}
+	}
 }
 
 //========================================================================================
@@ -2362,7 +3082,7 @@
 	int			hash;
 	shader_t	*sh;
 
-	if ( (name==NULL) || (name[0] == 0) ) {  // bk001205
+	if ( (name==NULL) || (name[0] == 0) ) {
 		return tr.defaultShader;
 	}
 
@@ -2387,6 +3107,25 @@
 	return tr.defaultShader;
 }
 
+//As above.
+
+shader_t *R_FindShaderByNameHashAndLightmap(long hash,int lightmapIndex )
+{
+	//char		strippedName[MAX_QPATH];
+	int			i;
+		
+	for (i=0;i<tr.numShaders;i++)
+	{
+		if (tr.shaders[i]->nameHash==hash && tr.shaders[i]->lightmapIndex==lightmapIndex) 
+		{
+			// match found
+			return tr.shaders[i];
+		}
+	}
+
+	return tr.defaultShader;
+}
+
 
 /*
 ===============
@@ -2431,6 +3170,10 @@
 	// lightmaps
 	if ( lightmapIndex >= 0 && lightmapIndex >= tr.numLightmaps ) {
 		lightmapIndex = LIGHTMAP_BY_VERTEX;
+	} else if ( lightmapIndex < LIGHTMAP_2D ) {
+		// negative lightmap indexes cause stray pointers (think tr.lightmaps[lightmapIndex])
+		ri.Printf( PRINT_WARNING, "WARNING: shader '%s' has invalid lightmap index of %d\n", name, lightmapIndex  );
+		lightmapIndex = LIGHTMAP_BY_VERTEX;
 	}
 
 	COM_StripExtension(name, strippedName, sizeof(strippedName));
@@ -2497,7 +3240,7 @@
 	// if not defined in the in-memory shader descriptions,
 	// look for a single supported image file
 	//
-	image = R_FindImageFile( name, mipRawImage, mipRawImage, mipRawImage ? GL_REPEAT : GL_CLAMP );
+	image = R_FindImageFile( name, mipRawImage, mipRawImage, mipRawImage ? GL_REPEAT : GL_CLAMP_TO_EDGE, qfalse ,qfalse,qfalse);
 	if ( !image ) {
 		ri.Printf( PRINT_DEVELOPER, "Couldn't find image file for shader %s\n", name );
 		shader.defaultShader = qtrue;
@@ -2542,7 +3285,7 @@
 		stages[1].stateBits |= GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO;
 	} else {
 		// two pass lightmap
-		stages[0].bundle[0].image[0] = tr.lightmaps[shader.lightmapIndex];
+		stages[0].bundle[0].image[0] = tr.fatlightmap;//tr.lightmaps[shader.lightmapIndex];
 		stages[0].bundle[0].isLightmap = qtrue;
 		stages[0].active = qtrue;
 		stages[0].rgbGen = CGEN_IDENTITY;	// lightmaps are scaled on creation
@@ -2565,7 +3308,7 @@
 
 	hash = generateHashValue(name, FILE_HASH_SIZE);
 
-	// 20051020 misantropia -- probably not necessary since this function
+	// probably not necessary since this function
 	// only gets called from tr_font.c with lightmapIndex == LIGHTMAP_2D
 	// but better safe than sorry.
 	if ( lightmapIndex >= tr.numLightmaps ) {
@@ -2647,7 +3390,7 @@
 		stages[1].stateBits |= GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO;
 	} else {
 		// two pass lightmap
-		stages[0].bundle[0].image[0] = tr.lightmaps[shader.lightmapIndex];
+		stages[0].bundle[0].image[0] = tr.fatlightmap;
 		stages[0].bundle[0].isLightmap = qtrue;
 		stages[0].active = qtrue;
 		stages[0].rgbGen = CGEN_IDENTITY;	// lightmaps are scaled on creation
@@ -2772,7 +3517,7 @@
 */
 shader_t *R_GetShaderByHandle( qhandle_t hShader ) {
 	if ( hShader < 0 ) {
-	  ri.Printf( PRINT_WARNING, "R_GetShaderByHandle: out of range hShader '%d'\n", hShader ); // bk: FIXME name
+	  ri.Printf( PRINT_WARNING, "R_GetShaderByHandle: out of range hShader '%d'\n", hShader );
 		return tr.defaultShader;
 	}
 	if ( hShader >= tr.numShaders ) {
@@ -2870,7 +3615,7 @@
 	char *oldp, *token, *hashMem;
 	int shaderTextHashTableSizes[MAX_SHADERTEXT_HASH], hash, size;
 
-	long sum = 0;
+	long sum = 0, summand;
 	// scan for shader files
 	shaderFiles = ri.FS_ListFiles( "scripts", ".shader", &numShaderFiles );
 
@@ -2891,10 +3636,38 @@
 
 		Com_sprintf( filename, sizeof( filename ), "scripts/%s", shaderFiles[i] );
 		ri.Printf( PRINT_DEVELOPER, "...loading '%s'\n", filename );
-		sum += ri.FS_ReadFile( filename, (void **)&buffers[i] );
-		if ( !buffers[i] ) {
+		summand = ri.FS_ReadFile( filename, (void **)&buffers[i] );
+		
+		if ( !buffers[i] )
 			ri.Error( ERR_DROP, "Couldn't load %s", filename );
+		
+		// Do a simple check on the shader structure in that file to make sure one bad shader file cannot fuck up all other shaders.
+		p = buffers[i];
+		while(1)
+		{
+			token = COM_ParseExt(&p, qtrue);
+			
+			if(!*token)
+				break;
+			
+			oldp = p;
+			
+			token = COM_ParseExt(&p, qtrue);
+			if(token[0] != '{' && token[1] != '\0')
+			{
+				ri.Printf(PRINT_WARNING, "WARNING: Bad shader file %s has incorrect syntax.\n", filename);
+				ri.FS_FreeFile(buffers[i]);
+				buffers[i] = NULL;
+				break;
 		}
+
+			SkipBracedSection(&oldp);
+			p = oldp;
+		}
+			
+		
+		if (buffers[i])
+			sum += summand;		
 	}
 
 	// build single large buffer
@@ -2902,13 +3675,17 @@
 	s_shaderText[ 0 ] = '\0';
 
 	// free in reverse order, so the temp files are all dumped
-	for ( i = numShaderFiles - 1; i >= 0 ; i-- ) {
+	for ( i = numShaderFiles - 1; i >= 0 ; i-- )
+	{
+		if(buffers[i])
+		{
 		p = &s_shaderText[strlen(s_shaderText)];
 		strcat( s_shaderText, buffers[i] );
 		ri.FS_FreeFile( buffers[i] );
 		COM_Compress(p);
 		strcat( s_shaderText, "\n" );
 	}
+	}
 
 	// free up memory
 	ri.FS_FreeFileList( shaderFiles );
@@ -3013,7 +3790,7 @@
 ==================
 */
 void R_InitShaders( void ) {
-	ri.Printf( PRINT_ALL, "Initializing Shaders\n" );
+	ri.Printf( PRINT_DEVELOPER, "Initializing Shaders\n" );
 
 	Com_Memset(hashTable, 0, sizeof(hashTable));
 
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_shadows.c bumpy-code/code/renderer/tr_shadows.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_shadows.c	2014-06-09 22:09:45.531844427 -0400
+++ bumpy-code/code/renderer/tr_shadows.c	2014-06-09 22:14:52.609548624 -0400
@@ -155,6 +155,7 @@
 	int		i;
 	int		numTris;
 	vec3_t	lightDir;
+	GLboolean rgba[4];
 
 	// we can only do this if we have enough space in the vertex buffers
 	if ( tess.numVertexes >= SHADER_MAX_VERTEXES / 2 ) {
@@ -215,6 +216,7 @@
 	qglColor3f( 0.2f, 0.2f, 0.2f );
 
 	// don't write to the color buffer
+	qglGetBooleanv(GL_COLOR_WRITEMASK, rgba);
 	qglColorMask( GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE );
 
 	qglEnable( GL_STENCIL_TEST );
@@ -245,7 +247,7 @@
 
 
 	// reenable writing to the color buffer
-	qglColorMask( GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE );
+	qglColorMask(rgba[0], rgba[1], rgba[2], rgba[3]);
 }
 
 
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_sky.c bumpy-code/code/renderer/tr_sky.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_sky.c	2014-06-09 22:09:45.531844427 -0400
+++ bumpy-code/code/renderer/tr_sky.c	2014-06-09 22:14:52.609548624 -0400
@@ -22,7 +22,7 @@
 // tr_sky.c
 #include "tr_local.h"
 
-#define SKY_SUBDIVISIONS		8
+#define SKY_SUBDIVISIONS		2
 #define HALF_SKY_SUBDIVISIONS	(SKY_SUBDIVISIONS/2)
 
 static float s_cloudTexCoords[6][SKY_SUBDIVISIONS+1][SKY_SUBDIVISIONS+1][2];
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_surface.c bumpy-code/code/renderer/tr_surface.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_surface.c	2014-06-09 22:09:45.531844427 -0400
+++ bumpy-code/code/renderer/tr_surface.c	2014-06-09 22:14:52.609548624 -0400
@@ -278,6 +279,58 @@
 }
 
 
+/*
+=============
+RB_SurfaceDecal
+=============
+*/
+
+void RB_SurfaceDecal( srfSurfaceDecal_t *srf ) 
+{
+	//Le fuck?! 
+	//This should never ever be called.
+}
+
+
+
+
+
+/*
+=============
+RB_SurfaceStatic
+=============
+*/
+
+void RB_SurfaceStatic( srfSurfaceStatic_t *srf ) {
+
+	if (tess.numStaticSurfs==2048-1)
+	{
+		
+		return;
+	}
+	tess.StaticSurfs[tess.numStaticSurfs++]=srf;
+	
+
+	/*
+GL_State( GLS_DEFAULT );	
+	GL_Cull(CT_TWO_SIDED);
+		qglBindTexture(0,0);
+		qglDisableClientState( GL_COLOR_ARRAY);
+	qglBindBuffer(GL_ARRAY_BUFFER, tr.VBO_vertexBuffer);
+	qglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, tr.VBO_indexBuffer);
+	//qglEnableClientState(GL_VERTEX_ARRAY);
+
+	qglVertexPointer(3,GL_FLOAT,sizeof(staticVert_t),GEOMETRY_VERTEX_OFFSET(0, staticVert_t , position ));
+	qglTexCoordPointer(2,GL_FLOAT,sizeof(staticVert_t),GEOMETRY_VERTEX_OFFSET(0, staticVert_t , uv ));
+	
+	qglDrawElements(GL_TRIANGLES, srf->numIndices , GL_UNSIGNED_INT,  GEOMETRY_INDEX_OFFSET(srf->startIndex)  );
+	
+	//qglDisableClientState(GL_VERTEX_ARRAY);
+	qglBindBuffer(GL_ARRAY_BUFFER, 0);
+	qglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+	qglEnableClientState( GL_COLOR_ARRAY);
+	*/
+}
 
 /*
 ==============
@@ -1244,5 +1297,8 @@
 #endif
 	(void(*)(void*))RB_SurfaceFlare,		// SF_FLARE,
 	(void(*)(void*))RB_SurfaceEntity,		// SF_ENTITY
-	(void(*)(void*))RB_SurfaceDisplayList		// SF_DISPLAY_LIST
+	(void(*)(void*))RB_SurfaceDisplayList,		// SF_DISPLAY_LIST
+	(void(*)(void*))RB_SurfaceStatic,		// SF_STATIC,
+	(void(*)(void*))RB_SurfaceDecal,		// SF_DECAL,
+
 };
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_types.h bumpy-code/code/renderer/tr_types.h
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_types.h	2014-06-09 22:09:45.531844427 -0400
+++ bumpy-code/code/renderer/tr_types.h	2014-06-09 22:14:52.609548624 -0400
@@ -28,23 +28,33 @@
 #define	MAX_ENTITIES	1023		// can't be increased without changing drawsurf bit packing
 
 // renderfx flags
-#define	RF_MINLIGHT			1		// allways have some light (viewmodel, some items)
-#define	RF_THIRD_PERSON		2		// don't draw through eyes, only mirrors (player bodies, chat sprites)
-#define	RF_FIRST_PERSON		4		// only draw through eyes (view weapon, damage blood blob)
-#define	RF_DEPTHHACK		8		// for view weapon Z crunching
-#define	RF_NOSHADOW			64		// don't add stencil shadows
+#define	RF_MINLIGHT		0x0001		// allways have some light (viewmodel, some items)
+#define	RF_THIRD_PERSON		0x0002		// don't draw through eyes, only mirrors (player bodies, chat sprites)
+#define	RF_FIRST_PERSON		0x0004		// only draw through eyes (view weapon, damage blood blob)
+#define	RF_DEPTHHACK		0x0008		// for view weapon Z crunching
+
+#define RF_CROSSHAIR		0x0010		// This item is a cross hair and will draw over everything similar to
+						// DEPTHHACK in stereo rendering mode, with the difference that the
+						// projection matrix won't be hacked to reduce the stereo separation as
+						// is done for the gun.
 
-#define RF_LIGHTING_ORIGIN	128		// use refEntity->lightingOrigin instead of refEntity->origin
+#define	RF_NOSHADOW		0x0040		// don't add stencil shadows
+
+#define RF_LIGHTING_ORIGIN	0x0080		// use refEntity->lightingOrigin instead of refEntity->origin
 									// for lighting.  This allows entities to sink into the floor
 									// with their origin going solid, and allows all parts of a
 									// player to get the same lighting
-#define	RF_SHADOW_PLANE		256		// use refEntity->shadowPlane
-#define	RF_WRAP_FRAMES		512		// mod the model frames by the maxframes to allow continuous
-									// animation without needing to know the frame count
+
+#define	RF_SHADOW_PLANE		0x0100		// use refEntity->shadowPlane
+#define	RF_WRAP_FRAMES		0x0200		// mod the model frames by the maxframes to allow continuous
 
 // refdef flags
-#define RDF_NOWORLDMODEL	1		// used for player configuration screen
-#define RDF_HYPERSPACE		4		// teleportation effect
+#define RDF_NOWORLDMODEL	0x0001		// used for player configuration screen
+#define RDF_HYPERSPACE		0x0004		// teleportation effect
+#define RDF_NOEFFECTS		0x0008		// Don't post-process this view
+#define RDF_NOCUBEMAP       0x0010      // no specular
+#define RDF_NODISPLAY       0x0020      // do not flip the screen for this frame, used for offscene renders
+#define RDF_NOCLEAR         0x0040      // Keeps the contents of the scene for next frame (currently used for vis experimentation work)
 
 typedef struct {
 	vec3_t		xyz;
@@ -71,7 +81,8 @@
 	RT_MAX_REF_ENTITY_TYPE
 } refEntityType_t;
 
-typedef struct {
+typedef struct
+{
 	refEntityType_t	reType;
 	int			renderfx;
 
@@ -84,7 +95,8 @@
 	vec3_t		axis[3];			// rotation vectors
 	qboolean	nonNormalizedAxes;	// axis are not normalized, i.e. they have scale
 	float		origin[3];			// also used as MODEL_BEAM's "from"
-	int			frame;				// also used as MODEL_BEAM's diameter
+	int       frame;	
+										            // also used as MODEL_BEAM's diameter
 
 	// previous data for frame interpolation
 	float		oldorigin[3];		// also used as MODEL_BEAM's "to"
@@ -145,7 +157,8 @@
 */
 typedef enum {
 	TC_NONE,
-	TC_S3TC
+	TC_S3TC,  // this is for the GL_S3_s3tc extension.
+	TC_S3TC_ARB  // this is for the GL_EXT_texture_compression_s3tc extension.
 } textureCompression_t;
 
 typedef enum {
@@ -176,6 +189,7 @@
 
 	int						maxTextureSize;			// queried from GL
	int						maxActiveTextures;		// multitexture ability
+	int						numTextureUnits;		// multitexture ability
 
 	int						colorBits, depthBits, stencilBits;
 
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_world.c bumpy-code/code/renderer/tr_world.c
--- ioq3-for-UrbanTerror-4-bumpy/code/renderer/tr_world.c	2014-06-09 22:09:45.531844427 -0400
+++ bumpy-code/code/renderer/tr_world.c	2014-06-09 22:14:52.609548624 -0400
@@ -281,7 +281,7 @@
 R_AddWorldSurface
 ======================
 */
-static void R_AddWorldSurface( msurface_t *surf, int dlightBits ) {
+void R_AddWorldSurface( msurface_t *surf, int dlightBits ) {
 	if ( surf->viewCount == tr.viewCount ) {
 		return;		// already in this view
 	}
@@ -294,6 +294,8 @@
 		return;
 	}
 
+	if (surf->shader && surf->shader->noFancyWater) return;
+
 	// check for dlighting
 	if ( dlightBits ) {
 		dlightBits = R_DlightSurface( surf, dlightBits );
@@ -498,7 +500,7 @@
 R_PointInLeaf
 ===============
 */
-static mnode_t *R_PointInLeaf( const vec3_t p ) {
+mnode_t *R_PointInLeaf( const vec3_t p ) {
 	mnode_t		*node;
 	float		d;
 	cplane_t	*plane;
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/unix/linux_glimp.c bumpy-code/code/unix/linux_glimp.c
--- ioq3-for-UrbanTerror-4-bumpy/code/unix/linux_glimp.c	2014-06-09 22:09:45.557844231 -0400
+++ bumpy-code/code/unix/linux_glimp.c	2014-06-09 22:14:52.659548255 -0400
@@ -150,40 +150,6 @@
 static int mouse_accel_denominator;
 static int mouse_threshold;    
 
-/*
-* Find the first occurrence of find in s.
-*/
-// bk001130 - from cvs1.17 (mkv), const
-// bk001130 - made first argument const
-static const char *Q_stristr( const char *s, const char *find)
-{
-  register char c, sc;
-  register size_t len;
-
-  if ((c = *find++) != 0)
-  {
-    if (c >= 'a' && c <= 'z')
-    {
-      c -= ('a' - 'A');
-    }
-    len = strlen(find);
-    do
-    {
-      do
-      {
-        if ((sc = *s++) == 0)
-          return NULL;
-        if (sc >= 'a' && sc <= 'z')
-        {
-          sc -= ('a' - 'A');
-        }
-      } while (sc != c);
-    } while (Q_stricmpn(s, find, len) != 0);
-    s--;
-  }
-  return s;
-}
-
 /*****************************************************************************
 ** KEYBOARD
 ** NOTE TTimo the keyboard handling is done with KeySyms
@@ -1040,9 +1006,6 @@
   else
     colorbits = r_colorbits->value;
 
-  if ( !Q_stricmp( r_glDriver->string, _3DFX_DRIVER_NAME ) )
-    colorbits = 16;
-
   if (!r_depthbits->value)
     depthbits = 24;
   else
@@ -1275,24 +1238,6 @@
       qglMultiTexCoord2fARB = ( PFNGLMULTITEXCOORD2FARBPROC ) dlsym( glw_state.OpenGLLib, "glMultiTexCoord2fARB" );
       qglActiveTextureARB = ( PFNGLACTIVETEXTUREARBPROC ) dlsym( glw_state.OpenGLLib, "glActiveTextureARB" );
       qglClientActiveTextureARB = ( PFNGLCLIENTACTIVETEXTUREARBPROC ) dlsym( glw_state.OpenGLLib, "glClientActiveTextureARB" );
-
-      if ( qglActiveTextureARB )
-      {
-        GLint glint = 0;
-        qglGetIntegerv( GL_MAX_ACTIVE_TEXTURES_ARB, &glint );
-        glConfig.maxActiveTextures = (int) glint;
-
-        if ( glConfig.maxActiveTextures > 1 )
-        {
-          ri.Printf( PRINT_ALL, "...using GL_ARB_multitexture\n" );
-        } else
-        {
-          qglMultiTexCoord2fARB = NULL;
-          qglActiveTextureARB = NULL;
-          qglClientActiveTextureARB = NULL;
-          ri.Printf( PRINT_ALL, "...not using GL_ARB_multitexture, < 2 texture units\n" );
-        }
-      }
     } else
     {
       ri.Printf( PRINT_ALL, "...ignoring GL_ARB_multitexture\n" );
@@ -1450,7 +1395,6 @@
 {
   qboolean attemptedlibGL = qfalse;
   qboolean attempted3Dfx = qfalse;
-  qboolean success = qfalse;
   char  buf[1024];
   cvar_t *lastValidRenderer = ri.Cvar_Get( "r_lastValidRenderer", "(uninitialized)", CVAR_ARCHIVE );
 
@@ -1485,48 +1429,10 @@
   //
   // load and initialize the specific OpenGL driver
   //
-  if ( !GLW_LoadOpenGL( r_glDriver->string ) )
-  {
-    if ( !Q_stricmp( r_glDriver->string, OPENGL_DRIVER_NAME ) )
-    {
-      attemptedlibGL = qtrue;
-    } else if ( !Q_stricmp( r_glDriver->string, _3DFX_DRIVER_NAME ) )
-    {
-      attempted3Dfx = qtrue;
-    }
-
-    #if 0
-    // TTimo
-    // https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=455
-    // old legacy load code, was confusing people who had a bad OpenGL setup
-    if ( !attempted3Dfx && !success )
-    {
-      attempted3Dfx = qtrue;
-      if ( GLW_LoadOpenGL( _3DFX_DRIVER_NAME ) )
-      {
-        ri.Cvar_Set( "r_glDriver", _3DFX_DRIVER_NAME );
-        r_glDriver->modified = qfalse;
-        success = qtrue;
-      }
+  if ( !GLW_LoadOpenGL( r_glDriver->string ) ) {
+    ri.Error( ERR_FATAL, "GLimp_Init() - could not load OpenGL subsystem\n" );
     }
-    #endif
 
-    // try ICD before trying 3Dfx standalone driver
-    if ( !attemptedlibGL && !success )
-    {
-      attemptedlibGL = qtrue;
-      if ( GLW_LoadOpenGL( OPENGL_DRIVER_NAME ) )
-      {
-        ri.Cvar_Set( "r_glDriver", OPENGL_DRIVER_NAME );
-        r_glDriver->modified = qfalse;
-        success = qtrue;
-      }
-    }
-
-    if (!success)
-      ri.Error( ERR_FATAL, "GLimp_Init() - could not load OpenGL subsystem - get help on the official website: http://www.urbanterror.info/support/manual/faq/\n" );
-
-  }
 
   // Save it in case the UI stomps it
   ri.Cvar_Set( "r_previousglDriver", r_glDriver->string );
@@ -1564,10 +1470,10 @@
     if ( Q_stristr( buf, "voodoo graphics/1 tmu/2 mb" ) )
     {
       ri.Cvar_Set( "r_picmip", "2" );
-      ri.Cvar_Get( "r_picmip", "0", CVAR_ARCHIVE | CVAR_LATCH );
+      ri.Cvar_Get( "r_picmip", "1", CVAR_ARCHIVE | CVAR_LATCH );
     } else
     {
-      ri.Cvar_Set( "r_picmip", "0" );
+      ri.Cvar_Set( "r_picmip", "1" );
 
       if ( Q_stristr( buf, "rage 128" ) || Q_stristr( buf, "rage128" ) )
       {
@@ -1813,9 +1719,7 @@
     // temporarily deactivate if not in the game and
     // running on the desktop
     // voodoo always counts as full screen
-    if (Cvar_VariableValue ("r_fullscreen") == 0
-        && strcmp( Cvar_VariableString("r_glDriver"), _3DFX_DRIVER_NAME ) )
-    {
+    if ( Cvar_VariableValue("r_fullscreen") == 0 ) {
       IN_DeactivateMouse ();
       return;
     }
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/unix/linux_qgl.c bumpy-code/code/unix/linux_qgl.c
--- ioq3-for-UrbanTerror-4-bumpy/code/unix/linux_qgl.c	2014-06-09 22:09:45.558844223 -0400
+++ bumpy-code/code/unix/linux_qgl.c	2014-06-09 22:14:52.660548247 -0400
@@ -39,12 +39,6 @@
 #include "../renderer/tr_local.h"
 #include "unix_glw.h"
 
-// bk001129 - from cvs1.17 (mkv)
-//#if defined(__FX__)
-//#include <GL/fxmesa.h>
-//#endif
-//#include <GL/glx.h> // bk010216 - FIXME: all of the above redundant? renderer/qgl.h
-
 #if defined(USE_SDL_VIDEO)
 #include "SDL.h"
 #include "SDL_loadso.h"
@@ -424,6 +418,41 @@
 void ( APIENTRY * qglSelectTextureSGIS)( GLenum );
 void ( APIENTRY * qglMTexCoord2fSGIS)( GLenum, GLfloat, GLfloat );
 
+void ( APIENTRY * qglBindBufferARB) ( GLenum target, GLuint buffer );
+GLvoid (APIENTRY * qglAttachObjectARB) (GLhandleARB containerObj, GLhandleARB obj);
+GLvoid (APIENTRY * qglBindFramebufferEXT) (GLenum target, GLuint framebuffer);
+GLvoid (APIENTRY * qglBindRenderbufferEXT) (GLenum target, GLuint renderbuffer);
+void (APIENTRY * qglBufferDataARB) (GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage);
+GLenum (APIENTRY * qglCheckFramebufferStatusEXT) (GLenum target);
+GLvoid (APIENTRY * qglCompileShaderARB) (GLhandleARB shaderObj);
+GLhandleARB (APIENTRY * qglCreateProgramObjectARB) (void);
+GLhandleARB (APIENTRY * qglCreateShaderObjectARB) (GLenum shaderType);
+GLvoid (APIENTRY * qglEnableVertexAttribArrayARB) (GLuint index);
+GLvoid (APIENTRY * qglDisableVertexAttribArrayARB) (GLuint index);
+GLvoid (APIENTRY * qglFramebufferRenderbufferEXT) (GLenum target, GLenum attachment,
+					       GLenum renderbuffertarget, GLuint renderbuffer);
+GLvoid (APIENTRY * qglFramebufferTexture2DEXT) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture, GLint level);
+void (APIENTRY * qglGenBuffersARB) (GLsizei n, GLuint * buffers);
+GLvoid (APIENTRY * qglGenFramebuffersEXT) (GLsizei n, GLuint *framebuffers);
+GLvoid (APIENTRY * qglGenRenderbuffersEXT) (GLsizei n, GLuint *renderbuffers);
+GLint(APIENTRY * qglGetAttribLocationARB) (GLhandleARB programObj, const GLcharARB * name);
+GLvoid (APIENTRY * qglGetInfoLogARB) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
+GLvoid (APIENTRY * qglGetObjectParameterivARB) (GLhandleARB obj, GLenum pname, GLint *params);
+GLint(APIENTRY * qglGetUniformLocationARB) (GLhandleARB programObj, const GLcharARB * name);
+GLvoid (APIENTRY * qglLinkProgramARB) (GLhandleARB programObj);
+GLvoid (APIENTRY * qglRenderbufferStorageEXT) (GLenum target, GLenum internalformat,
+					   GLsizei width, GLsizei height);
+GLvoid (APIENTRY * qglShaderSourceARB) (GLhandleARB shaderObj, GLsizei count, const GLcharARB **string,
+				       const GLint *length);
+GLvoid (APIENTRY * qglUniform1fARB) (GLint location, GLfloat v0);
+GLvoid (APIENTRY * qglUniform1iARB) (GLint location, GLint v0);
+GLvoid (APIENTRY * qglUniform3fARB) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+GLvoid (APIENTRY * qglUniform4fARB) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+GLvoid (APIENTRY * qglUseProgramObjectARB) (GLhandleARB programObj);
+GLvoid (APIENTRY * qglVertexAttribPointerARB) (GLuint index, GLint size, GLenum type, GLboolean normalized,
+					      GLsizei stride, const GLvoid *pointer);
+
 static void ( APIENTRY * dllAccum )(GLenum op, GLfloat value);
 static void ( APIENTRY * dllAlphaFunc )(GLenum func, GLclampf ref);
 GLboolean ( APIENTRY * dllAreTexturesResident )(GLsizei n, const GLuint *textures, GLboolean *residences);
@@ -3038,6 +3067,36 @@
 	qglXCopyContext              = NULL;
 	qglXSwapBuffers              = NULL;
 #endif
+
+    qglBindBufferARB = NULL;
+    qglAttachObjectARB = NULL;
+    qglBindFramebufferEXT = NULL;
+    qglBindRenderbufferEXT = NULL;
+    qglBufferDataARB = NULL;
+    qglCheckFramebufferStatusEXT = NULL;
+    qglCompileShaderARB = NULL;
+    qglCreateProgramObjectARB = NULL;
+    qglCreateShaderObjectARB = NULL;
+    qglDisableVertexAttribArrayARB = NULL;
+    qglEnableVertexAttribArrayARB = NULL;
+    qglFramebufferRenderbufferEXT = NULL;
+    qglFramebufferTexture2DEXT = NULL;
+    qglGenBuffersARB = NULL;
+    qglGenFramebuffersEXT = NULL;
+    qglGenRenderbuffersEXT = NULL;
+    qglGetAttribLocationARB = NULL;
+    qglGetInfoLogARB = NULL;
+    qglGetObjectParameterivARB = NULL;
+    qglGetUniformLocationARB = NULL;
+    qglLinkProgramARB = NULL;
+    qglRenderbufferStorageEXT = NULL;
+    qglShaderSourceARB = NULL;
+    qglUniform1fARB = NULL;
+    qglUniform1iARB = NULL;
+    qglUniform3fARB = NULL;
+    qglUniform4fARB = NULL;
+    qglUseProgramObjectARB = NULL;
+    qglVertexAttribPointerARB = NULL;
 }
 
 #if USE_SDL_VIDEO
@@ -3472,6 +3531,36 @@
 	qglClientActiveTextureARB = NULL;
 	qglMultiTexCoord2fARB = NULL;
 
+    qglBindBufferARB = GPA( "glBindBufferARB" );
+    qglAttachObjectARB = GPA( "glAttachObjectARB" );
+    qglBindFramebufferEXT = GPA( "glBindFramebufferEXT" );
+    qglBindRenderbufferEXT = GPA( "glBindRenderbufferEXT" );
+    qglBufferDataARB = GPA( "glBufferDataARB" );
+    qglCheckFramebufferStatusEXT = GPA( "glCheckFramebufferStatusEXT" );
+    qglCompileShaderARB = GPA( "glCompileShaderARB" );
+    qglCreateProgramObjectARB = GPA( "glCreateProgramObjectARB" );
+    qglCreateShaderObjectARB = GPA( "glCreateShaderObjectARB" );
+    qglDisableVertexAttribArrayARB = GPA( "glDisableVertexAttribArrayARB" );
+    qglEnableVertexAttribArrayARB = GPA( "glEnableVertexAttribArrayARB" );
+    qglFramebufferRenderbufferEXT = GPA( "glFramebufferRenderbufferEXT" );
+    qglFramebufferTexture2DEXT = GPA( "glFramebufferTexture2DEXT" );
+    qglGenBuffersARB = GPA( "glGenBuffersARB" );
+    qglGenFramebuffersEXT = GPA( "glGenFramebuffersEXT" );
+    qglGenRenderbuffersEXT = GPA( "glGenRenderbuffersEXT" );
+    qglGetAttribLocationARB = GPA( "glGetAttribLocationARB" );
+    qglGetInfoLogARB = GPA( "glGetInfoLogARB" );
+    qglGetObjectParameterivARB = GPA( "glGetObjectParameterivARB" );
+    qglGetUniformLocationARB = GPA( "glGetUniformLocationARB" );
+    qglLinkProgramARB = GPA( "glLinkProgramARB" );
+    qglRenderbufferStorageEXT = GPA( "glRenderbufferStorageEXT" );
+    qglShaderSourceARB = GPA( "glShaderSourceARB" );
+    qglUniform1fARB = GPA( "glUniform1fARB" );
+    qglUniform1iARB = GPA( "glUniform1iARB" );
+    qglUniform3fARB = GPA( "glUniform3fARB" );
+    qglUniform4fARB = GPA( "glUniform4fARB" );
+    qglUseProgramObjectARB = GPA( "glUseProgramObjectARB" );
+    qglVertexAttribPointerARB = GPA( "glVertexAttribPointerARB" );
+
 	return qtrue;
 }
 
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/unix/sdl_glimp.c bumpy-code/code/unix/sdl_glimp.c
--- ioq3-for-UrbanTerror-4-bumpy/code/unix/sdl_glimp.c	2014-06-09 22:09:45.559844215 -0400
+++ bumpy-code/code/unix/sdl_glimp.c	2014-06-09 22:14:52.661548239 -0400
@@ -95,17 +95,6 @@
 #define GLimp_SetCurrentContext(ctx)
 #endif
 
-#ifndef MACOS_X
-#ifdef USE_ALTGAMMA
-#include <X11/Xlib.h>
-#include <X11/extensions/xf86vmode.h>
-
-static XF86VidModeGamma origGamma;
-static Display *disp;
-static int scrNum;
-#endif
-#endif
-
 static QGLContext opengl_context;
 
 //#define KBD_DBG
@@ -578,30 +567,12 @@
 */
 void GLimp_SetGamma( unsigned char red[256], unsigned char green[256], unsigned char blue[256] )
 {
-  #ifndef MACOS_X
-  #ifdef USE_ALTGAMMA
-  float g = Cvar_Get("r_gamma", "1.0", 0)->value;
-  XF86VidModeGamma gamma;
-
-  gamma.red = g;
-  gamma.green = g;
-  gamma.blue = g;
-
-  XF86VidModeSetGamma(disp, scrNum, &gamma);
-  XF86VidModeGetGamma(disp, scrNum, &gamma);
-  Com_Printf("XF86VidModeSetGamma: %.3f, %.3f, %.3f.\n", gamma.red, gamma.green, gamma.blue);
-  return;
-  #endif
-  #endif
-
-
 	Uint16 table[3][256];
 	int i, j;
     //	float g;
 
-	if ( r_ignorehwgamma->integer ) {
+	if(r_ignorehwgamma->integer)
 		return;
-    }
 
 	// taken from win_gamma.c:
 	for (i = 0; i < 256; i++)
@@ -621,22 +592,10 @@
 		}
 	}
 
-#if 1
-    Com_Printf( "SDL_SetGammaRamp: " );
-	if ( SDL_SetGammaRamp( table[0], table[1], table[2] ) < 0 ) {
-        Com_Printf( "failed\n" );
-    } else {
-        Com_Printf( "success\n" );
-    }
-#else
-	g = Cvar_Get( "r_gamma", "1.0", 0 )->value;
-    Com_Printf( "SDL_SetGamma %f: ", g );
-	if ( SDL_SetGamma( g, g, g ) ) {
-        Com_Printf( "failed\n" );
-    } else {
-        Com_Printf( "success\n" );
-    }    
-#endif
+	SDL_SetGammaRamp(table[0], table[1], table[2]);
+
+//	g  = Cvar_Get("r_gamma", "1.0", 0)->value;
+//	SDL_SetGamma(g, g, g);
 }
 
 /*
@@ -653,13 +612,6 @@
   IN_Shutdown();
   screen = NULL;
 
-  #ifndef MACOS_X
-  #ifdef USE_ALTGAMMA
-  XF86VidModeSetGamma(disp, scrNum, &origGamma);
-  XCloseDisplay(disp);
-  #endif
-  #endif
-
   memset( &glConfig, 0, sizeof( glConfig ) );
   memset( &glState, 0, sizeof( glState ) );
 
@@ -1041,15 +993,6 @@
 static void GLW_InitGamma( void )
 {
     glConfig.deviceSupportsGamma = qtrue;
-
-    #ifndef MACOS_X
-    #ifdef USE_ALTGAMMA
-    disp = XOpenDisplay(NULL);
-    scrNum = DefaultScreen(disp);
-    XF86VidModeGetGamma(disp, scrNum, &origGamma);
-    #endif
-    #endif
-
 }
 
 /*
@@ -1175,7 +1118,7 @@
     }
 
     if (!success)
-      ri.Error( ERR_FATAL, "GLimp_Init() - could not load OpenGL subsystem - get help on the official website: http://www.urbanterror.info/support/manual/faq/\n" );
+      ri.Error( ERR_FATAL, "GLimp_Init() - could not load OpenGL subsystem\n" );
 
   }
 
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/unix/unix_main.c bumpy-code/code/unix/unix_main.c
--- ioq3-for-UrbanTerror-4-bumpy/code/unix/unix_main.c	2014-06-09 22:09:45.564844175 -0400
+++ bumpy-code/code/unix/unix_main.c	2014-06-09 22:14:52.666548204 -0400
@@ -119,10 +119,6 @@
 // bk001207 
 #define MEM_THRESHOLD 96*1024*1024
 
-#define MAX_CMD 1024
-static char exit_cmdline[MAX_CMD] = "";
-void Sys_DoStartProcess( char *cmdline );
-
 /*
 ==================
 Sys_LowPhysicalMemory()
@@ -354,7 +350,7 @@
 #else
 
   // Give me a backtrace on error exits.
-  //  assert( ex == 0 );
+  assert( ex == 0 );
   exit(ex);
 #endif
 }
@@ -1200,33 +1196,8 @@
 
 char *Sys_GetClipboardData(void)
 {
-  char *data = NULL;
-  char *cliptext;
-  FILE *fp;
-
-  #ifdef MACOS_X
-  fp = popen("/usr/bin/pbpaste", "r");
-  #else
-  if (access("/usr/bin/xclip", F_OK) != -1) {
-      fp = popen("/usr/bin/xclip -o", "r");
-  } else if (access("/usr/local/bin/xclip", F_OK) != -1) {
-      fp = popen("/usr/local/bin/xclip -o", "r");
-  } else {
       return NULL;
   }
-  #endif
-  if (fp != NULL) {
-    cliptext = Z_Malloc(1024);
-    if (fgets(cliptext, sizeof(cliptext)-1, fp) != NULL) {
-      data = Z_Malloc(sizeof(cliptext) + 1);
-      Q_strncpyz(data, cliptext, sizeof(cliptext));
-      strtok(data, "\n\r\b");
-    }
-    pclose(fp);
-  }
-
-  return data;
-}
 
 static struct Q3ToAnsiColorTable_s
 {
@@ -1249,7 +1220,7 @@
 
 void Sys_ANSIColorify( const char *msg, char *buffer, int bufferSize )
 {
-  int   msgLength;
+  int   msgLength, pos;
   int   i, j;
   char  *escapeCode;
   char  tempBuffer[ 7 ];
@@ -1258,6 +1229,7 @@
     return;
 
   msgLength = strlen( msg );
+  pos = 0;
   i = 0;
   buffer[ 0 ] = '\0';
 
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/unix/unix_shared.c bumpy-code/code/unix/unix_shared.c
--- ioq3-for-UrbanTerror-4-bumpy/code/unix/unix_shared.c	2014-06-09 22:09:45.564844175 -0400
+++ bumpy-code/code/unix/unix_shared.c	2014-06-09 22:14:52.667548196 -0400
@@ -263,6 +262,7 @@
 	int			i;
 	struct stat st;
 
+	int			extLen;
 
 	if (filter) {
 
@@ -292,6 +292,8 @@
 		dironly = qtrue;
 	}
 	
+	extLen = strlen( extension );
+	
 	// search
 	nfiles = 0;
 
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/win32/win_gamma.c bumpy-code/code/win32/win_gamma.c
--- ioq3-for-UrbanTerror-4-bumpy/code/win32/win_gamma.c	2014-06-09 22:09:45.576844087 -0400
+++ bumpy-code/code/win32/win_gamma.c	2014-06-09 22:14:52.946546136 -0400
@@ -41,17 +41,6 @@
 
 	glConfig.deviceSupportsGamma = qfalse;
 
-	if ( qwglSetDeviceGammaRamp3DFX )
-	{
-		glConfig.deviceSupportsGamma = qtrue;
-
-		hDC = GetDC( GetDesktopWindow() );
-		glConfig.deviceSupportsGamma = qwglGetDeviceGammaRamp3DFX( hDC, s_oldHardwareGamma );
-		ReleaseDC( GetDesktopWindow(), hDC );
-
-		return;
-	}
-
 	// non-3Dfx standalone drivers don't support gamma changes, period
 	if ( glConfig.driverType == GLDRV_STANDALONE )
 	{
@@ -180,11 +169,7 @@
 	}
 
 
-	if ( qwglSetDeviceGammaRamp3DFX )
-	{
-		qwglSetDeviceGammaRamp3DFX( glw_state.hDC, table );
-	}
-	else
+	
 	{
 		ret = SetDeviceGammaRamp( glw_state.hDC, table );
 		if ( !ret ) {
@@ -200,11 +185,6 @@
 {
 	if ( glConfig.deviceSupportsGamma )
 	{
-		if ( qwglSetDeviceGammaRamp3DFX )
-		{
-			qwglSetDeviceGammaRamp3DFX( glw_state.hDC, s_oldHardwareGamma );
-		}
-		else
 		{
 			HDC hDC;
 			
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/win32/win_glimp.c bumpy-code/code/win32/win_glimp.c
--- ioq3-for-UrbanTerror-4-bumpy/code/win32/win_glimp.c	2014-06-09 22:09:45.576844087 -0400
+++ bumpy-code/code/win32/win_glimp.c	2014-06-09 22:14:52.947546129 -0400
@@ -524,7 +524,7 @@
 	//
 	if ( !glw_state.pixelFormatSet )
 	{
-		GLW_CreatePFD( &pfd, colorbits, depthbits, stencilbits, r_stereo->integer );
+		GLW_CreatePFD( &pfd, colorbits, depthbits, stencilbits, r_stereoEnabled->integer );
 		if ( ( tpfd = GLW_MakeContext( &pfd ) ) != TRY_PFD_SUCCESS )
 		{
 			if ( tpfd == TRY_PFD_FAIL_HARD )
@@ -554,7 +554,7 @@
 			{
 				colorbits = glw_state.desktopBitsPixel;
 			}
-			GLW_CreatePFD( &pfd, colorbits, depthbits, 0, r_stereo->integer );
+			GLW_CreatePFD( &pfd, colorbits, depthbits, 0, r_stereoEnabled->integer );
 			if ( GLW_MakeContext( &pfd ) != TRY_PFD_SUCCESS )
 			{
 				if ( glw_state.hDC )
@@ -572,7 +572,7 @@
 		/*
 		** report if stereo is desired but unavailable
 		*/
-		if ( !( pfd.dwFlags & PFD_STEREO ) && ( r_stereo->integer != 0 ) ) 
+		if ( !( pfd.dwFlags & PFD_STEREO ) && ( r_stereoEnabled->integer != 0 ) ) 
 		{
 			ri.Printf( PRINT_ALL, "...failed to select stereo pixel format\n" );
 			glConfig.stereoEnabled = qfalse;
@@ -647,7 +647,7 @@
 		r.right  = width;
 		r.bottom = height;
 
-		if ( cdsFullscreen || !Q_stricmp( _3DFX_DRIVER_NAME, drivername ) )
+		if ( cdsFullscreen  )
 		{
 			exstyle = WS_EX_TOPMOST;
 			stylebits = WS_POPUP|WS_VISIBLE|WS_SYSMENU;
@@ -662,7 +662,7 @@
 		w = r.right - r.left;
 		h = r.bottom - r.top;
 
-		if ( cdsFullscreen || !Q_stricmp( _3DFX_DRIVER_NAME, drivername ) )
+		if ( cdsFullscreen  )
 		{
 			x = 0;
 			y = 0;
@@ -935,15 +935,9 @@
 					
 					PrintCDSError( cdsRet );
 					
-					//@Barbatos - try initializing default 800x600 mode instead of crashing
-					ri.Printf( PRINT_ALL, "... trying to fallback to r_mode 4 (800x600)\n");
-					ri.Cvar_Set( "r_mode", "4" );
-					glw_state.cdsFullscreen = qtrue;
-
-					if ( !GLW_CreateWindow( drivername, glConfig.vidWidth, glConfig.vidHeight, colorbits, qtrue) )
-					{
 						ri.Printf( PRINT_ALL, "...restoring display settings\n" );
 						ChangeDisplaySettings( 0, 0 );
+					
 						glw_state.cdsFullscreen = qfalse;
 						glConfig.isFullscreen = qfalse;
 						if ( !GLW_CreateWindow( drivername, glConfig.vidWidth, glConfig.vidHeight, colorbits, qfalse) )
@@ -952,12 +946,6 @@
 						}
 						return RSERR_INVALID_FULLSCREEN;
 					}
-					// Perform a vid_restart to apply the changes
-					else {
-						Cbuf_AddText( "vid_restart" );
-					}
-					
-				}
 			}
 		}
 		if( glw_state.cdsFullscreen )
@@ -995,190 +983,406 @@
 	return RSERR_OK;
 }
 
+
+static qboolean GLimp_HaveExtension(const char *ext)
+{
+	const char *ptr = Q_stristr( glConfig.extensions_string, ext );
+	if (ptr == NULL)
+		return qfalse;
+	ptr += strlen(ext);
+	return ((*ptr == ' ') || (*ptr == '\0'));  // verify it's complete string.
+}
+
 /*
 ** GLW_InitExtensions
 */
+
+
+#define SDL_GL_GetProcAddress( a) qwglGetProcAddress(  a )
+
 static void GLW_InitExtensions( void )
 {
 	if ( !r_allowExtensions->integer )
 	{
-		ri.Printf( PRINT_ALL, "*** IGNORING OPENGL EXTENSIONS ***\n" );
+		ri.Printf( PRINT_ALL, "* IGNORING OPENGL EXTENSIONS *\n" );
 		return;
 	}
 
-	ri.Printf( PRINT_ALL, "Initializing OpenGL extensions\n" );
+	ri.Printf( PRINT_DEVELOPER, "Initializing OpenGL extensions\n" );
+
+	// GL_EXT_draw_range_elements
+	if ( GLimp_HaveExtension( "GL_EXT_draw_range_elements" ) )
+	{
+		qglDrawRangeElementsEXT = SDL_GL_GetProcAddress( "glDrawRangeElementsEXT" );
+	}
 
-	// GL_S3_s3tc
 	glConfig.textureCompression = TC_NONE;
-	if ( strstr( glConfig.extensions_string, "GL_S3_s3tc" ) )
+
+	// GL_EXT_texture_compression_s3tc
+	if ( GLimp_HaveExtension( "GL_ARB_texture_compression" ) &&
+	     GLimp_HaveExtension( "GL_EXT_texture_compression_s3tc" ) )
 	{
-		if ( r_ext_compressed_textures->integer )
+		if ( r_ext_compressed_textures->value )
 		{
-			glConfig.textureCompression = TC_S3TC;
-			ri.Printf( PRINT_ALL, "...using GL_S3_s3tc\n" );
+			glConfig.textureCompression = TC_S3TC_ARB;
+			ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_texture_compression_s3tc\n" );
 		}
 		else
 		{
-			glConfig.textureCompression = TC_NONE;
-			ri.Printf( PRINT_ALL, "...ignoring GL_S3_s3tc\n" );
+			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_texture_compression_s3tc\n" );
 		}
 	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...GL_S3_s3tc not found\n" );
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture_compression_s3tc not found\n" );
 	}
 
-	// GL_EXT_texture_env_add
-	glConfig.textureEnvAddAvailable = qfalse;
-	if ( strstr( glConfig.extensions_string, "EXT_texture_env_add" ) )
+	// GL_S3_s3tc ... legacy extension before GL_EXT_texture_compression_s3tc.
+	if (glConfig.textureCompression == TC_NONE)
 	{
-		if ( r_ext_texture_env_add->integer )
+		if ( GLimp_HaveExtension( "GL_S3_s3tc" ) )
 		{
-			glConfig.textureEnvAddAvailable = qtrue;
-			ri.Printf( PRINT_ALL, "...using GL_EXT_texture_env_add\n" );
+			if ( r_ext_compressed_textures->value )
+			{
+				glConfig.textureCompression = TC_S3TC;
+				ri.Printf( PRINT_DEVELOPER, "...using GL_S3_s3tc\n" );
 		}
 		else
 		{
-			glConfig.textureEnvAddAvailable = qfalse;
-			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_env_add\n" );
+				ri.Printf( PRINT_DEVELOPER, "...ignoring GL_S3_s3tc\n" );
 		}
 	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...GL_EXT_texture_env_add not found\n" );
+			ri.Printf( PRINT_DEVELOPER, "...GL_S3_s3tc not found\n" );
+		}
 	}
 
-	// WGL_EXT_swap_control
-	qwglSwapIntervalEXT = ( BOOL (WINAPI *)(int)) qwglGetProcAddress( "wglSwapIntervalEXT" );
-	if ( qwglSwapIntervalEXT )
+
+	// GL_EXT_texture_env_add
+	glConfig.textureEnvAddAvailable = qfalse;
+	if ( GLimp_HaveExtension( "EXT_texture_env_add" ) )
 	{
-		ri.Printf( PRINT_ALL, "...using WGL_EXT_swap_control\n" );
-		r_swapInterval->modified = qtrue;	// force a set next frame
+		if ( r_ext_texture_env_add->integer )
+		{
+			glConfig.textureEnvAddAvailable = qtrue;
+			ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_texture_env_add\n" );
 	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...WGL_EXT_swap_control not found\n" );
+			glConfig.textureEnvAddAvailable = qfalse;
+			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_texture_env_add\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture_env_add not found\n" );
 	}
 
 	// GL_ARB_multitexture
 	qglMultiTexCoord2fARB = NULL;
 	qglActiveTextureARB = NULL;
 	qglClientActiveTextureARB = NULL;
-	if ( strstr( glConfig.extensions_string, "GL_ARB_multitexture" )  )
+	if ( GLimp_HaveExtension( "GL_ARB_multitexture" ) )
 	{
-		if ( r_ext_multitexture->integer )
+		if ( r_ext_multitexture->value )
 		{
-			qglMultiTexCoord2fARB = ( PFNGLMULTITEXCOORD2FARBPROC ) qwglGetProcAddress( "glMultiTexCoord2fARB" );
-			qglActiveTextureARB = ( PFNGLACTIVETEXTUREARBPROC ) qwglGetProcAddress( "glActiveTextureARB" );
-			qglClientActiveTextureARB = ( PFNGLCLIENTACTIVETEXTUREARBPROC ) qwglGetProcAddress( "glClientActiveTextureARB" );
+			qglMultiTexCoord2fARB = SDL_GL_GetProcAddress( "glMultiTexCoord2fARB" );
+			qglActiveTextureARB = SDL_GL_GetProcAddress( "glActiveTextureARB" );
+			qglClientActiveTextureARB = SDL_GL_GetProcAddress( "glClientActiveTextureARB" );
 
 			if ( qglActiveTextureARB )
 			{
-				qglGetIntegerv( GL_MAX_ACTIVE_TEXTURES_ARB, &glConfig.maxActiveTextures );
-
-				if ( glConfig.maxActiveTextures > 1 )
+				GLint glint = 0;
+				qglGetIntegerv( GL_MAX_TEXTURE_UNITS_ARB, &glint );
+				glConfig.numTextureUnits = (int) glint;
+				if ( glConfig.numTextureUnits > NUM_TEXTURE_BUNDLES )
+					glConfig.numTextureUnits = NUM_TEXTURE_BUNDLES;
+				if ( r_ext_multitexture->integer > 1 &&
+				     glConfig.numTextureUnits > r_ext_multitexture->integer )
+					glConfig.numTextureUnits = r_ext_multitexture->integer;
+				if ( glConfig.numTextureUnits > 1 )
 				{
-					ri.Printf( PRINT_ALL, "...using GL_ARB_multitexture\n" );
+					ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_multitexture (%d of %d units)\n", glConfig.numTextureUnits, glint );
 				}
 				else
 				{
 					qglMultiTexCoord2fARB = NULL;
 					qglActiveTextureARB = NULL;
 					qglClientActiveTextureARB = NULL;
-					ri.Printf( PRINT_ALL, "...not using GL_ARB_multitexture, < 2 texture units\n" );
+					ri.Printf( PRINT_DEVELOPER, "...not using GL_ARB_multitexture, < 2 texture units\n" );
 				}
 			}
 		}
 		else
 		{
-			ri.Printf( PRINT_ALL, "...ignoring GL_ARB_multitexture\n" );
+			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_multitexture\n" );
 		}
 	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...GL_ARB_multitexture not found\n" );
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_multitexture not found\n" );
 	}
 
-	// GL_EXT_compiled_vertex_array
-	qglLockArraysEXT = NULL;
-	qglUnlockArraysEXT = NULL;
-	if ( strstr( glConfig.extensions_string, "GL_EXT_compiled_vertex_array" ) && ( glConfig.hardwareType != GLHW_RIVA128 ) )
-	{
-		if ( r_ext_compiled_vertex_array->integer )
-		{
-			ri.Printf( PRINT_ALL, "...using GL_EXT_compiled_vertex_array\n" );
-			qglLockArraysEXT = ( void ( APIENTRY * )( int, int ) ) qwglGetProcAddress( "glLockArraysEXT" );
-			qglUnlockArraysEXT = ( void ( APIENTRY * )( void ) ) qwglGetProcAddress( "glUnlockArraysEXT" );
-			if (!qglLockArraysEXT || !qglUnlockArraysEXT) {
-				ri.Error (ERR_FATAL, "bad getprocaddress");
-			}
+	vertexBufferObjects = qfalse;
+	qglBindBufferARB = NULL;
+	qglDeleteBuffersARB = NULL;
+	qglGenBuffersARB = NULL;
+	qglIsBufferARB = NULL;
+	qglBufferDataARB = NULL;
+	qglBufferSubDataARB = NULL;
+	qglGetBufferSubDataARB = NULL;
+	qglMapBufferARB = NULL;
+	qglUnmapBufferARB = NULL;
+	qglGetBufferParameterivARB = NULL;
+	qglGetBufferPointervARB = NULL;
+	if ( GLimp_HaveExtension( "GL_ARB_vertex_buffer_object" ) )
+	{
+		if ( r_ext_vertex_buffer_object->integer ) {
+			qglBindBufferARB = (void (APIENTRY *)(GLenum, GLuint)) SDL_GL_GetProcAddress("glBindBufferARB");
+			qglDeleteBuffersARB = (void (APIENTRY *)(GLsizei, const GLuint *)) SDL_GL_GetProcAddress("glDeleteBuffersARB");
+			qglGenBuffersARB = (void (APIENTRY *)(GLsizei, GLuint *)) SDL_GL_GetProcAddress("glGenBuffersARB");
+			qglIsBufferARB = (GLboolean (APIENTRY *)(GLuint)) SDL_GL_GetProcAddress("glIsBufferARB");
+			qglBufferDataARB = (void (APIENTRY *)(GLenum, GLsizeiptrARB, const GLvoid *, GLenum)) SDL_GL_GetProcAddress("glBufferDataARB");
+			qglBufferSubDataARB = (void (APIENTRY *)(GLenum, GLintptrARB, GLsizeiptrARB, const GLvoid *)) SDL_GL_GetProcAddress("glBufferSubDataARB");
+			qglGetBufferSubDataARB = (void (APIENTRY *)(GLenum, GLintptrARB, GLsizeiptrARB, GLvoid *)) SDL_GL_GetProcAddress("glGetBufferSubDataARB");
+			qglMapBufferARB = (GLvoid *(APIENTRY *)(GLenum, GLenum)) SDL_GL_GetProcAddress("glMapBufferARB");
+			qglUnmapBufferARB = (GLboolean (APIENTRY *)(GLenum)) SDL_GL_GetProcAddress("glUnmapBufferARB");
+			qglGetBufferParameterivARB = (void (APIENTRY *)(GLenum, GLenum, GLint *)) SDL_GL_GetProcAddress("glGetBufferParameterivARB");
+			qglGetBufferPointervARB = (void (APIENTRY *)(GLenum, GLenum, GLvoid **)) SDL_GL_GetProcAddress("glGetBufferPointervARB");
+			vertexBufferObjects = qtrue;
+			ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_vertex_buffer_object\n" );
 		}
 		else
 		{
-			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_compiled_vertex_array\n" );
+				ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_vertex_buffer_object\n" );
 		}
 	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...GL_EXT_compiled_vertex_array not found\n" );
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_vertex_buffer_object not found\n" );
 	}
 
-	// WGL_3DFX_gamma_control
-	qwglGetDeviceGammaRamp3DFX = NULL;
-	qwglSetDeviceGammaRamp3DFX = NULL;
-
-	if ( strstr( glConfig.extensions_string, "WGL_3DFX_gamma_control" ) )
+	// WGL_EXT_swap_control
+	qwglSwapIntervalEXT = ( BOOL (WINAPI *)(int)) qwglGetProcAddress( "wglSwapIntervalEXT" );
+	if ( qwglSwapIntervalEXT )
 	{
-		if ( !r_ignorehwgamma->integer && r_ext_gamma_control->integer )
+		ri.Printf( PRINT_ALL, "...using WGL_EXT_swap_control\n" );
+		r_swapInterval->modified = qtrue;	// force a set next frame
+	}
+	else
 		{
-			qwglGetDeviceGammaRamp3DFX = ( BOOL ( WINAPI * )( HDC, LPVOID ) ) qwglGetProcAddress( "wglGetDeviceGammaRamp3DFX" );
-			qwglSetDeviceGammaRamp3DFX = ( BOOL ( WINAPI * )( HDC, LPVOID ) ) qwglGetProcAddress( "wglSetDeviceGammaRamp3DFX" );
+		ri.Printf( PRINT_ALL, "...WGL_EXT_swap_control not found\n" );
+	}
+
 
-			if ( qwglGetDeviceGammaRamp3DFX && qwglSetDeviceGammaRamp3DFX )
+	// GL_EXT_compiled_vertex_array
+	if ( GLimp_HaveExtension( "GL_EXT_compiled_vertex_array" ) )
 			{
-				ri.Printf( PRINT_ALL, "...using WGL_3DFX_gamma_control\n" );
-			}
-			else
+		if ( r_ext_compiled_vertex_array->value )
 			{
-				qwglGetDeviceGammaRamp3DFX = NULL;
-				qwglSetDeviceGammaRamp3DFX = NULL;
+			ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_compiled_vertex_array\n" );
+			qglLockArraysEXT = ( void ( APIENTRY * )( GLint, GLint ) ) SDL_GL_GetProcAddress( "glLockArraysEXT" );
+			qglUnlockArraysEXT = ( void ( APIENTRY * )( void ) ) SDL_GL_GetProcAddress( "glUnlockArraysEXT" );
+			if (!qglLockArraysEXT || !qglUnlockArraysEXT)
+			{
+				ri.Error (ERR_FATAL, "bad getprocaddress");
 			}
 		}
 		else
 		{
-			ri.Printf( PRINT_ALL, "...ignoring WGL_3DFX_gamma_control\n" );
+			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_compiled_vertex_array\n" );
 		}
 	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...WGL_3DFX_gamma_control not found\n" );
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_compiled_vertex_array not found\n" );
 	}
 
 	textureFilterAnisotropic = qfalse;
-	if ( strstr( glConfig.extensions_string, "GL_EXT_texture_filter_anisotropic" ) )
+	if ( GLimp_HaveExtension( "GL_EXT_texture_filter_anisotropic" ) )
 	{
 		if ( r_ext_texture_filter_anisotropic->integer ) {
-			qglGetIntegerv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &maxAnisotropy );
+			qglGetIntegerv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, (GLint *)&maxAnisotropy );
 			if ( maxAnisotropy <= 0 ) {
-				ri.Printf( PRINT_ALL, "...GL_EXT_texture_filter_anisotropic not properly supported!\n" );
+				ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture_filter_anisotropic not properly supported!\n" );
 				maxAnisotropy = 0;
 			}
 			else
 			{
-				ri.Printf( PRINT_ALL, "...using GL_EXT_texture_filter_anisotropic (max: %i)\n", maxAnisotropy );
+				ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_texture_filter_anisotropic (max: %i)\n", maxAnisotropy );
 				textureFilterAnisotropic = qtrue;
 			}
 		}
 		else
 		{
-			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_filter_anisotropic\n" );
+			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_texture_filter_anisotropic\n" );
 		}
 	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...GL_EXT_texture_filter_anisotropic not found\n" );
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture_filter_anisotropic not found\n" );
 	}
+
+	vertexShaders = qfalse;
+	if ( GLimp_HaveExtension( "GL_ARB_shader_objects" )
+	     && GLimp_HaveExtension( "GL_ARB_fragment_shader" )
+	     && GLimp_HaveExtension( "GL_ARB_vertex_shader" )
+	     && GLimp_HaveExtension( "GL_ARB_shading_language_100" ) )
+	{
+		if ( r_ext_vertex_shader->integer ) {
+		  ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_vertex_shader\n" );
+		  
+		  qglDeleteObjectARB = (GLvoid (APIENTRY *)(GLhandleARB)) SDL_GL_GetProcAddress("glDeleteObjectARB");
+		  qglGetHandleARB = (GLhandleARB (APIENTRY *)(GLenum)) SDL_GL_GetProcAddress("glGetHandleARB");
+		  qglDetachObjectARB = (GLvoid (APIENTRY *)(GLhandleARB, GLhandleARB)) SDL_GL_GetProcAddress("glDetachObjectARB");
+		  qglCreateShaderObjectARB = (GLhandleARB (APIENTRY *)(GLenum)) SDL_GL_GetProcAddress("glCreateShaderObjectARB");
+		  qglShaderSourceARB = (GLvoid (APIENTRY *)(GLhandleARB, GLsizei, const GLcharARB **,
+							   const GLint *)) SDL_GL_GetProcAddress("glShaderSourceARB");
+		  qglCompileShaderARB = (GLvoid (APIENTRY *)(GLhandleARB)) SDL_GL_GetProcAddress("glCompileShaderARB");
+		  qglCreateProgramObjectARB = (GLhandleARB (APIENTRY *)(void)) SDL_GL_GetProcAddress("glCreateProgramObjectARB");
+		  qglAttachObjectARB = (GLvoid (APIENTRY *)(GLhandleARB, GLhandleARB)) SDL_GL_GetProcAddress("glAttachObjectARB");
+		  qglLinkProgramARB = (GLvoid (APIENTRY *)(GLhandleARB)) SDL_GL_GetProcAddress("glLinkProgramARB");
+		  qglUseProgramObjectARB = (GLvoid (APIENTRY *)(GLhandleARB)) SDL_GL_GetProcAddress("glUseProgramObjectARB");
+		  qglValidateProgramARB = (GLvoid (APIENTRY *)(GLhandleARB)) SDL_GL_GetProcAddress("glValidateProgramARB");
+		  qglUniform1fARB = (GLvoid (APIENTRY *)(GLint, GLfloat)) SDL_GL_GetProcAddress("glUniform1fARB");
+		  qglUniform2fARB = (GLvoid (APIENTRY *)(GLint, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform2fARB");
+		  qglUniform3fARB = (GLvoid (APIENTRY *)(GLint, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform3fARB");
+		  qglUniform4fARB = (GLvoid (APIENTRY *)(GLint, GLfloat, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform4fARB");
+		  qglUniform1iARB = (GLvoid (APIENTRY *)(GLint, GLint)) SDL_GL_GetProcAddress("glUniform1iARB");
+		  qglUniform2iARB = (GLvoid (APIENTRY *)(GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform2iARB");
+		  qglUniform3iARB = (GLvoid (APIENTRY *)(GLint, GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform3iARB");
+		  qglUniform4iARB = (GLvoid (APIENTRY *)(GLint, GLint, GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform4iARB");
+		  qglUniform1fvARB = (GLvoid (APIENTRY *)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform1fvARB");
+		  qglUniform2fvARB = (GLvoid (APIENTRY *)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform2fvARB");
+		  qglUniform3fvARB = (GLvoid (APIENTRY *)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform3fvARB");
+		  qglUniform4fvARB = (GLvoid (APIENTRY *)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform4fvARB");
+		  qglUniform1ivARB = (GLvoid (APIENTRY *)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform1viARB");
+		  qglUniform2ivARB = (GLvoid (APIENTRY *)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform2ivARB");
+		  qglUniform3ivARB = (GLvoid (APIENTRY *)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform3ivARB");
+		  qglUniform4ivARB = (GLvoid (APIENTRY *)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform4ivARB");
+		  qglUniformMatrix2fvARB = (GLvoid (APIENTRY *)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv2ARB");
+		  qglUniformMatrix3fvARB = (GLvoid (APIENTRY *)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv3ARB");
+		  qglUniformMatrix4fvARB = (GLvoid (APIENTRY *)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv4ARB");
+		  qglGetObjectParameterfvARB = (GLvoid (APIENTRY *)(GLhandleARB, GLenum, GLfloat *)) SDL_GL_GetProcAddress("glGetObjectParameterfvARB");
+		  qglGetObjectParameterivARB = (GLvoid (APIENTRY *)(GLhandleARB, GLenum, GLint *)) SDL_GL_GetProcAddress("glGetObjectParameterivARB");
+		  qglGetInfoLogARB = (GLvoid (APIENTRY *)(GLhandleARB, GLsizei, GLsizei *, GLcharARB *)) SDL_GL_GetProcAddress("glGetInfoLogARB");
+		  qglGetAttachedObjectsARB = (GLvoid (APIENTRY *)(GLhandleARB, GLsizei, GLsizei *, GLhandleARB *)) SDL_GL_GetProcAddress("glGetAttachedObjectsARB");
+		  qglGetUniformLocationARB = (GLint (APIENTRY *)(GLhandleARB, const GLcharARB *)) SDL_GL_GetProcAddress("glGetUniformLocationARB");
+		  qglGetActiveUniformARB = (GLvoid (APIENTRY *)(GLhandleARB, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLcharARB *)) SDL_GL_GetProcAddress("glGetActiveUniformARB");
+		  qglGetUniformfvARB = (GLvoid (APIENTRY *)(GLhandleARB, GLint, GLfloat *)) SDL_GL_GetProcAddress("glGetUniformfvARB");
+		  qglGetUniformivARB = (GLvoid (APIENTRY *)(GLhandleARB, GLint, GLint *)) SDL_GL_GetProcAddress("glGetUniformivARB");
+		  qglGetShaderSourceARB = (GLvoid (APIENTRY *)(GLhandleARB, GLsizei, GLsizei *, GLcharARB *)) SDL_GL_GetProcAddress("glGetShaderSourceARB");
+
+		  qglVertexAttrib1fARB = (GLvoid (APIENTRY *)(GLuint, GLfloat)) SDL_GL_GetProcAddress("glVertexAttrib1fARB");
+		  qglVertexAttrib1sARB = (GLvoid (APIENTRY *)(GLuint, GLshort)) SDL_GL_GetProcAddress("glVertexAttrib1sARB");
+		  qglVertexAttrib1dARB = (GLvoid (APIENTRY *)(GLuint, GLdouble)) SDL_GL_GetProcAddress("glVertexAttrib1dARB");
+		  qglVertexAttrib2fARB = (GLvoid (APIENTRY *)(GLuint, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glVertexAttrib2fARB");
+		  qglVertexAttrib2sARB = (GLvoid (APIENTRY *)(GLuint, GLshort, GLshort)) SDL_GL_GetProcAddress("glVertexAttrib2sARB");
+		  qglVertexAttrib2dARB = (GLvoid (APIENTRY *)(GLuint, GLdouble, GLdouble)) SDL_GL_GetProcAddress("glVertexAttrib2dARB");
+		  qglVertexAttrib3fARB = (GLvoid (APIENTRY *)(GLuint, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glVertexAttrib3fARB");
+		  qglVertexAttrib3sARB = (GLvoid (APIENTRY *)(GLuint, GLshort, GLshort, GLshort)) SDL_GL_GetProcAddress("glVertexAttrib3sARB");
+		  qglVertexAttrib3dARB = (GLvoid (APIENTRY *)(GLuint, GLdouble, GLdouble, GLdouble)) SDL_GL_GetProcAddress("glVertexAttrib3dARB");
+		  qglVertexAttrib4fARB = (GLvoid (APIENTRY *)(GLuint, GLfloat, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glVertexAttrib4fARB");
+		  qglVertexAttrib4sARB = (GLvoid (APIENTRY *)(GLuint, GLshort, GLshort, GLshort, GLshort)) SDL_GL_GetProcAddress("glVertexAttrib4sARB");
+		  qglVertexAttrib4dARB = (GLvoid (APIENTRY *)(GLuint, GLdouble, GLdouble, GLdouble, GLdouble)) SDL_GL_GetProcAddress("glVertexAttrib4dARB");
+		  qglVertexAttrib4NubARB = (GLvoid (APIENTRY *)(GLuint, GLubyte, GLubyte, GLubyte, GLubyte)) SDL_GL_GetProcAddress("glVertexAttrib4NubARB");
+		  qglVertexAttrib1fvARB = (GLvoid (APIENTRY *)(GLuint, GLfloat *)) SDL_GL_GetProcAddress("glVertexAttrib1fvARB");
+		  qglVertexAttrib1svARB = (GLvoid (APIENTRY *)(GLuint, GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib1svARB");
+		  qglVertexAttrib1dvARB = (GLvoid (APIENTRY *)(GLuint, GLdouble *)) SDL_GL_GetProcAddress("glVertexAttrib1dvARB");
+		  qglVertexAttrib2fvARB = (GLvoid (APIENTRY *)(GLuint, GLfloat *)) SDL_GL_GetProcAddress("glVertexAttrib2fvARB");
+		  qglVertexAttrib2svARB = (GLvoid (APIENTRY *)(GLuint, GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib2svARB");
+		  qglVertexAttrib2dvARB = (GLvoid (APIENTRY *)(GLuint, GLdouble *)) SDL_GL_GetProcAddress("glVertexAttrib2dvARB");
+		  qglVertexAttrib3fvARB = (GLvoid (APIENTRY *)(GLuint, GLfloat *)) SDL_GL_GetProcAddress("glVertexAttrib3fvARB");
+		  qglVertexAttrib3svARB = (GLvoid (APIENTRY *)(GLuint, GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib3svARB");
+		  qglVertexAttrib3dvARB = (GLvoid (APIENTRY *)(GLuint, GLdouble *)) SDL_GL_GetProcAddress("glVertexAttrib3dvARB");
+		  qglVertexAttrib4fvARB = (GLvoid (APIENTRY *)(GLuint, GLfloat *)) SDL_GL_GetProcAddress("glVertexAttrib4fvARB");
+		  qglVertexAttrib4svARB = (GLvoid (APIENTRY *)(GLuint, GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib4svARB");
+		  qglVertexAttrib4dvARB = (GLvoid (APIENTRY *)(GLuint, GLdouble *)) SDL_GL_GetProcAddress("glVertexAttrib4dvARB");
+		  qglVertexAttrib4ivARB = (GLvoid (APIENTRY *)(GLuint, GLint *)) SDL_GL_GetProcAddress("glVertexAttrib4ivARB");
+		  qglVertexAttrib4bvARB = (GLvoid (APIENTRY *)(GLuint, GLbyte *)) SDL_GL_GetProcAddress("glVertexAttrib4bvARB");
+		  qglVertexAttrib4ubvARB = (GLvoid (APIENTRY *)(GLuint, GLubyte *)) SDL_GL_GetProcAddress("glVertexAttrib4ubvARB");
+		  qglVertexAttrib4usvARB = (GLvoid (APIENTRY *)(GLuint, GLushort *)) SDL_GL_GetProcAddress("glVertexAttrib4usvARB");
+		  qglVertexAttrib4uivARB = (GLvoid (APIENTRY *)(GLuint, GLuint *)) SDL_GL_GetProcAddress("glVertexAttrib4uivARB");
+		  qglVertexAttrib4NbvARB = (GLvoid (APIENTRY *)(GLuint, const GLbyte *)) SDL_GL_GetProcAddress("glVertexAttrib4NbvARB");
+		  qglVertexAttrib4NsvARB = (GLvoid (APIENTRY *)(GLuint, const GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib4NsvARB");
+		  qglVertexAttrib4NivARB = (GLvoid (APIENTRY *)(GLuint, const GLint *)) SDL_GL_GetProcAddress("glVertexAttrib4NivARB");
+		  qglVertexAttrib4NubvARB = (GLvoid (APIENTRY *)(GLuint, const GLubyte *)) SDL_GL_GetProcAddress("glVertexAttrib4NubvARB");
+		  qglVertexAttrib4NusvARB = (GLvoid (APIENTRY *)(GLuint, const GLushort *)) SDL_GL_GetProcAddress("glVertexAttrib4NusvARB");
+		  qglVertexAttrib4NuivARB = (GLvoid (APIENTRY *)(GLuint, const GLuint *)) SDL_GL_GetProcAddress("glVertexAttrib4NuivARB");
+		  qglVertexAttribPointerARB = (GLvoid (APIENTRY *)(GLuint, GLint, GLenum, GLboolean, GLsizei, const GLvoid *)) SDL_GL_GetProcAddress("glVertexAttribPointerARB");
+		  qglEnableVertexAttribArrayARB = (GLvoid (APIENTRY *)(GLuint)) SDL_GL_GetProcAddress("glEnableVertexAttribArrayARB");
+		  qglDisableVertexAttribArrayARB = (GLvoid (APIENTRY *)(GLuint)) SDL_GL_GetProcAddress("glDisableVertexAttribArrayARB");
+		  qglBindAttribLocationARB = (GLvoid (APIENTRY *)(GLhandleARB, GLuint, const GLcharARB *)) SDL_GL_GetProcAddress("glBindAttribLocationARB");
+		  qglGetActiveAttribARB = (GLvoid (APIENTRY *)(GLhandleARB, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLcharARB *)) SDL_GL_GetProcAddress("glGetActiveAttribARB");
+		  qglGetAttribLocationARB = (GLint (APIENTRY *)(GLhandleARB, const GLcharARB *)) SDL_GL_GetProcAddress("glGetAttribLocationARB");
+		  qglGetVertexAttribdvARB = (GLvoid (APIENTRY *)(GLuint, GLenum, GLdouble *)) SDL_GL_GetProcAddress("glGetVertexAttribdvARB");
+		  qglGetVertexAttribfvARB = (GLvoid (APIENTRY *)(GLuint, GLenum, GLfloat *)) SDL_GL_GetProcAddress("glGetVertexAttribfvARB");
+		  qglGetVertexAttribivARB = (GLvoid (APIENTRY *)(GLuint, GLenum, GLint *)) SDL_GL_GetProcAddress("glGetVertexAAttribivARB");
+		  qglGetVertexAttribPointervARB = (GLvoid (APIENTRY *)(GLuint, GLenum, GLvoid **)) SDL_GL_GetProcAddress("glGetVertexAttribPointervARB");
+		  vertexShaders = qtrue;
+		}
+		else
+		{
+			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_vertex_shader\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_vertex_shader\n" );
+	}
+
+	if ( GLimp_HaveExtension( "GL_EXT_framebuffer_object" ) )
+	{
+		if ( r_ext_framebuffer_object->integer ) {
+			ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_framebuffer_object\n" );
+			qglIsRenderbufferEXT = (GLboolean (APIENTRY *) (GLuint)) SDL_GL_GetProcAddress("glIsRenderbufferEXT");
+			qglBindRenderbufferEXT = (GLvoid (APIENTRY *) (GLenum, GLuint)) SDL_GL_GetProcAddress("glBindRenderbufferEXT");
+			qglDeleteRenderbuffersEXT = (GLvoid (APIENTRY *) (GLsizei, const GLuint *)) SDL_GL_GetProcAddress("glDeleteRenderbuffersEXT");
+			qglGenRenderbuffersEXT = (GLvoid (APIENTRY *) (GLsizei, GLuint *)) SDL_GL_GetProcAddress("glGenRenderbuffersEXT");
+			qglRenderbufferStorageEXT = (GLvoid (APIENTRY *) (GLenum, GLenum,GLsizei, GLsizei)) SDL_GL_GetProcAddress("glRenderbufferStorageEXT");
+			qglGetRenderbufferParameterivEXT = (GLvoid (APIENTRY *) (GLenum, GLenum, GLint *)) SDL_GL_GetProcAddress("glGetRenderbufferParameterivEXT");
+			qglIsFramebufferEXT = (GLboolean (APIENTRY *) (GLuint)) SDL_GL_GetProcAddress("glIsFramebufferEXT");
+			qglBindFramebufferEXT = (GLvoid (APIENTRY *) (GLenum, GLuint)) SDL_GL_GetProcAddress("glBindFramebufferEXT");
+			qglDeleteFramebuffersEXT = (GLvoid (APIENTRY *) (GLsizei, const GLuint *)) SDL_GL_GetProcAddress("glDeleteFramebuffersEXT");
+			qglGenFramebuffersEXT = (GLvoid (APIENTRY *) (GLsizei, GLuint *)) SDL_GL_GetProcAddress("glGenFramebuffersEXT");
+			qglCheckFramebufferStatusEXT = (GLenum (APIENTRY *) (GLenum)) SDL_GL_GetProcAddress("glCheckFramebufferStatusEXT");
+			qglFramebufferTexture1DEXT = (GLvoid (APIENTRY *) (GLenum, GLenum, GLenum, GLuint, GLint)) SDL_GL_GetProcAddress("glFramebufferTexture1DEXT");
+			qglFramebufferTexture2DEXT = (GLvoid (APIENTRY *) (GLenum, GLenum, GLenum, GLuint, GLint)) SDL_GL_GetProcAddress("glFramebufferTexture2DEXT");
+			qglFramebufferTexture3DEXT = (GLvoid (APIENTRY *) (GLenum, GLenum, GLenum, GLuint, GLint, GLint)) SDL_GL_GetProcAddress("glFramebufferTexture3DEXT");
+			qglFramebufferRenderbufferEXT = (GLvoid (APIENTRY *) (GLenum, GLenum, GLenum, GLuint)) SDL_GL_GetProcAddress("glFramebufferRenderbufferEXT");
+			qglGetFramebufferAttachmentParameterivEXT = (GLvoid (APIENTRY *) (GLenum, GLenum, GLenum, GLint *)) SDL_GL_GetProcAddress("glGetFramebufferAttachmentParameterivEXT");
+			qglGenerateMipmapEXT = (GLvoid (APIENTRY *) (GLenum)) SDL_GL_GetProcAddress("glGenerateMipmapEXT");
+		}
+		else
+		{
+			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_framebuffer_object\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_framebuffer_object\n" );
+	}
+
+
+	qglGenQueriesARB        = (void*)SDL_GL_GetProcAddress("glGenQueriesARB");
+    qglDeleteQueriesARB     = (void*)SDL_GL_GetProcAddress("glDeleteQueriesARB");
+    qglIsQueryARB           = (void*)SDL_GL_GetProcAddress("glIsQueryARB");
+    qglBeginQueryARB        = (void*)SDL_GL_GetProcAddress("glBeginQueryARB");
+    qglEndQueryARB          = (void*)SDL_GL_GetProcAddress("glEndQueryARB");
+    qglGetQueryivARB        = (void*)SDL_GL_GetProcAddress("glGetQueryivARB");
+    qglGetQueryObjectivARB  = (void*)SDL_GL_GetProcAddress("glGetQueryObjectivARB");
+    qglGetQueryObjectuivARB = (void*)SDL_GL_GetProcAddress("glGetQueryObjectuivARB");
+
+    if( !qglGenQueriesARB       || !qglDeleteQueriesARB || !qglIsQueryARB    || 
+        !qglBeginQueryARB       || !qglEndQueryARB      || !qglGetQueryivARB ||
+        !qglGetQueryObjectivARB || !qglGetQueryObjectuivARB )
+        {
+        	ri.Printf( PRINT_DEVELOPER, "Ignoring GL_ARB_occlusion_query\n" );
+            return;
 }
+}
+
 
 /*
 ** GLW_CheckOSVersion
@@ -1250,10 +1454,6 @@
 
 		ri.Printf( PRINT_ALL, "...assuming '%s' is a standalone driver\n", drivername );
 
-		if ( strstr( buffer, _3DFX_DRIVER_NAME ) )
-		{
-			glConfig.driverType = GLDRV_VOODOO;
-		}
 	}
 
 	// disable the 3Dfx splash screen
@@ -1347,6 +1547,8 @@
 	QGL_EnableLogging( r_logFile->integer );
 }
 
+#define OPENGL_DRIVER_NAME ""
+
 static void GLW_StartOpenGL( void )
 {
 	qboolean attemptedOpenGL32 = qfalse;
@@ -1355,55 +1558,9 @@
 	//
 	// load and initialize the specific OpenGL driver
 	//
-	if ( !GLW_LoadOpenGL( r_glDriver->string ) )
+	if ( !GLW_LoadOpenGL( "opengl32" ) )
 	{
-		if ( !Q_stricmp( r_glDriver->string, OPENGL_DRIVER_NAME ) )
-		{
-			attemptedOpenGL32 = qtrue;
-		}
-		else if ( !Q_stricmp( r_glDriver->string, _3DFX_DRIVER_NAME ) )
-		{
-			attempted3Dfx = qtrue;
-		}
-
-		if ( !attempted3Dfx )
-		{
-			attempted3Dfx = qtrue;
-			if ( GLW_LoadOpenGL( _3DFX_DRIVER_NAME ) )
-			{
-				ri.Cvar_Set( "r_glDriver", _3DFX_DRIVER_NAME );
-				r_glDriver->modified = qfalse;
-			}
-			else
-			{
-				if ( !attemptedOpenGL32 )
-				{
-					if ( !GLW_LoadOpenGL( OPENGL_DRIVER_NAME ) )
-					{
-						ri.Error( ERR_FATAL, "GLW_StartOpenGL() - could not load OpenGL subsystem - get help on the official website: http://www.urbanterror.info/support/manual/faq/\n" );
-					}
-					ri.Cvar_Set( "r_glDriver", OPENGL_DRIVER_NAME );
-					r_glDriver->modified = qfalse;
-				}
-				else
-				{
-					ri.Error( ERR_FATAL, "GLW_StartOpenGL() - could not load OpenGL subsystem - get help on the official website: http://www.urbanterror.info/support/manual/faq/\n" );
-				}
-			}
-		}
-		else if ( !attemptedOpenGL32 )
-		{
-			attemptedOpenGL32 = qtrue;
-			if ( GLW_LoadOpenGL( OPENGL_DRIVER_NAME ) )
-			{
-				ri.Cvar_Set( "r_glDriver", OPENGL_DRIVER_NAME );
-				r_glDriver->modified = qfalse;
-			}
-			else
-			{
-				ri.Error( ERR_FATAL, "GLW_StartOpenGL() - could not load OpenGL subsystem - get help on the official website: http://www.urbanterror.info/support/manual/faq/\n" );
-			}
-		}
+		ri.Error( ERR_FATAL, "GLW_StartOpenGL() - could not load OpenGL subsystem\n" );
 	}
 }
 
@@ -1472,12 +1629,12 @@
 		// VOODOO GRAPHICS w/ 2MB
 		if ( strstr( buf, "voodoo graphics/1 tmu/2 mb" ) )
 		{
-			ri.Cvar_Set( "r_picmip", "2" );
-			ri.Cvar_Get( "r_picmip", "0", CVAR_ARCHIVE | CVAR_LATCH );
+			ri.Cvar_Set( "r_picmip", "1" );
+			ri.Cvar_Get( "r_picmip", "1", CVAR_ARCHIVE | CVAR_LATCH );
 		}
 		else
 		{
-			ri.Cvar_Set( "r_picmip", "0" ); //@Barbatos: defaulted to 0
+			ri.Cvar_Set( "r_picmip", "1" );
 
 			if ( strstr( buf, "rage 128" ) || strstr( buf, "rage128" ) )
 			{
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/win32/win_input.c bumpy-code/code/win32/win_input.c
--- ioq3-for-UrbanTerror-4-bumpy/code/win32/win_input.c	2014-06-09 22:09:45.577844080 -0400
+++ bumpy-code/code/win32/win_input.c	2014-06-09 22:14:52.947546129 -0400
@@ -94,8 +94,6 @@
 void IN_JoyMove(void);
 
 static void MidiInfo_f( void );
-void IN_CursorShow (void);
-void IN_CursorHide (void);
 
 /*
 ============================================================
@@ -150,11 +148,8 @@
 
 	SetCapture ( g_wv.hWnd );
 	ClipCursor (&window_rect);
-}
-
-void IN_ActivateRawMouse( void ) 
-{
-	IN_ActivateWin32Mouse();
+	while (ShowCursor (FALSE) >= 0)
+		;
 }
 
 /*
@@ -166,11 +161,8 @@
 {
 	ClipCursor (NULL);
 	ReleaseCapture ();
-}
-
-void IN_DeactivateRawMouse( void ) 
-{
-	IN_DeactivateWin32Mouse();
+	while (ShowCursor (TRUE) < 0)
+		;
 }
 
 /*
@@ -200,19 +192,12 @@
 ============================================================
 */
 
-#ifdef DEFINE_GUID
 #undef DEFINE_GUID
-#endif
-
-#ifndef DIDFT_OPTIONAL
-#define DIDFT_OPTIONAL		0x80000000
-#endif
 
 #define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
         const GUID name \
                 = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
 
-DEFINE_GUID(IID_IDirectInput8A,    0xBF798030,0x483A,0x4DA2,0xAA,0x99,0x5D,0x64,0xED,0x36,0x97,0x00);
 DEFINE_GUID(GUID_SysMouse,   0x6F1D2B60,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
 DEFINE_GUID(GUID_XAxis,   0xA36D02E0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
 DEFINE_GUID(GUID_YAxis,   0xA36D02E1,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
@@ -220,10 +205,10 @@
 
 
 #define DINPUT_BUFFERSIZE           16
-#define iDirectInput8Create(a,b,c,d,e)	pDirectInput8Create(a,b,c,d,e)
-HRESULT (WINAPI *pDirectInput8Create)(HINSTANCE hinst, DWORD dwVersion, 
-									  REFIID riidltf, LPVOID *ppvOut, 
-									  LPUNKNOWN punkOuter);
+#define iDirectInputCreate(a,b,c,d)	pDirectInputCreate(a,b,c,d)
+
+HRESULT (WINAPI *pDirectInputCreate)(HINSTANCE hinst, DWORD dwVersion,
+	LPDIRECTINPUT * lplpDirectInput, LPUNKNOWN punkOuter);
 
 static HINSTANCE hInstDI;
 
@@ -231,28 +216,20 @@
 	LONG  lX;                   // X axis goes here
 	LONG  lY;                   // Y axis goes here
 	LONG  lZ;                   // Z axis goes here
-	BYTE  bButton1;             // One button goes here
-	BYTE  bButton2;             // Another button goes here
-	BYTE  bButton3;             // Another button goes here
-	BYTE  bButton4;             // Another button goes here
-	BYTE  bButton5;             // One button goes here
-	BYTE  bButton6;             // Another button goes here
-	BYTE  bButton7;             // Another button goes here
-	BYTE  bButton8;             // Another button goes here
+	BYTE  bButtonA;             // One button goes here
+	BYTE  bButtonB;             // Another button goes here
+	BYTE  bButtonC;             // Another button goes here
+	BYTE  bButtonD;             // Another button goes here
 } MYDATA;
 
 static DIOBJECTDATAFORMAT rgodf[] = {
   { &GUID_XAxis,    FIELD_OFFSET(MYDATA, lX),       DIDFT_AXIS | DIDFT_ANYINSTANCE,   0,},
   { &GUID_YAxis,    FIELD_OFFSET(MYDATA, lY),       DIDFT_AXIS | DIDFT_ANYINSTANCE,   0,},
-  { &GUID_ZAxis,    FIELD_OFFSET(MYDATA, lZ),       DIDFT_OPTIONAL | DIDFT_AXIS | DIDFT_ANYINSTANCE,   0,},
-  { 0,              FIELD_OFFSET(MYDATA, bButton1), DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
-  { 0,              FIELD_OFFSET(MYDATA, bButton2), DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
-  { 0,              FIELD_OFFSET(MYDATA, bButton3), DIDFT_OPTIONAL | DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
-  { 0,              FIELD_OFFSET(MYDATA, bButton4), DIDFT_OPTIONAL | DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
-  { 0,              FIELD_OFFSET(MYDATA, bButton5), DIDFT_OPTIONAL | DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
-  { 0,              FIELD_OFFSET(MYDATA, bButton6), DIDFT_OPTIONAL | DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
-  { 0,              FIELD_OFFSET(MYDATA, bButton7), DIDFT_OPTIONAL | DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
-  { 0,              FIELD_OFFSET(MYDATA, bButton8), DIDFT_OPTIONAL | DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
+  { &GUID_ZAxis,    FIELD_OFFSET(MYDATA, lZ),       0x80000000 | DIDFT_AXIS | DIDFT_ANYINSTANCE,   0,},
+  { 0,              FIELD_OFFSET(MYDATA, bButtonA), DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
+  { 0,              FIELD_OFFSET(MYDATA, bButtonB), DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
+  { 0,              FIELD_OFFSET(MYDATA, bButtonC), 0x80000000 | DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
+  { 0,              FIELD_OFFSET(MYDATA, bButtonD), 0x80000000 | DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
 };
 
 #define NUM_OBJECTS (sizeof(rgodf) / sizeof(rgodf[0]))
@@ -267,35 +244,11 @@
 	rgodf,                      // and here they are
 };
 
-static LPDIRECTINPUT8A			g_pdi;
-static LPDIRECTINPUTDEVICE8A	g_pMouse;
+static LPDIRECTINPUT		g_pdi;
+static LPDIRECTINPUTDEVICE	g_pMouse;
 
 void IN_DIMouse( int *mx, int *my );
 
-
-
-/**
- * Show windows cursor.
- */
-void IN_CursorShow (void)
-{
-	while (ShowCursor(TRUE) < 0)
-		;
-}
-
-
-
-/**
- * Hide windows cursor.
- */
-void IN_CursorHide (void)
-{
-	while (ShowCursor(FALSE) >= 0)
-		;
-}
-
-
-
 /*
 ========================
 IN_InitDIMouse
@@ -317,27 +270,26 @@
 	Com_DPrintf( "Initializing DirectInput...\n");
 
 	if (!hInstDI) {
-		hInstDI = LoadLibrary("dinput8.dll");
+		hInstDI = LoadLibrary("dinput.dll");
 		
 		if (hInstDI == NULL) {
-			Com_DPrintf ("Couldn't load dinput8.dll\n");
+			Com_DPrintf ("Couldn't load dinput.dll\n");
 			return qfalse;
 		}
 	}
 
-	if (!pDirectInput8Create) {
-		pDirectInput8Create = 
-			(HRESULT (WINAPI *)(HINSTANCE, DWORD, REFIID, LPVOID *, LPUNKNOWN ))
-			GetProcAddress(hInstDI,"DirectInput8Create");
+	if (!pDirectInputCreate) {
+		pDirectInputCreate = (HRESULT (WINAPI *)(HINSTANCE, DWORD, LPDIRECTINPUT *, LPUNKNOWN))
+			GetProcAddress(hInstDI,"DirectInputCreateA");
 
-		if (!pDirectInput8Create) {
-			Com_DPrintf ("Couldn't get DI8 proc addr\n");
+		if (!pDirectInputCreate) {
+			Com_DPrintf ("Couldn't get DI proc addr\n");
 			return qfalse;
 		}
 	}
 
-	// register with DirectInput8 and get an IDirectInput8 to play with.
-	hr = iDirectInput8Create( g_wv.hInstance, DIRECTINPUT_VERSION, &IID_IDirectInput8A, (void**)&g_pdi, NULL);
+	// register with DirectInput and get an IDirectInput to play with.
+	hr = iDirectInputCreate( g_wv.hInstance, DIRECTINPUT_VERSION, &g_pdi, NULL);
 
 	if (FAILED(hr)) {
 		Com_DPrintf ("iDirectInputCreate failed\n");
@@ -345,7 +297,7 @@
 	}
 
 	// obtain an interface to the system mouse device.
-	hr = IDirectInput8_CreateDevice(g_pdi, &GUID_SysMouse, &g_pMouse, NULL);
+	hr = IDirectInput_CreateDevice(g_pdi, &GUID_SysMouse, &g_pMouse, NULL);
 
 	if (FAILED(hr)) {
 		Com_DPrintf ("Couldn't open DI mouse device\n");
@@ -353,7 +305,7 @@
 	}
 
 	// set the data format to "mouse format".
-	hr = IDirectInputDevice8_SetDataFormat(g_pMouse, &df);
+	hr = IDirectInputDevice_SetDataFormat(g_pMouse, &df);
 
 	if (FAILED(hr)) 	{
 		Com_DPrintf ("Couldn't set DI mouse format\n");
@@ -361,7 +313,7 @@
 	}
 
 	// set the cooperativity level.
-	hr = IDirectInputDevice8_SetCooperativeLevel(g_pMouse, g_wv.hWnd,
+	hr = IDirectInputDevice_SetCooperativeLevel(g_pMouse, g_wv.hWnd,
 			DISCL_EXCLUSIVE | DISCL_FOREGROUND);
 
 	// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=50
@@ -373,7 +325,7 @@
 
 	// set the buffer size to DINPUT_BUFFERSIZE elements.
 	// the buffer size is a DWORD property associated with the device
-	hr = IDirectInputDevice8_SetProperty(g_pMouse, DIPROP_BUFFERSIZE, &dipdw.diph);
+	hr = IDirectInputDevice_SetProperty(g_pMouse, DIPROP_BUFFERSIZE, &dipdw.diph);
 
 	if (FAILED(hr)) {
 		Com_DPrintf ("Couldn't set DI buffersize\n");
@@ -395,12 +347,12 @@
 */
 void IN_ShutdownDIMouse( void ) {
     if (g_pMouse) {
-		IDirectInputDevice8_Release(g_pMouse);
+		IDirectInputDevice_Release(g_pMouse);
 		g_pMouse = NULL;
 	}
 
     if (g_pdi) {
-		IDirectInput8_Release(g_pdi);
+		IDirectInput_Release(g_pdi);
 		g_pdi = NULL;
 	}
 }
@@ -418,7 +370,7 @@
 	}
 
 	// we may fail to reacquire if the window has been recreated
-	hr = IDirectInputDevice8_Acquire( g_pMouse );
+	hr = IDirectInputDevice_Acquire( g_pMouse );
 	if (FAILED(hr)) {
 		if ( !IN_InitDIMouse() ) {
 			Com_Printf ("Falling back to Win32 mouse support...\n");
@@ -432,10 +384,11 @@
 IN_DeactivateDIMouse
 ==========================
 */
-void IN_DeactivateDIMouse( void ) 
-{
-	if (!g_pMouse) return;
-	IDirectInputDevice8_Unacquire( g_pMouse );
+void IN_DeactivateDIMouse( void ) {
+	if (!g_pMouse) {
+		return;
+	}
+	IDirectInputDevice_Unacquire( g_pMouse );
 }
 
 
@@ -460,10 +413,10 @@
 	{
 		dwElements = 1;
 
-		hr = IDirectInputDevice8_GetDeviceData(g_pMouse,
+		hr = IDirectInputDevice_GetDeviceData(g_pMouse,
 				sizeof(DIDEVICEOBJECTDATA), &od, &dwElements, 0);
 		if ((hr == DIERR_INPUTLOST) || (hr == DIERR_NOTACQUIRED)) {
-			IDirectInputDevice8_Acquire(g_pMouse);
+			IDirectInputDevice_Acquire(g_pMouse);
 			return;
 		}
 
@@ -504,30 +457,6 @@
 			else
 				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_MOUSE4, qfalse, 0, NULL );
 			break;      
-		case DIMOFS_BUTTON4:
-			if (od.dwData & 0x80)
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_MOUSE5, qtrue, 0, NULL );
-			else
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_MOUSE5, qfalse, 0, NULL );
-			break;      
-		case DIMOFS_BUTTON5:
-			if (od.dwData & 0x80)
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_AUX1, qtrue, 0, NULL );
-			else
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_AUX1, qfalse, 0, NULL );
-			break;      
-		case DIMOFS_BUTTON6:
-			if (od.dwData & 0x80)
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_AUX2, qtrue, 0, NULL );
-			else
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_AUX2, qfalse, 0, NULL );
-			break;      
-		case DIMOFS_BUTTON7:
-			if (od.dwData & 0x80)
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_AUX3, qtrue, 0, NULL );
-			else
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_AUX3, qfalse, 0, NULL );
-			break;      
     // https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=50
 		case DIMOFS_Z:
 			value = od.dwData;
@@ -546,7 +475,7 @@
 
 	// read the raw delta counter and ignore
 	// the individual sample time / values
-	hr = IDirectInputDevice8_GetDeviceState(g_pMouse,
+	hr = IDirectInputDevice_GetDeviceState(g_pMouse,
 			sizeof(DIDEVICEOBJECTDATA), &state);
 	if ( FAILED(hr) ) {
 		*mx = *my = 0;
@@ -573,23 +502,25 @@
 */
 void IN_ActivateMouse( void ) 
 {
-	if (!s_wmv.mouseInitialized) return;
-	if (s_wmv.mouseActive) return;
-	if (in_mouse->integer == 0)
+	if (!s_wmv.mouseInitialized ) {
+		return;
+	}
+	if ( !in_mouse->integer ) 
 	{
 		s_wmv.mouseActive = qfalse;
 		return;
 	}
-	s_wmv.mouseActive = qtrue;
+	if ( s_wmv.mouseActive ) 
+	{
+		return;
+	}
 
-	// RAW WM_INPUT
-	if (in_mouse->integer == 2) IN_ActivateRawMouse();
-	// DirectInput
-	else if (in_mouse->integer == 1) IN_ActivateDIMouse();
-	// Win32 WM_ messages
-	else if (in_mouse->integer == -1) IN_ActivateWin32Mouse();
+	s_wmv.mouseActive = qtrue;
 	
-	IN_CursorHide();
+	if ( in_mouse->integer != -1 ) {
+		IN_ActivateDIMouse();
+	}
+	IN_ActivateWin32Mouse();
 }
 
 
@@ -601,14 +532,16 @@
 ===========
 */
 void IN_DeactivateMouse( void ) {
-	if (!s_wmv.mouseInitialized) return;
-	if (!s_wmv.mouseActive) return;
+	if (!s_wmv.mouseInitialized ) {
+		return;
+	}
+	if (!s_wmv.mouseActive ) {
+		return;
+	}
 	s_wmv.mouseActive = qfalse;
 
 	IN_DeactivateDIMouse();
 	IN_DeactivateWin32Mouse();
-	IN_DeactivateRawMouse();
-	IN_CursorShow();
 }
 
 
@@ -623,8 +556,7 @@
 	s_wmv.mouseInitialized = qfalse;
 	s_wmv.mouseStartupDelayed = qfalse;
 
-	if (in_mouse->integer == 0) 
-	{
+	if ( in_mouse->integer == 0 ) {
 		Com_DPrintf ("Mouse control not active.\n");
 		return;
 	}
@@ -637,26 +569,16 @@
 		Cvar_Set( "in_mouse", "-1" );
 	}
 
-	if (in_mouse->integer == 2)
-	{
-		Com_DPrintf ("Using RAW mouse input.\n");
-		s_wmv.mouseInitialized = qtrue;
-		return;
-	}
-	else if (in_mouse->integer == -1)
-	{
+	if ( in_mouse->integer == -1 ) {
 		Com_DPrintf ("Skipping check for DirectInput\n");
-	}
-	else 
-	{
+	} else {
 		if (!g_wv.hWnd)
 		{
 			Com_DPrintf ("No window for DirectInput mouse init, delaying\n");
 			s_wmv.mouseStartupDelayed = qtrue;
 			return;
 		}
-		if (IN_InitDIMouse()) 
-		{
+		if ( IN_InitDIMouse() ) {
 			s_wmv.mouseInitialized = qtrue;
 			return;
 		}
@@ -675,16 +597,20 @@
 {
 	int i;
 
-	if (!s_wmv.mouseInitialized) return;
+	if ( !s_wmv.mouseInitialized )
+		return;
 
 	// perform button actions
-	for (i = 0 ; i < 8; i++)
+	for  (i = 0 ; i < 3 ; i++ )
 	{
-		if ((mstate & (1 << i)) && !(s_wmv.oldButtonState & (1 << i)))
+		if ( (mstate & (1<<i)) &&
+			!(s_wmv.oldButtonState & (1<<i)) )
 		{
 			Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MOUSE1 + i, qtrue, 0, NULL);
 		}
-		if (!(mstate & (1 << i)) && (s_wmv.oldButtonState & (1 << i)))
+
+		if ( !(mstate & (1<<i)) &&
+			(s_wmv.oldButtonState & (1<<i)) )
 		{
 			Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MOUSE1 + i, qfalse, 0, NULL);
 		}
@@ -699,16 +625,12 @@
 IN_MouseMove
 ===========
 */
-void IN_MouseMove ( void ) 
-{
+void IN_MouseMove ( void ) {
 	int mx, my;
 
-	if (g_pMouse) 
-	{
+	if ( g_pMouse ) {
 		IN_DIMouse( &mx, &my );
-	}
-	else 
-	{
+	} else {
 		IN_Win32Mouse( &mx, &my );
 	}
 
@@ -825,11 +747,15 @@
 	}
 
 	if ( cls.keyCatchers & KEYCATCH_CONSOLE ) {
-		if ( Cvar_VariableValue ("r_fullscreen") == 0 )	{
+		// temporarily deactivate if not in the game and
+		// running on the desktop
+		// voodoo always counts as full screen
+		if (Cvar_VariableValue ("r_fullscreen") == 0
+			/*&& strcmp( Cvar_VariableString("r_glDriver"), _3DFX_DRIVER_NAME)*/ )	{
 			IN_DeactivateMouse();
-		}
 		return;
 	}
+	}
 
 	if ( !in_appactive ) {
 		IN_DeactivateMouse ();
@@ -838,12 +764,8 @@
 
 	IN_ActivateMouse();
 
-	// IF not RAW
-	if (in_mouse->integer != 2)
-	{
 		// post events to the system que
 		IN_MouseMove();
-	}
 
 }
 
@@ -1225,105 +1147,3 @@
 	Com_Memset( &s_midiInfo, 0, sizeof( s_midiInfo ) );
 }
 
-void IN_InitRawMouseInput(HANDLE hWnd)
-{
-#ifndef HID_USAGE_PAGE_GENERIC
-#define HID_USAGE_PAGE_GENERIC         ((USHORT) 0x01)
-#endif
-#ifndef HID_USAGE_GENERIC_MOUSE
-#define HID_USAGE_GENERIC_MOUSE        ((USHORT) 0x02)
-#endif
-
-	RAWINPUTDEVICE Rid[1];
-	Rid[0].usUsagePage = HID_USAGE_PAGE_GENERIC;
-	Rid[0].usUsage = HID_USAGE_GENERIC_MOUSE;
-	Rid[0].dwFlags = 0;//RIDEV_NOLEGACY;
-	Rid[0].hwndTarget = hWnd;
-	RegisterRawInputDevices(Rid, 1, sizeof(Rid[0]));
-	
-	Com_DPrintf ("RAW mouse input registered.\n");
-}
-
-void IN_HandleRawMouseData(HRAWINPUT hndlmouse)
-{
-	static BYTE* lpbuf = NULL;
-	static UINT ilpbufsize = 0;
-	UINT dwSize;
-	RAWINPUT* raw;
-
-	// even in raw mouse mode, it is necessary to keep warping the pointer to the center to avoid the mouse sliding out in windowed mode
-	if ((cls.keyCatchers & KEYCATCH_CONSOLE) != KEYCATCH_CONSOLE) SetCursorPos(window_center_x, window_center_y);
-	
-	if (GetRawInputData(hndlmouse, RID_INPUT, NULL, &dwSize, sizeof(RAWINPUTHEADER)) == (UINT)-1)
-	{
-		Com_DPrintf("Could not get RAW mouse data buffer size.");
-		return;
-	}
-
-	if (dwSize > ilpbufsize)
-	{
-		if (lpbuf != NULL) Z_Free(lpbuf);
-		lpbuf = Z_Malloc(dwSize);
-		ilpbufsize = dwSize;
-	}
-
-	if (GetRawInputData(hndlmouse, RID_INPUT, lpbuf, &dwSize, sizeof(RAWINPUTHEADER)) != dwSize)
-	{
-		Com_DPrintf("Could not get RAW mouse data.");
-		return;
-	}
-
-	raw = (RAWINPUT*)lpbuf;
-
-	if (raw->header.dwType != RIM_TYPEMOUSE) return;
-
-	// movement
-	if (raw->data.mouse.usFlags & MOUSE_MOVE_ABSOLUTE)
-	{
-		Com_DPrintf("Absolute mouse data not supported.");
-	}
-	else if ((cls.keyCatchers & KEYCATCH_CONSOLE) != KEYCATCH_CONSOLE)
-	{
-		if (raw->data.mouse.lLastX != 0 || raw->data.mouse.lLastY != 0)
-		{
-			Sys_QueEvent( 0, SE_MOUSE, raw->data.mouse.lLastX, raw->data.mouse.lLastY, 0, NULL );
-		}
-	}
-
-
-	// Buttons
-	if (raw->data.mouse.usButtonFlags & RI_MOUSE_BUTTON_1_DOWN)
-		Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MOUSE1, qtrue, 0, NULL);
-	if (raw->data.mouse.usButtonFlags & RI_MOUSE_BUTTON_1_UP) 
-		Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MOUSE1, qfalse, 0, NULL);
-	if (raw->data.mouse.usButtonFlags & RI_MOUSE_BUTTON_2_DOWN)
-		Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MOUSE2, qtrue, 0, NULL);
-	if (raw->data.mouse.usButtonFlags & RI_MOUSE_BUTTON_2_UP) 
-		Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MOUSE2, qfalse, 0, NULL);
-	if (raw->data.mouse.usButtonFlags & RI_MOUSE_BUTTON_3_DOWN)
-		Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MOUSE3, qtrue, 0, NULL);
-	if (raw->data.mouse.usButtonFlags & RI_MOUSE_BUTTON_3_UP) 
-		Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MOUSE3, qfalse, 0, NULL);
-	if (raw->data.mouse.usButtonFlags & RI_MOUSE_BUTTON_4_DOWN)
-		Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MOUSE4, qtrue, 0, NULL);
-	if (raw->data.mouse.usButtonFlags & RI_MOUSE_BUTTON_4_UP) 
-		Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MOUSE4, qfalse, 0, NULL);
-	if (raw->data.mouse.usButtonFlags & RI_MOUSE_BUTTON_5_DOWN)
-		Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MOUSE5, qtrue, 0, NULL);
-	if (raw->data.mouse.usButtonFlags & RI_MOUSE_BUTTON_5_UP) 
-		Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MOUSE5, qfalse, 0, NULL);
-		
-	if (raw->data.mouse.usButtonFlags & RI_MOUSE_WHEEL)
-	{
-		if ( (short)raw->data.mouse.usButtonData > 0 )
-		{
-			Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MWHEELUP, qtrue, 0, NULL);
-			Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MWHEELUP, qfalse, 0, NULL);
-		}
-		else if ( (short)raw->data.mouse.usButtonData < 0 )
-		{
-			Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MWHEELDOWN, qtrue, 0, NULL);
-			Sys_QueEvent(g_wv.sysMsgTime, SE_KEY, K_MWHEELDOWN, qfalse, 0, NULL);
-		}
-	}
-}
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/win32/win_local.h bumpy-code/code/win32/win_local.h
--- ioq3-for-UrbanTerror-4-bumpy/code/win32/win_local.h	2014-06-09 22:09:45.577844080 -0400
+++ bumpy-code/code/win32/win_local.h	2014-06-09 22:14:52.947546129 -0400
@@ -31,7 +31,7 @@
 #endif
 
 #define	DIRECTSOUND_VERSION	0x0300
-#define	DIRECTINPUT_VERSION	0x0800
+#define	DIRECTINPUT_VERSION	0x0300
 
 #include <dinput.h>
 #include <dsound.h>
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/win32/win_main.c bumpy-code/code/win32/win_main.c
--- ioq3-for-UrbanTerror-4-bumpy/code/win32/win_main.c	2014-06-09 22:09:45.577844080 -0400
+++ bumpy-code/code/win32/win_main.c	2014-06-09 22:14:52.947546129 -0400
@@ -410,7 +338,7 @@
 	}
 
 	do {
-		if ( (!wantsubs && (flag ^ ( findinfo.attrib & _A_SUBDIR ))) || (wantsubs && (findinfo.attrib & _A_SUBDIR)) ) {
+		if ( (!wantsubs && flag ^ ( findinfo.attrib & _A_SUBDIR )) || (wantsubs && findinfo.attrib & _A_SUBDIR) ) {
 			if ( nfiles == MAX_FOUND_FILES - 1 ) {
 				break;
 			}
@@ -979,22 +907,16 @@
 ================
 */
 void Sys_QueEvent( int time, sysEventType_t type, int value, int value2, int ptrLength, void *ptr ) {
-	static qboolean silence_overflow_spam = qfalse;   
 	sysEvent_t	*ev;
 
 	ev = &eventQue[ eventHead & MASK_QUED_EVENTS ];
 	if ( eventHead - eventTail >= MAX_QUED_EVENTS ) {
-		if ( !silence_overflow_spam ) {
 			Com_Printf("Sys_QueEvent: overflow\n");
-			silence_overflow_spam = qtrue;
-                }
 		// we are discarding an event, but don't leak memory
 		if ( ev->evPtr ) {
 			Z_Free( ev->evPtr );
 		}
 		eventTail++;
-	} else {
-		silence_overflow_spam = qfalse;
         }
 
 	eventHead++;
@@ -1274,9 +1090,7 @@
 
 	// save out a couple things in rom cvars for the renderer to access
 	Cvar_Get( "win_hinstance", va("%i", (int)g_wv.hInstance), CVAR_ROM );
-#ifndef DEDICATED
 	Cvar_Get( "win_wndproc", va("%i", (int)MainWndProc), CVAR_ROM );
-#endif
 
 	//
 	// figure out our CPU
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/win32/win_qgl.c bumpy-code/code/win32/win_qgl.c
--- ioq3-for-UrbanTerror-4-bumpy/code/win32/win_qgl.c	2014-06-09 22:09:45.577844080 -0400
+++ bumpy-code/code/win32/win_qgl.c	2014-06-09 22:14:52.947546129 -0400
@@ -32,41 +32,42 @@
 #include <float.h>
 #include "../renderer/tr_local.h"
 #include "glw_win.h"
+#include <GL/gl.h>
 
 void QGL_EnableLogging( qboolean enable );
 
-int ( WINAPI * qwglSwapIntervalEXT)( int interval );
-BOOL  ( WINAPI * qwglGetDeviceGammaRamp3DFX)( HDC, LPVOID );
-BOOL  ( WINAPI * qwglSetDeviceGammaRamp3DFX)( HDC, LPVOID );
-
-int   ( WINAPI * qwglChoosePixelFormat )(HDC, CONST PIXELFORMATDESCRIPTOR *);
-int   ( WINAPI * qwglDescribePixelFormat) (HDC, int, UINT, LPPIXELFORMATDESCRIPTOR);
-int   ( WINAPI * qwglGetPixelFormat)(HDC);
-BOOL  ( WINAPI * qwglSetPixelFormat)(HDC, int, CONST PIXELFORMATDESCRIPTOR *);
-BOOL  ( WINAPI * qwglSwapBuffers)(HDC);
-
-BOOL  ( WINAPI * qwglCopyContext)(HGLRC, HGLRC, UINT);
-HGLRC ( WINAPI * qwglCreateContext)(HDC);
-HGLRC ( WINAPI * qwglCreateLayerContext)(HDC, int);
-BOOL  ( WINAPI * qwglDeleteContext)(HGLRC);
-HGLRC ( WINAPI * qwglGetCurrentContext)(VOID);
-HDC   ( WINAPI * qwglGetCurrentDC)(VOID);
-PROC  ( WINAPI * qwglGetProcAddress)(LPCSTR);
-BOOL  ( WINAPI * qwglMakeCurrent)(HDC, HGLRC);
-BOOL  ( WINAPI * qwglShareLists)(HGLRC, HGLRC);
-BOOL  ( WINAPI * qwglUseFontBitmaps)(HDC, DWORD, DWORD, DWORD);
+int ( APIENTRY * qwglSwapIntervalEXT)( int interval );
+BOOL  ( APIENTRY * qwglGetDeviceGammaRamp3DFX)( HDC, LPVOID );
+BOOL  ( APIENTRY * qwglSetDeviceGammaRamp3DFX)( HDC, LPVOID );
+
+int   ( APIENTRY * qwglChoosePixelFormat )(HDC, CONST PIXELFORMATDESCRIPTOR *);
+int   ( APIENTRY * qwglDescribePixelFormat) (HDC, int, UINT, LPPIXELFORMATDESCRIPTOR);
+int   ( APIENTRY * qwglGetPixelFormat)(HDC);
+BOOL  ( APIENTRY * qwglSetPixelFormat)(HDC, int, CONST PIXELFORMATDESCRIPTOR *);
+BOOL  ( APIENTRY * qwglSwapBuffers)(HDC);
+
+BOOL  ( APIENTRY * qwglCopyContext)(HGLRC, HGLRC, UINT);
+HGLRC ( APIENTRY * qwglCreateContext)(HDC);
+HGLRC ( APIENTRY * qwglCreateLayerContext)(HDC, int);
+BOOL  ( APIENTRY * qwglDeleteContext)(HGLRC);
+HGLRC ( APIENTRY * qwglGetCurrentContext)(VOID);
+HDC   ( APIENTRY * qwglGetCurrentDC)(VOID);
+PROC  ( APIENTRY * qwglGetProcAddress)(LPCSTR);
+BOOL  ( APIENTRY * qwglMakeCurrent)(HDC, HGLRC);
+BOOL  ( APIENTRY * qwglShareLists)(HGLRC, HGLRC);
+BOOL  ( APIENTRY * qwglUseFontBitmaps)(HDC, DWORD, DWORD, DWORD);
 
-BOOL  ( WINAPI * qwglUseFontOutlines)(HDC, DWORD, DWORD, DWORD, FLOAT,
+BOOL  ( APIENTRY * qwglUseFontOutlines)(HDC, DWORD, DWORD, DWORD, FLOAT,
                                            FLOAT, int, LPGLYPHMETRICSFLOAT);
 
-BOOL ( WINAPI * qwglDescribeLayerPlane)(HDC, int, int, UINT,
+BOOL ( APIENTRY * qwglDescribeLayerPlane)(HDC, int, int, UINT,
                                             LPLAYERPLANEDESCRIPTOR);
-int  ( WINAPI * qwglSetLayerPaletteEntries)(HDC, int, int, int,
+int  ( APIENTRY * qwglSetLayerPaletteEntries)(HDC, int, int, int,
                                                 CONST COLORREF *);
-int  ( WINAPI * qwglGetLayerPaletteEntries)(HDC, int, int, int,
+int  ( APIENTRY * qwglGetLayerPaletteEntries)(HDC, int, int, int,
                                                 COLORREF *);
-BOOL ( WINAPI * qwglRealizeLayerPalette)(HDC, int, BOOL);
-BOOL ( WINAPI * qwglSwapLayerBuffers)(HDC, UINT);
+BOOL ( APIENTRY * qwglRealizeLayerPalette)(HDC, int, BOOL);
+BOOL ( APIENTRY * qwglSwapLayerBuffers)(HDC, UINT);
 
 void ( APIENTRY * qglAccum )(GLenum op, GLfloat value);
 void ( APIENTRY * qglAlphaFunc )(GLenum func, GLclampf ref);
@@ -405,12 +406,7 @@
 void ( APIENTRY * qglVertexPointer )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
 void ( APIENTRY * qglViewport )(GLint x, GLint y, GLsizei width, GLsizei height);
 
-void ( APIENTRY * qglMultiTexCoord2fARB )( GLenum texture, GLfloat s, GLfloat t );
-void ( APIENTRY * qglActiveTextureARB )( GLenum texture );
-void ( APIENTRY * qglClientActiveTextureARB )( GLenum texture );
 
-void ( APIENTRY * qglLockArraysEXT)( GLint, GLint);
-void ( APIENTRY * qglUnlockArraysEXT) ( void );
 
 
 static void ( APIENTRY * dllAccum )(GLenum op, GLfloat value);
@@ -750,6 +746,165 @@
 static void ( APIENTRY * dllVertexPointer )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
 static void ( APIENTRY * dllViewport )(GLint x, GLint y, GLsizei width, GLsizei height);
 
+
+//Courtesty of sdl_glimp.h
+
+void (APIENTRY * qglDrawRangeElementsEXT) (GLenum mode, GLsizei count, GLuint start, GLuint end, GLenum type, const GLvoid *indices);
+
+void (APIENTRY * qglActiveTextureARB) (GLenum texture);
+void (APIENTRY * qglClientActiveTextureARB) (GLenum texture);
+void (APIENTRY * qglMultiTexCoord2fARB) (GLenum target, GLfloat s, GLfloat t);
+
+void (APIENTRY * qglLockArraysEXT) (GLint first, GLsizei count);
+void (APIENTRY * qglUnlockArraysEXT) (void);
+
+void (APIENTRY * qglBindBufferARB) (GLenum target, GLuint buffer);
+void (APIENTRY * qglDeleteBuffersARB) (GLsizei n, const GLuint * buffers);
+void (APIENTRY * qglGenBuffersARB) (GLsizei n, GLuint * buffers);
+GLboolean (APIENTRY * qglIsBufferARB) (GLuint buffer);
+void (APIENTRY * qglBufferDataARB) (GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage);
+void (APIENTRY * qglBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data);
+void (APIENTRY * qglGetBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid * data);
+GLvoid *(APIENTRY * qglMapBufferARB) (GLenum target, GLenum access);
+GLboolean (APIENTRY * qglUnmapBufferARB) (GLenum target);
+void (APIENTRY * qglGetBufferParameterivARB) (GLenum target, GLenum pname, GLint * params);
+void (APIENTRY * qglGetBufferPointervARB) (GLenum target, GLenum pname, GLvoid * *params);
+
+// GL_ARB_shader_objects
+GLvoid (APIENTRY * qglDeleteObjectARB) (GLhandleARB obj);
+GLhandleARB (APIENTRY * qglGetHandleARB) (GLenum pname);
+GLvoid (APIENTRY * qglDetachObjectARB) (GLhandleARB containerObj, GLhandleARB attachedObj);
+GLhandleARB (APIENTRY * qglCreateShaderObjectARB) (GLenum shaderType);
+GLvoid (APIENTRY * qglShaderSourceARB) (GLhandleARB shaderObj, GLsizei count, const GLcharARB **string,
+				       const GLint *length);
+GLvoid (APIENTRY * qglCompileShaderARB) (GLhandleARB shaderObj);
+GLhandleARB (APIENTRY * qglCreateProgramObjectARB) (void);
+GLvoid (APIENTRY * qglAttachObjectARB) (GLhandleARB containerObj, GLhandleARB obj);
+GLvoid (APIENTRY * qglLinkProgramARB) (GLhandleARB programObj);
+GLvoid (APIENTRY * qglUseProgramObjectARB) (GLhandleARB programObj);
+GLvoid (APIENTRY * qglValidateProgramARB) (GLhandleARB programObj);
+GLvoid (APIENTRY * qglUniform1fARB) (GLint location, GLfloat v0);
+GLvoid (APIENTRY * qglUniform2fARB) (GLint location, GLfloat v0, GLfloat v1);
+GLvoid (APIENTRY * qglUniform3fARB) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+GLvoid (APIENTRY * qglUniform4fARB) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+GLvoid (APIENTRY * qglUniform1iARB) (GLint location, GLint v0);
+GLvoid (APIENTRY * qglUniform2iARB) (GLint location, GLint v0, GLint v1);
+GLvoid (APIENTRY * qglUniform3iARB) (GLint location, GLint v0, GLint v1, GLint v2);
+GLvoid (APIENTRY * qglUniform4iARB) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+GLvoid (APIENTRY * qglUniform1fvARB) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRY * qglUniform2fvARB) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRY * qglUniform3fvARB) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRY * qglUniform4fvARB) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRY * qglUniform1ivARB) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRY * qglUniform2ivARB) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRY * qglUniform3ivARB) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRY * qglUniform4ivARB) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRY * qglUniformMatrix2fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+GLvoid (APIENTRY * qglUniformMatrix3fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+GLvoid (APIENTRY * qglUniformMatrix4fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+GLvoid (APIENTRY * qglGetObjectParameterfvARB) (GLhandleARB obj, GLenum pname, GLfloat *params);
+GLvoid (APIENTRY * qglGetObjectParameterivARB) (GLhandleARB obj, GLenum pname, GLint *params);
+GLvoid (APIENTRY * qglGetInfoLogARB) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
+GLvoid (APIENTRY * qglGetAttachedObjectsARB) (GLhandleARB containerObj, GLsizei maxCount, GLsizei *count,
+					     GLhandleARB *obj);
+GLint(APIENTRY * qglGetUniformLocationARB) (GLhandleARB programObj, const GLcharARB * name);
+GLvoid (APIENTRY * qglGetActiveUniformARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
+					   GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+GLvoid (APIENTRY * qglGetUniformfvARB) (GLhandleARB programObj, GLint location, GLfloat *params);
+GLvoid (APIENTRY * qglGetUniformivARB) (GLhandleARB programObj, GLint location, GLint *params);
+GLvoid (APIENTRY * qglGetShaderSourceARB) (GLhandleARB obj, GLsizei maxLength, GLsizei *length,
+					  GLcharARB *source);
+
+// GL_ARB_vertex_shader
+GLvoid (APIENTRY * qglVertexAttrib1fARB) (GLuint index, GLfloat v0);
+GLvoid (APIENTRY * qglVertexAttrib1sARB) (GLuint index, GLshort v0);
+GLvoid (APIENTRY * qglVertexAttrib1dARB) (GLuint index, GLdouble v0);
+GLvoid (APIENTRY * qglVertexAttrib2fARB) (GLuint index, GLfloat v0, GLfloat v1);
+GLvoid (APIENTRY * qglVertexAttrib2sARB) (GLuint index, GLshort v0, GLshort v1);
+GLvoid (APIENTRY * qglVertexAttrib2dARB) (GLuint index, GLdouble v0, GLdouble v1);
+GLvoid (APIENTRY * qglVertexAttrib3fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2);
+GLvoid (APIENTRY * qglVertexAttrib3sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2);
+GLvoid (APIENTRY * qglVertexAttrib3dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
+GLvoid (APIENTRY * qglVertexAttrib4fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+GLvoid (APIENTRY * qglVertexAttrib4sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3);
+GLvoid (APIENTRY * qglVertexAttrib4dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
+GLvoid (APIENTRY * qglVertexAttrib4NubARB) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+GLvoid (APIENTRY * qglVertexAttrib1fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRY * qglVertexAttrib1svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRY * qglVertexAttrib1dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRY * qglVertexAttrib2fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRY * qglVertexAttrib2svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRY * qglVertexAttrib2dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRY * qglVertexAttrib3fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRY * qglVertexAttrib3svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRY * qglVertexAttrib3dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRY * qglVertexAttrib4fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRY * qglVertexAttrib4svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRY * qglVertexAttrib4dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRY * qglVertexAttrib4ivARB) (GLuint index, GLint *v);
+GLvoid (APIENTRY * qglVertexAttrib4bvARB) (GLuint index, GLbyte *v);
+GLvoid (APIENTRY * qglVertexAttrib4ubvARB) (GLuint index, GLubyte *v);
+GLvoid (APIENTRY * qglVertexAttrib4usvARB) (GLuint index, GLushort *v);
+GLvoid (APIENTRY * qglVertexAttrib4uivARB) (GLuint index, GLuint *v);
+GLvoid (APIENTRY * qglVertexAttrib4NbvARB) (GLuint index, const GLbyte *v);
+GLvoid (APIENTRY * qglVertexAttrib4NsvARB) (GLuint index, const GLshort *v);
+GLvoid (APIENTRY * qglVertexAttrib4NivARB) (GLuint index, const GLint *v);
+GLvoid (APIENTRY * qglVertexAttrib4NubvARB) (GLuint index, const GLubyte *v);
+GLvoid (APIENTRY * qglVertexAttrib4NusvARB) (GLuint index, const GLushort *v);
+GLvoid (APIENTRY * qglVertexAttrib4NuivARB) (GLuint index, const GLuint *v);
+GLvoid (APIENTRY * qglVertexAttribPointerARB) (GLuint index, GLint size, GLenum type, GLboolean normalized,
+					      GLsizei stride, const GLvoid *pointer);
+GLvoid (APIENTRY * qglEnableVertexAttribArrayARB) (GLuint index);
+GLvoid (APIENTRY * qglDisableVertexAttribArrayARB) (GLuint index);
+GLvoid (APIENTRY * qglBindAttribLocationARB) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
+GLvoid (APIENTRY * qglGetActiveAttribARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
+					  GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+GLint(APIENTRY * qglGetAttribLocationARB) (GLhandleARB programObj, const GLcharARB * name);
+GLvoid (APIENTRY * qglGetVertexAttribdvARB) (GLuint index, GLenum pname, GLdouble *params);
+GLvoid (APIENTRY * qglGetVertexAttribfvARB) (GLuint index, GLenum pname, GLfloat *params);
+GLvoid (APIENTRY * qglGetVertexAttribivARB) (GLuint index, GLenum pname, GLint *params);
+GLvoid (APIENTRY * qglGetVertexAttribPointervARB) (GLuint index, GLenum pname, GLvoid **pointer);
+
+// GL_ARB_framebuffer_object
+GLboolean (APIENTRY * qglIsRenderbufferEXT) (GLuint renderbuffer);
+GLvoid (APIENTRY * qglBindRenderbufferEXT) (GLenum target, GLuint renderbuffer);
+GLvoid (APIENTRY * qglDeleteRenderbuffersEXT) (GLsizei n, const GLuint *renderbuffers);
+GLvoid (APIENTRY * qglGenRenderbuffersEXT) (GLsizei n, GLuint *renderbuffers);
+GLvoid (APIENTRY * qglRenderbufferStorageEXT) (GLenum target, GLenum internalformat,
+					   GLsizei width, GLsizei height);
+GLvoid (APIENTRY * qglGetRenderbufferParameterivEXT) (GLenum target, GLenum pname, GLint *params);
+GLboolean (APIENTRY * qglIsFramebufferEXT) (GLuint framebuffer);
+GLvoid (APIENTRY * qglBindFramebufferEXT) (GLenum target, GLuint framebuffer);
+GLvoid (APIENTRY * qglDeleteFramebuffersEXT) (GLsizei n, const GLuint *framebuffers);
+GLvoid (APIENTRY * qglGenFramebuffersEXT) (GLsizei n, GLuint *framebuffers);
+GLenum (APIENTRY * qglCheckFramebufferStatusEXT) (GLenum target);
+GLvoid (APIENTRY * qglFramebufferTexture1DEXT) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture, GLint level);
+GLvoid (APIENTRY * qglFramebufferTexture2DEXT) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture, GLint level);
+GLvoid (APIENTRY * qglFramebufferTexture3DEXT) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture,
+					    GLint level, GLint layer);
+GLvoid (APIENTRY * qglFramebufferRenderbufferEXT) (GLenum target, GLenum attachment,
+					       GLenum renderbuffertarget, GLuint renderbuffer);
+GLvoid (APIENTRY * qglGetFramebufferAttachmentParameterivEXT) (GLenum target, GLenum attachment,
+							   GLenum pname, GLint *params);
+GLvoid (APIENTRY * qglGenerateMipmapEXT) (GLenum target);
+
+
+
+
+GLvoid (APIENTRY * qglGenQueriesARB) (GLsizei n, GLuint *ids);
+GLvoid (APIENTRY * qglDeleteQueriesARB) (GLsizei n, const GLuint *ids);
+GLboolean (APIENTRY * qglIsQueryARB) (GLuint id);
+GLvoid (APIENTRY * qglBeginQueryARB) (GLenum target, GLuint id);
+GLvoid (APIENTRY * qglEndQueryARB) (GLenum target);
+GLvoid (APIENTRY * qglGetQueryivARB) (GLenum target, GLenum pname, GLint *params);
+GLvoid (APIENTRY * qglGetQueryObjectivARB) (GLuint id, GLenum pname, GLint *params);
+GLvoid (APIENTRY * qglGetQueryObjectuivARB) (GLuint id, GLenum pname, GLuint *params);
+
+
+
 static const char * BooleanToString( GLboolean b )
 {
 	if ( b == GL_FALSE )
@@ -3228,6 +3383,8 @@
 
 #ifdef _MSC_VER
 #	pragma warning (disable : 4113 4133 4047 )
+//#	define GPA( a ) GetProcAddress( glw_state.hinstOpenGL, a )
+
 #	define GPA( a ) GetProcAddress( glw_state.hinstOpenGL, a )
 #else
 #	define GPA( a ) (void *)GetProcAddress( glw_state.hinstOpenGL, a )
@@ -3254,15 +3411,6 @@
 	ri.Printf( PRINT_ALL, "...initializing QGL\n" );
 
 	// NOTE: this assumes that 'dllname' is lower case (and it should be)!
-	if ( strstr( dllname, _3DFX_DRIVER_NAME ) )
-	{
-		if ( !GlideIsValid() )
-		{
-			ri.Printf( PRINT_ALL, "...WARNING: missing Glide installation, assuming no 3Dfx available\n" );
-			return qfalse;
-		}
-	}
-
 	if ( dllname[0] != '!' )
 	{
 		Com_sprintf( libName, sizeof( libName ), "%s\\%s", systemDir, dllname );
@@ -3640,11 +3788,11 @@
 	qwglSwapBuffers              = GPA( "wglSwapBuffers" );
 
 	qwglSwapIntervalEXT = 0;
-	qglActiveTextureARB = 0;
-	qglClientActiveTextureARB = 0;
-	qglMultiTexCoord2fARB = 0;
-	qglLockArraysEXT = 0;
-	qglUnlockArraysEXT = 0;
+//	qglActiveTextureARB = 0;
+	//qglClientActiveTextureARB = 0;
+	//qglMultiTexCoord2fARB = 0;
+	//qglLockArraysEXT = 0;
+//	qglUnlockArraysEXT = 0;
 	qwglGetDeviceGammaRamp3DFX = NULL;
 	qwglSetDeviceGammaRamp3DFX = NULL;
 
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/win32/win_resource.rc bumpy-code/code/win32/win_resource.rc
--- ioq3-for-UrbanTerror-4-bumpy/code/win32/win_resource.rc	2014-06-09 22:09:45.577844080 -0400
+++ bumpy-code/code/win32/win_resource.rc	2014-06-09 22:14:52.948546122 -0400
@@ -7,11 +7,11 @@
 //
 // Generated from the TEXTINCLUDE 2 resource.
 //
-//#ifndef __MINGW32__
-//#include "winres.h"
-//#else
+#ifndef __MINGW32__
+#include "winres.h"
+#else
 #include <winresrc.h>
-//#endif
+#endif
 
 /////////////////////////////////////////////////////////////////////////////
 #undef APSTUDIO_READONLY_SYMBOLS
@@ -70,7 +70,7 @@
 
 STRINGTABLE DISCARDABLE 
 BEGIN
-    IDS_STRING1             "Quake3-UrT"
+    IDS_STRING1             "ioUrbanTerror"
 END
 
 #endif    // English (U.S.) resources
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/win32/win_shared.c bumpy-code/code/win32/win_shared.c
--- ioq3-for-UrbanTerror-4-bumpy/code/win32/win_shared.c	2014-06-09 22:09:45.577844080 -0400
+++ bumpy-code/code/win32/win_shared.c	2014-06-09 22:14:52.948546122 -0400
@@ -34,83 +34,26 @@
 #include <conio.h>
 #include <wincrypt.h>
 
-#ifdef DEDICATED
-WinVars_t	g_wv;
-#endif
-
 /*
 ================
 Sys_Milliseconds
 ================
 */
-
-int Sys_Milliseconds_INIT(void);
-int (*Sys_Milliseconds)(void) = Sys_Milliseconds_INIT;
-
-int Sys_GetTimeStamp_INIT(void);
-int	(*Sys_GetTimeStamp)(void) = Sys_GetTimeStamp_INIT;
-
-qboolean g_usinghpc = qfalse;
-__int64 g_hpf;
-__int64 g_hpc_base;
-int Sys_Milliseconds_HPC(void)
-{
-	__int64 hpc_cur;
-	QueryPerformanceCounter((LARGE_INTEGER*)&hpc_cur);
-	return ((hpc_cur - g_hpc_base) / g_hpf);
-}
-int Sys_GetTimeStamp_HPC(void)
+int			sys_timeBase;
+int Sys_Milliseconds (void)
 {
-	__int64 hpc_cur;
-	QueryPerformanceCounter((LARGE_INTEGER*)&hpc_cur);
-	return (hpc_cur / g_hpf);
-}
+	int			sys_curtime;
+	static qboolean	initialized = qfalse;
 
-int g_sys_timeBase;
-int Sys_Milliseconds_LPC(void)
-{
-	return (timeGetTime() - g_sys_timeBase);
-}
-int Sys_GetTimeStamp_LPC(void)
-{
-	return timeGetTime();
+	if (!initialized) {
+		sys_timeBase = timeGetTime();
+		initialized = qtrue;
 }
+	sys_curtime = timeGetTime() - sys_timeBase;
 
-int Sys_Milliseconds_INIT(void)
-{
-	if (QueryPerformanceFrequency((LARGE_INTEGER*)&g_hpf) && g_hpf >= 1000) 
-	{
-		g_hpf /= 1000; g_usinghpc = qtrue;
-		Com_Printf("Using High Performance Timer.\n");
-		QueryPerformanceCounter((LARGE_INTEGER*)&g_hpc_base);
-		Sys_Milliseconds = Sys_Milliseconds_HPC;
-		Sys_GetTimeStamp = Sys_GetTimeStamp_HPC;
-	}
-	else
-	{
-		if (timeBeginPeriod(1) != TIMERR_NOERROR)
-			Com_Printf("Timer setup failed.");
-
-		Com_Printf("Using Normal Timer.\n");
-		g_sys_timeBase = timeGetTime();
-		Sys_Milliseconds = Sys_Milliseconds_LPC;
-		Sys_GetTimeStamp = Sys_GetTimeStamp_LPC;
-	}
-	
-	return (Sys_Milliseconds)();
+	return sys_curtime;
 }
 
-int Sys_GetTimeStamp_INIT(void)
-{
-	(Sys_Milliseconds)();
-	return Sys_GetTimeStamp();
-}
-
-/*int Sys_Milliseconds (void)
-{
-	return fp_Sys_Milliseconds();
-}*/
-
 #ifndef __GNUC__ //see snapvectora.s
 /*
 ================
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/win32/win_wndproc.c bumpy-code/code/win32/win_wndproc.c
--- ioq3-for-UrbanTerror-4-bumpy/code/win32/win_wndproc.c	2014-06-09 22:09:45.578844072 -0400
+++ bumpy-code/code/win32/win_wndproc.c	2014-06-09 22:14:52.948546122 -0400
@@ -29,28 +29,6 @@
 #define WM_MOUSEWHEEL (WM_MOUSELAST+1)  // message that will be supported by the OS 
 #endif
 
-#ifndef WM_MOUSEHWHEEL
-#define WM_MOUSEHWHEEL                  0x020E
-#endif
-
-#ifndef WM_XBUTTONDOWN
-#define WM_XBUTTONDOWN                  0x020B
-#endif
-
-#ifndef WM_XBUTTONUP
-#define WM_XBUTTONUP                    0x020C
-#endif
-
-#ifndef MK_XBUTTON1
-#define MK_XBUTTON1         0x0020
-#endif
-
-#ifndef MK_XBUTTON2
-#define MK_XBUTTON2         0x0040
-#endif
-
-
-
 static UINT MSH_MOUSEWHEEL;
 
 // Console variables that we need to access from this module
@@ -256,19 +234,6 @@
 	}
 }
 
-static __inline void HandleMouseButtons(WPARAM wParam)
-{
-	int	temp = 0;
-
-	if (wParam & MK_LBUTTON) temp |= 1;
-	if (wParam & MK_RBUTTON) temp |= 2;
-	if (wParam & MK_MBUTTON) temp |= 4;
-	if (wParam & MK_XBUTTON1) temp |= 8;
-	if (wParam & MK_XBUTTON2) temp |= 16;
-
-	IN_MouseEvent (temp);
-}
-
 
 /*
 ====================
@@ -279,11 +244,6 @@
 */
 extern cvar_t *in_mouse;
 extern cvar_t *in_logitechbug;
-
-static HWND g_rawmouseinitializedhwnd = NULL;
-void IN_InitRawMouseInput(HANDLE hWnd);
-void IN_HandleRawMouseData(HRAWINPUT hndlmouse);
-
 LONG WINAPI MainWndProc (
     HWND    hWnd,
     UINT    uMsg,
@@ -293,50 +253,37 @@
 	static qboolean flip = qtrue;
 	int zDelta, i;
 
-	if (in_mouse->integer == 2 && g_rawmouseinitializedhwnd != hWnd)
-	{
-		IN_InitRawMouseInput(hWnd);
-		g_rawmouseinitializedhwnd = hWnd;
-	}
-
-	switch (uMsg)
+	// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/userinput/mouseinput/aboutmouseinput.asp
+	// Windows 95, Windows NT 3.51 - uses MSH_MOUSEWHEEL
+	// only relevant for non-DI input
+	//
+	// NOTE: not sure how reliable this is anymore, might trigger double wheel events
+	if (in_mouse->integer != 1)
 	{
-	case WM_SETCURSOR:
-		if (in_mouse->integer == 2) SetCursor(NULL);
-		break;
-	case WM_MOUSEHWHEEL:
-		// Windows Vista and above...
-
-		if (in_mouse->integer == -1 || in_mouse->integer == 2)
+		if ( uMsg == MSH_MOUSEWHEEL )
 		{
-			// 120 increments, might be 240 and multiples if wheel goes too fast
-			zDelta = ( short ) HIWORD( wParam ) / 120;
-			if ( zDelta > 0 )
+			if ( ( ( int ) wParam ) > 0 )
 			{
-				Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELRIGHT, qtrue, 0, NULL );
-				Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELRIGHT, qfalse, 0, NULL );
+				Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELUP, qtrue, 0, NULL );
+				Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELUP, qfalse, 0, NULL );
 			}
 			else
 			{
-				Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELLEFT, qtrue, 0, NULL );
-				Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELLEFT, qfalse, 0, NULL );
+				Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELDOWN, qtrue, 0, NULL );
+				Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELDOWN, qfalse, 0, NULL );
+			}
+			return DefWindowProc (hWnd, uMsg, wParam, lParam);
 			}
-			
-			if (in_mouse->integer == -1) HandleMouseButtons(wParam);
-
-			// when an application processes the WM_MOUSEHWHEEL message, it must return zero
-			return 0;
 		}
-		break;
-		
 		
+	switch (uMsg)
+	{
 	case WM_MOUSEWHEEL:
 		// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/userinput/mouseinput/aboutmouseinput.asp
 		// Windows 98/Me, Windows NT 4.0 and later - uses WM_MOUSEWHEEL
 		// only relevant for non-DI input and when console is toggled in window mode
 		//   if console is toggled in window mode (KEYCATCH_CONSOLE) then mouse is released and DI doesn't see any mouse wheel
-		
-		if (in_mouse->integer == -1 || (!r_fullscreen->integer && (cls.keyCatchers & KEYCATCH_CONSOLE)))
+		if (in_mouse->integer != 1 || (!r_fullscreen->integer && (cls.keyCatchers & KEYCATCH_CONSOLE)))
 		{
 			// 120 increments, might be 240 and multiples if wheel goes too fast
 			// NOTE Logitech: logitech drivers are screwed and send the message twice?
@@ -374,23 +321,11 @@
 					}
 				}
 			}
-		
-			HandleMouseButtons(wParam);
-
-		
-			
 			// when an application processes the WM_MOUSEWHEEL message, it must return zero
 			return 0;
 		}
 		break;
 
-	case WM_INPUT:
-		if (in_mouse->integer == 2)
-		{
-			IN_HandleRawMouseData((HRAWINPUT)lParam);
-		}
-		break;
-
 	case WM_CREATE:
 
 		g_wv.hWnd = hWnd;
@@ -488,10 +423,23 @@
 	case WM_RBUTTONUP:
 	case WM_MBUTTONDOWN:
 	case WM_MBUTTONUP:
-	case WM_XBUTTONDOWN:
-	case WM_XBUTTONUP:
 	case WM_MOUSEMOVE:
-		if (in_mouse->integer == -1) HandleMouseButtons(wParam);
+		{
+			int	temp;
+
+			temp = 0;
+
+			if (wParam & MK_LBUTTON)
+				temp |= 1;
+
+			if (wParam & MK_RBUTTON)
+				temp |= 2;
+
+			if (wParam & MK_MBUTTON)
+				temp |= 4;
+
+			IN_MouseEvent (temp);
+		}
 		break;
 
 	case WM_SYSCOMMAND:
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/qcommon/cm_trace.c bumpy-code/code/qcommon/cm_trace.c
--- ioq3-for-UrbanTerror-4-bumpy/code/qcommon/cm_trace.c	2014-06-09 22:09:45.518844526 -0400
+++ bumpy-code/code/qcommon/cm_trace.c	2014-06-09 22:14:52.573548890 -0400
@@ -131,10 +131,7 @@
 ================
 */
 float SquareRootFloat(float number) {
-	union {
-		float f;
-		int i;
-	} t;
+	floatint_t t;
 	float x, y;
 	const float f = 1.5F;
 
@@ -735,7 +732,7 @@
 */
 void CM_TraceThroughSphere( traceWork_t *tw, vec3_t origin, float radius, vec3_t start, vec3_t end ) {
 	float l1, l2, length, scale, fraction;
-	float b, c, d, sqrtd;
+	float a, b, c, d, sqrtd;
 	vec3_t v1, dir, intersection;
 
 	// if inside the sphere
@@ -771,7 +768,7 @@
 	//
 	VectorSubtract(start, origin, v1);
 	// dir is normalized so a = 1
-    //a = 1.0f;//dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2];
+	a = 1.0f;//dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2];
 	b = 2.0f * (dir[0] * v1[0] + dir[1] * v1[1] + dir[2] * v1[2]);
 	c = v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2] - (radius+RADIUS_EPSILON) * (radius+RADIUS_EPSILON);
 
@@ -822,9 +819,8 @@
 ================
 */
 void CM_TraceThroughVerticalCylinder( traceWork_t *tw, vec3_t origin, float radius, float halfheight, vec3_t start, vec3_t end) {
-
 	float length, scale, fraction, l1, l2;
-	float b, c, d, sqrtd;
+	float a, b, c, d, sqrtd;
 	vec3_t v1, dir, start2d, end2d, org2d, intersection;
 
 	// 2d coordinates
@@ -870,7 +866,7 @@
 	//
 	VectorSubtract(start, origin, v1);
 	// dir is normalized so we can use a = 1
-	// a = 1.0f;// * (dir[0] * dir[0] + dir[1] * dir[1]);
+	a = 1.0f;// * (dir[0] * dir[0] + dir[1] * dir[1]);
 	b = 2.0f * (v1[0] * dir[0] + v1[1] * dir[1]);
 	c = v1[0] * v1[0] + v1[1] * v1[1] - (radius+RADIUS_EPSILON) * (radius+RADIUS_EPSILON);
 
diff -wBur ioq3-for-UrbanTerror-4-bumpy/code/qcommon/q_shared.h bumpy-code/code/qcommon/q_shared.h
--- ioq3-for-UrbanTerror-4-bumpy/code/qcommon/q_shared.h	2014-06-09 22:09:45.522844494 -0400
+++ bumpy-code/code/qcommon/q_shared.h	2014-06-09 22:14:52.580548838 -0400
@@ -127,13 +136,17 @@
     typedef unsigned __int32 uint32_t;
     typedef unsigned __int16 uint16_t;
     typedef unsigned __int8 uint8_t;
-
-    int Q_vsnprintf(char *str, size_t size, const char *format, va_list ap);
   #endif
 #endif
 
 typedef unsigned char 		byte;
 
+typedef union {
+	float f;
+	int i;
+	unsigned int ui;
+} floatint_t;
+
 typedef enum {qfalse, qtrue}	qboolean;
 
 typedef int		qhandle_t;
@@ -453,12 +458,23 @@
 #endif
 #endif
 
+#define Vector2Set(v, x, y) ((v)[0]=(x), (v)[1]=(y))
 #define VectorClear(a)			((a)[0]=(a)[1]=(a)[2]=0)
 #define VectorNegate(a,b)		((b)[0]=-(a)[0],(b)[1]=-(a)[1],(b)[2]=-(a)[2])
 #define VectorSet(v, x, y, z)	((v)[0]=(x), (v)[1]=(y), (v)[2]=(z))
+#define Vector2Copy(a,b)		((b)[0]=(a)[0],(b)[1]=(a)[1])
 #define Vector4Copy(a,b)		((b)[0]=(a)[0],(b)[1]=(a)[1],(b)[2]=(a)[2],(b)[3]=(a)[3])
+#define Vector4Add(a,b,c)    ((c)[0]=(a)[0]+(b)[0],(c)[1]=(a)[1]+(b)[1],(c)[2]=(a)[2]+(b)[2],(c)[3]=(a)[3]+(b)[3])
+#define Vector4Lerp( f, s, e, r ) ((r)[0]=(s)[0]+(f)*((e)[0]-(s)[0]),\
+  (r)[1]=(s)[1]+(f)*((e)[1]-(s)[1]),\
+  (r)[2]=(s)[2]+(f)*((e)[2]-(s)[2]),\
+  (r)[3]=(s)[3]+(f)*((e)[3]-(s)[3]))
+
+// always snap downwards
+#define Floor(fl) ( (fl) >= 0 ? (int)(fl) : -(int)(-(fl)) )
+#define SnapVector(v) ( (v)[0] = Floor( (v)[0] ), (v)[1] = Floor( (v)[1] ), \
+			(v)[2]=Floor((v)[2]))
 
-#define	SnapVector(v) {v[0]=((int)(v[0]));v[1]=((int)(v[1]));v[2]=((int)(v[2]));}
 // just in case you do't want to use the macros
 vec_t _DotProduct( const vec3_t v1, const vec3_t v2 );
 void _VectorSubtract( const vec3_t veca, const vec3_t vecb, vec3_t out );
@@ -484,6 +500,22 @@
 	return 1;
 }
 
+static ID_INLINE int VectorCompareEpsilon(
+		const vec3_t v1, const vec3_t v2, float epsilon )
+{
+	vec3_t d;
+
+	VectorSubtract( v1, v2, d );
+	d[ 0 ] = fabs( d[ 0 ] );
+	d[ 1 ] = fabs( d[ 1 ] );
+	d[ 2 ] = fabs( d[ 2 ] );
+
+	if( d[ 0 ] > epsilon || d[ 1 ] > epsilon || d[ 2 ] > epsilon )
+		return 0;
+
+	return 1;
+}
+
 static ID_INLINE vec_t VectorLength( const vec3_t v ) {
 	return (vec_t)sqrt (v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
 }
@@ -567,6 +599,7 @@
 
 void vectoangles( const vec3_t value1, vec3_t angles);
 void AnglesToAxis( const vec3_t angles, vec3_t axis[3] );
+void AxisToAngles( vec3_t axis[3], vec3_t angles );
 
 void AxisClear( vec3_t axis[3] );
 void AxisCopy( vec3_t in[3], vec3_t out[3] );
@@ -593,17 +626,48 @@
 qboolean PlaneFromPoints( vec4_t plane, const vec3_t a, const vec3_t b, const vec3_t c );
 void ProjectPointOnPlane( vec3_t dst, const vec3_t p, const vec3_t normal );
 void RotatePointAroundVector( vec3_t dst, const vec3_t dir, const vec3_t point, float degrees );
-void RotateAroundDirection( vec3_t axis[3], float yaw );
+void RotateAroundDirection( vec3_t axis[3], vec_t angle );
 void MakeNormalVectors( const vec3_t forward, vec3_t right, vec3_t up );
 // perpendicular vector could be replaced by this
 
 //int	PlaneTypeForNormal (vec3_t normal);
 
 void MatrixMultiply(float in1[3][3], float in2[3][3], float out[3][3]);
+void VectorMatrixMultiply( const vec3_t p, vec3_t m[ 3 ], vec3_t out );
 void AngleVectors( const vec3_t angles, vec3_t forward, vec3_t right, vec3_t up);
 void PerpendicularVector( vec3_t dst, const vec3_t src );
 int Q_isnan( float x );
 
+void GetPerpendicularViewVector( const vec3_t point, const vec3_t p1,
+		const vec3_t p2, vec3_t up );
+void ProjectPointOntoVector( vec3_t point, vec3_t vStart,
+		vec3_t vEnd, vec3_t vProj );
+float VectorDistance( vec3_t v1, vec3_t v2 );
+
+float pointToLineDistance( const vec3_t point, const vec3_t p1, const vec3_t p2 );
+float VectorMinComponent( vec3_t v );
+float VectorMaxComponent( vec3_t v );
+
+vec_t DistanceBetweenLineSegmentsSquared(
+    const vec3_t sP0, const vec3_t sP1,
+    const vec3_t tP0, const vec3_t tP1,
+    float *s, float *t );
+vec_t DistanceBetweenLineSegments(
+    const vec3_t sP0, const vec3_t sP1,
+    const vec3_t tP0, const vec3_t tP1,
+    float *s, float *t );
+
+#ifndef MAX
+#define MAX(x,y) ((x)>(y)?(x):(y))
+#endif
+
+#ifndef MIN
+#define MIN(x,y) ((x)<(y)?(x):(y))
+#endif
+
+#ifdef _MSC_VER
+float rint( float v );
+#endif
 
 //=============================================
 
@@ -653,6 +717,7 @@
 void Parse1DMatrix (char **buf_p, int x, float *m);
 void Parse2DMatrix (char **buf_p, int y, int x, float *m);
 void Parse3DMatrix (char **buf_p, int z, int y, int x, float *m);
+int Com_HexStrToInt( const char *str );
 
 void	QDECL Com_sprintf (char *dest, int size, const char *fmt, ...) __attribute__ ((format (printf, 3, 4)));
 
@@ -681,6 +746,8 @@
 int Q_islower( int c );
 int Q_isupper( int c );
 int Q_isalpha( int c );
+qboolean Q_isanumber( const char *s );
+qboolean Q_isintegral( float f );
 
 // portable case insensitive compare
 int		Q_stricmp (const char *s1, const char *s2);
@@ -704,6 +768,8 @@
 int Q_PrintStrlen( const char *string );
 // removes color sequences from string
 char *Q_CleanStr( char *string );
+// Count the number of char tocount encountered in string
+int Q_CountChar(const char *string, char tocount);
 
 //=============================================
 
@@ -803,6 +867,11 @@
 	int			modificationCount;	// incremented each time the cvar is changed
 	float		value;				// atof( string )
 	int			integer;			// atoi( string )
+	qboolean	validate;
+	qboolean	integral;
+	float			min;
+	float			max;
+	struct cvar_s *alias;
 	struct cvar_s *next;
 	struct cvar_s *hashNext;
 } cvar_t;
--- ioq3-for-UrbanTerror-4-bumpy/code/qcommon/qfiles.h	2014-06-11 22:13:11.815296760 -0400
+++ bumpy-code/code/qcommon/qfiles.h	2014-06-09 22:14:52.588548779 -0400
@@ -591,6 +553,17 @@
 
 #define drawVert_t_cleared(x) drawVert_t (x) = {{0, 0, 0}, {0, 0}, {0, 0}, {0, 0, 0}, {0, 0, 0, 0}}
 
+typedef struct 
+{
+	float position[3];
+	float uv[2];
+	float light_uv[2];
+	float normal[3];
+	float stv[3];
+	float ttv[3];
+	float rgba[4];
+} staticVert_t;
+
 typedef enum {
 	MST_BAD,
 	MST_PLANAR,
--- ioq3-for-UrbanTerror-4-bumpy/Makefile	2014-06-11 22:11:14.940118867 -0400
+++ bumpy-code/Makefile	2014-06-09 22:14:52.448549812 -0400
@@ -1037,14 +1015,46 @@
   $(B)/client/l_script.o \
   $(B)/client/l_struct.o \
   \
+  $(B)/client/tr_animation.o \
+  $(B)/client/tr_backend.o \
+  $(B)/client/tr_bsp.o \
+  $(B)/client/tr_cmds.o \
+  $(B)/client/tr_curve.o \
+  $(B)/client/tr_flares.o \
+  $(B)/client/tr_font.o \
+  $(B)/client/tr_image.o \
+  $(B)/client/tr_image_tga.o \
+  $(B)/client/tr_image_jpg.o \
+  $(B)/client/tr_image_png.o \
+  $(B)/client/tr_image_pcx.o \
+  $(B)/client/tr_image_bmp.o \
+  $(B)/client/tr_init.o \
+  $(B)/client/tr_light.o \
+  $(B)/client/tr_main.o \
+  $(B)/client/tr_marks.o \
+  $(B)/client/tr_mesh.o \
+  $(B)/client/tr_model.o \
+  $(B)/client/tr_noise.o \
+  $(B)/client/tr_scene.o \
+  $(B)/client/tr_shade.o \
+  $(B)/client/tr_shade_calc.o \
+  $(B)/client/tr_shader.o \
+  $(B)/client/tr_shadows.o \
+  $(B)/client/tr_sky.o \
+  $(B)/client/tr_surface.o \
+  $(B)/client/tr_world.o \
+  \
+  $(B)/client/tr_frag.o \
+
+ifneq ($(USE_INTERNAL_JPEG),0)
+  Q3OBJ += \
   $(B)/client/jcapimin.o \
-  $(B)/client/jchuff.o   \
-  $(B)/client/jcinit.o \
+    $(B)/client/jcapistd.o \
   $(B)/client/jccoefct.o  \
   $(B)/client/jccolor.o \
-  $(B)/client/jfdctflt.o \
   $(B)/client/jcdctmgr.o \
-  $(B)/client/jcphuff.o \
+    $(B)/client/jchuff.o   \
+    $(B)/client/jcinit.o \
   $(B)/client/jcmainct.o \
   $(B)/client/jcmarker.o \
   $(B)/client/jcmaster.o \
@@ -1052,8 +1062,10 @@
   $(B)/client/jcparam.o \
   $(B)/client/jcprepct.o \
   $(B)/client/jcsample.o \
+    $(B)/client/jctrans.o \
   $(B)/client/jdapimin.o \
   $(B)/client/jdapistd.o \
+    $(B)/client/jdatadst.o \
   $(B)/client/jdatasrc.o \
   $(B)/client/jdcoefct.o \
   $(B)/client/jdcolor.o \
@@ -1063,38 +1075,25 @@
   $(B)/client/jdmainct.o \
   $(B)/client/jdmarker.o \
   $(B)/client/jdmaster.o \
+    $(B)/client/jdmerge.o \
   $(B)/client/jdpostct.o \
   $(B)/client/jdsample.o \
   $(B)/client/jdtrans.o \
   $(B)/client/jerror.o \
+    $(B)/client/jfdctflt.o \
+    $(B)/client/jfdctfst.o \
+    $(B)/client/jfdctint.o \
   $(B)/client/jidctflt.o \
+    $(B)/client/jidctfst.o \
+    $(B)/client/jidctint.o \
   $(B)/client/jmemmgr.o \
   $(B)/client/jmemnobs.o \
+    $(B)/client/jquant1.o \
+    $(B)/client/jquant2.o \
   $(B)/client/jutils.o \
   \
-  $(B)/client/tr_animation.o \
-  $(B)/client/tr_backend.o \
-  $(B)/client/tr_bsp.o \
-  $(B)/client/tr_cmds.o \
-  $(B)/client/tr_curve.o \
-  $(B)/client/tr_flares.o \
-  $(B)/client/tr_font.o \
-  $(B)/client/tr_image.o \
-  $(B)/client/tr_init.o \
-  $(B)/client/tr_light.o \
-  $(B)/client/tr_main.o \
-  $(B)/client/tr_marks.o \
-  $(B)/client/tr_mesh.o \
-  $(B)/client/tr_model.o \
-  $(B)/client/tr_noise.o \
-  $(B)/client/tr_scene.o \
-  $(B)/client/tr_shade.o \
-  $(B)/client/tr_shade_calc.o \
-  $(B)/client/tr_shader.o \
-  $(B)/client/tr_shadows.o \
-  $(B)/client/tr_sky.o \
-  $(B)/client/tr_surface.o \
-  $(B)/client/tr_world.o \
+	$(B)/client/jcphuff.o
+endif
 
 ifeq ($(ARCH),i386)
   Q3OBJ += \
